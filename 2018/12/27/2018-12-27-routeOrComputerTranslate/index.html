<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-diy.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-diy.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-diy.png"><link rel="mask-icon" href="/images/logo-diy.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("http://yoursite.com").hostname,root:"/",scheme:"Pisces",version:"7.6.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="抬头本文已在本期刊的未来期刊中被接受发表，但尚未完全编辑。 内容可能会在最终发布之前发生变化 引用信息：DOI 10.1109 &#x2F; TC.2017.2709742，IEEE计算机上的交易题目路由还是计算？基于深度学习的范式转向智能化计算机网络分组传输作者Bomin Mao，学生会员，IEEE，Zubair Md.Fadlullah，高级会员，IEEE，Fengxiao Tang，IEEE学生会员，"><meta property="og:type" content="article"><meta property="og:title" content="论文翻译——毕设任务"><meta property="og:url" content="http://yoursite.com/2018/12/27/2018-12-27-routeOrComputerTranslate/index.html"><meta property="og:site_name" content="技术的路上奔跑"><meta property="og:description" content="抬头本文已在本期刊的未来期刊中被接受发表，但尚未完全编辑。 内容可能会在最终发布之前发生变化 引用信息：DOI 10.1109 &#x2F; TC.2017.2709742，IEEE计算机上的交易题目路由还是计算？基于深度学习的范式转向智能化计算机网络分组传输作者Bomin Mao，学生会员，IEEE，Zubair Md.Fadlullah，高级会员，IEEE，Fengxiao Tang，IEEE学生会员，"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://yoursite.com/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_04_01.png"><meta property="og:image" content="http://yoursite.com/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_05_02.png"><meta property="og:image" content="http://yoursite.com/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_05_03.png"><meta property="og:image" content="http://yoursite.com/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_04.png"><meta property="og:image" content="http://yoursite.com/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_05.png"><meta property="og:image" content="http://yoursite.com/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_06.png"><meta property="og:image" content="http://yoursite.com/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_07.png"><meta property="og:image" content="http://yoursite.com/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_08.png"><meta property="og:image" content="http://yoursite.com/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_09.png"><meta property="og:image" content="http://yoursite.com/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_10.png"><meta property="og:image" content="http://yoursite.com/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_11.png"><meta property="og:image" content="http://yoursite.com/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_02_18_01.png"><meta property="og:image" content="http://yoursite.com/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_02_18_02.png"><meta property="article:published_time" content="2018-12-27T07:15:49.000Z"><meta property="article:modified_time" content="2019-09-05T02:56:29.362Z"><meta property="article:author" content="王钰博"><meta property="article:tag" content="wyb"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://yoursite.com/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_04_01.png"><link rel="canonical" href="http://yoursite.com/2018/12/27/2018-12-27-routeOrComputerTranslate/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><title>论文翻译——毕设任务 | 技术的路上奔跑</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"><a href="https://github.com/Githubwyb" target="_blank" rel="noopener"><img width="149" height="149" style="position:absolute;top:0;right:0;border:0;z-index:999" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_darkblue_121621.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">技术的路上奔跑</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">入门</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/27/2018-12-27-routeOrComputerTranslate/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/12.jpg"><meta itemprop="name" content="王钰博"><meta itemprop="description" content="个人博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="技术的路上奔跑"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">论文翻译——毕设任务</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-12-27 15:15:49" itemprop="dateCreated datePublished" datetime="2018-12-27T15:15:49+08:00">2018-12-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-09-05 10:56:29" itemprop="dateModified" datetime="2019-09-05T10:56:29+08:00">2019-09-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Knowledge/Book/" itemprop="url" rel="index"><span itemprop="name">Book</span> </a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2018/12/27/2018-12-27-routeOrComputerTranslate/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2018/12/27/2018-12-27-routeOrComputerTranslate/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>24k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>22 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="抬头"><a href="#抬头" class="headerlink" title="抬头"></a>抬头</h1><p>本文已在本期刊的未来期刊中被接受发表，但尚未完全编辑。 内容可能会在最终发布之前发生变化 引用信息：DOI 10.1109 / TC.2017.2709742，IEEE计算机上的交易</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>路由还是计算？基于深度学习的范式转向智能化计算机网络分组传输</p><h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>Bomin Mao，学生会员，IEEE，Zubair Md.Fadlullah，高级会员，IEEE，Fengxiao Tang，IEEE学生会员，Nei Kato，IEEE院士，Osamu Akashi，Takeru Inoue和Kimihiro Mizutani</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>近年来，软件定义路由器（SDR）（可编程路由器）已成为一种可行的解决方案，可提供具有易扩展性和可编程性的经济高效的数据包处理平台。多核平台显着地推动了SDR的并行计算能力，使他们能够采用人工智能技术，即深度学习来管理路由路径。在本文中，我们通过深度学习探索数据包处理的新机会，以便将计算需求从基于规则的路由计算转移到基于深度学习的路由估计，以实现高吞吐量数据包处理。尽管深度学习技术已在各种计算领域得到广泛应用，但迄今为止，研究人员还未能有效地利用基于深度学习的路由计算来实现高速核心网络。我们设想一个有监督的深度学习系统来构建路由表，并展示如何使用中央处理单元（CPU）和图形处理单元（GPU）将所提出的方法与可编程路由器集成。我们演示了我们独特的输入和输出流量模式如何通过分析和广泛的计算机模拟来增强基于深度学习的SDR的路由计算。值得一提的是，仿真结果表明我们的方案在延迟、吞吐量和信令开销方面优于基准方法。</p><h1 id="索引术语"><a href="#索引术语" class="headerlink" title="索引术语"></a>索引术语</h1><p>软件定义路由器，网络流量控制，深度学习，骨干网络，核心网络，路由。</p><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;互联网核心中的路由器见证了硬件的几代变化，而路由算法背后的主要思想在传统意义上非常相似。这是因为互联网核心和有线/无线异构骨干网络的构建方式多年来基本保持不变[1]。另一方面，为了适应网络流量的巨大增长，互联网核心基础设施通过添加更多/更大的路由器和更多/更快的链路而继续扩展。越来越大的核心网络推动核心路由器的架构在计算和交换容量方面更加强大。即使最近数据流量激增，网络运营商也面临着流量管理的挑战，以确保服务质量（QoS）以及处理利润下降[2]。传统上，运营商依赖于硬件解决方案以便改善核心网络性能，即通过简单地增加路由器和/或链路的数量和大小，这导致大量的投资挥霍。另一方面，交通管理的软件方面主要关注新路由策略的应用，这些策略在新一代功能强大的硬件架构出现之前可能是不可能的[3]。换句话说，由于连续变化的网络环境，软件驱动的路由策略的进步似乎总是落后于流行的路由策略。为了应用为不同网络服务开发的最先进的软件驱动路由算法，有必要提高核心路由器的可编程性。由于其专有的硬件架构，设计可编程路由器是一个具有挑战性的研究领域。因此，研究人员已经考虑使用软件定义路由器（SDR），其在商用硬件架构上部署可编程路由策略以执行分组处理和传输。作为软件定义网络（SDN）的关键组件，SDR不仅需要支持基于软件的数据包传输，还需要根据网络运营商的要求灵活地执行其他功能，以优化其网络。然而，最近涉及SDR的研究工作主要集中在增强其硬件方面，以便提高与基于硬件的路由器相当的处理吞吐量性能。例如，研究人员和网络制造商已经探索了基于多核的SDR [4]。虽然多核中央处理器（CPU）在相关研究领域占主导地位[5]，但图形处理单元（GPU）——加速SDR正在成为一项激动人心的研究领域。 这背后的原因是GPU同时运行数万个线程以有效处理数据包的固有能力[3]，[6]，[7]。 换句话说，GPU可以执行相同的程序以并行方式处理不同的数据集，这些数据也可以与多核CPU结合以同时进行不同的指令[8]。 GPU和CPU的协作可以显着提升SDR的数据包处理吞吐量[7]，可以将其视为现代骨干网的主流候选者。</p><ul><li>B. Mao，Z. M. Fadlullah，F. Tang和N. Kato在日本仙台东北大学信息科学研究生院工作。<br>电子邮件：{fbomin.mao，zubair，fengxiao.tang &amp; katog} @it.is.tohoku.ac.jp</li><li>O. Akashi，T. Inoue和K. Mizutani与日本电报电话公司（NTT）网络创新实验室合作。<br>电子邮件：{fakashi.osam，inoue.takeru，mizutani.kimihirog} @lab.ntt.co.jp</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了进一步完善骨干路由器硬件架构的研究，还需要改进网络流量控制策略，以满足近几十年来不断增长的流量需求[9]。这是因为良好的路由路径管理技术可以直接缓解（甚至克服）网络拥塞。在本文中，我们将重点放在分组路由策略的设计上。根据最大或最小度量值选择路径的基于规则的传统路由策略（例如，最短路径（SP）算法等）通常归因于显着慢收敛的缺点。此外，它们可能不是特别适合于多度量网络，因为难以手动估计多个度量之间的关系[10]。为了利用各种指标之间的复杂关系来决定最佳路径，基于机器学习的智能网络流量控制系统在广泛的网络环境中引起了广泛关注[11]，[12]。已经利用监督、无监督和强化学习技术来管理许多不同网络场景中的分组路由[13] - [15]，例如无线网状网络（WMN）[14]。然而，由于传统机器学习技术在处理多个网络参数时的低效率以及输入和输出特征化的困难，这些智能策略仍然基于规则的传统路由[16]，[17]。自2006年以来，已经见证了在深度学习架构（例如，多层神经网络）中已经实现了逐步突破，使得它们能够适应曾经只有人类占据主导地位的极其复杂的活动，例如谷歌的AlphaGo在复杂的棋盘游戏中的表现[18]。此外，GPU已经成为运行深度学习算法的最可行的硬件平台，因为它们具有高度并行的计算能力，而且还有各种GPU制造商提供的大量编程工具包[8]。因此，通过利用GPU加速的SDR来利用深度学习算法来实现智能网络流量控制（例如，智能路由管理）是可行的。</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_04_01.png" width="30%"> - 图1：最近的跨学科趋势表明涉及计算系统，计算机网络和机器智能的跨学科领域。 特别地，由于CPU / GPU技术的进步和深度学习，网络流量控制系统正变得健壮和智能<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在本文中的工作贡献如下。首先，我们从三个方面探讨路由策略，即网络流量控制，深度学习和CPU / GPU计算架构，如图1所示。其次，我们提出了一种基于深度学习的GPU加速SDR路由表构建方法。在我们的提议中，我们采用有监督的深度信念架构（DBA）[19]来计算以边缘路由器的流量模式为输入的后续节点（即路由器）。第三，我们根据边缘路由器的传入流量模式，为我们采用的DBA提供输入和输出的独特特征。根据收集的数据训练所提出的DBA，所述数据包括入站流量模式和相应的后续节点（即，路由器）。此外，我们还演示了经过培训的DBA如何预测下一个节点。第四，我们展示了基于深度学习的路由策略在较低信令开销和快速收敛方面的优势，从而显着改善了流量控制。第五，我们通过分析和广泛的仿真结果证明了我们提出的基于深度学习的解决方案与基准路由方法相比的有效性。特别是，我们演示了我们的提案如何在GPU加速的SDR上工作，并在分析其复杂性后评估运行路由策略的时间成本。结果表明，所提出的路由策略在GPU上的运行速度比在CPU上快100多倍。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本文的其余结构如下。 第2节包括相关的研究工作。在第3部分中，我们描述了我们提出的路由DBA结构及其在GPU加速SDR中的工作原理。然后，我们在第4节和第5节介绍基于深度学习的路由策略的三个阶段，分析我们提案的复杂性，并比较GPU和CPU的理论时间成本。我们的提案的网络性能评估在第6节中介绍。最后，第7节结束了本文。</p><h1 id="2-相关研究工作"><a href="#2-相关研究工作" class="headerlink" title="2. 相关研究工作"></a>2. 相关研究工作</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本节中，我们将从硬件和软件角度介绍相关的研究工作，分别考虑SDR和深度学习的最新技术。 此外，在讨论深度学习相关研究的同时，我们还描述了文献中存在的相关机器智能路由策略。</p><h2 id="2-1-SDR相关研究工作"><a href="#2-1-SDR相关研究工作" class="headerlink" title="2.1 SDR相关研究工作"></a>2.1 SDR相关研究工作</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于深度学习执行需要高性能计算硬件的支持，因此有必要讨论最先进的SDR技术。尽管将数据包处理逻辑实施到硬件中的方法继续提高路由器的线路速率高达100 Gbps，但应用新的网络流量控制算法仍然是一个具有挑战性的问题，因为在可行性和可扩展性方面存在专用硬件的缺点[6],[20]。另一方面，基于通用硬件的SDR在分组处理中不是很有效，尽管它是可编程的和灵活的。由于多核解决方案可以显着提高计算能力，因此学术界和工业界的研究人员对利用CPU或GPU提供的多核和/或线程并行运行路由任务以提高处理吞吐量表现出极大的兴趣。目前的SDR [6]，[21]。[21]中介绍的RouteBricks架构探索了一种新颖的网络架构，其中数据包在运行在通用PC硬件集群上的软件中处理。RouteBricks的IPv4转发吞吐量已经显示为高达8.7 Gbps和64B数据包。但是，由于CPU成为更多计算密集型应用程序的瓶颈，其性能可能不会超过10 Gbps。作为解决此问题的方法，PacketShader架构[3]将并行数据包处理的计算需求从CPU转移到GPU，因为GPU与CPU相比包含更多内核。使用单个商品PC评估此体系结构表明PacketShader能够以39 Gbps转发64B IPv4数据包。此外，在[3]中指出，通过扩展I / O集线器的性能，线速率可以进一步提高到100 Gbps [7]。此外，包括英特尔和思科在内的网络制造商正在采用类似的项目来开发SDR架构中的高性能计算设备并开发商业产品[4]，[5]。从上述工作中可以注意到，当前的可编程SDR可以提供有竞争力的线路速率（即，与传统的专用设计路由器相比，费用要低得多），同时保持灵活性和可扩展性的强度。</p><h2 id="2-2-深度学习与机器智能路由策略的相关研究工作"><a href="#2-2-深度学习与机器智能路由策略的相关研究工作" class="headerlink" title="2.2 深度学习与机器智能路由策略的相关研究工作"></a>2.2 深度学习与机器智能路由策略的相关研究工作</h2><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_05_02.png" width="80%"><ul><li>图2：考虑系统模型和问题陈述。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于机器学习对于预测网络参数很有用，一些研究人员已经尝试利用人工神经网络（ANN）（一种机器学习技术）来预测网络流量[15]，链路带宽或其他指标[22]。超过几个时间间隔。然而，这些策略的效率受到传统机器学习技术的缺点的限制，主要是因为缺乏适当的深层结构学习算法，足够大的训练数据的可用性等等。实际上，根据[11]中的工作，尽管添加层可以在极其复杂的应用中提取更高级别的特征，但是包含许多隐藏层的传统深度神经网络架构表现出与浅层相比较差的性能。最近，深度学习成为一种有前途的计算模型，可以有效地利用多个处理层从多个抽象层次的数据中提取特征[11]。此方法使用通用非线性模块将一个级别的表示转换为更高和更抽象级别的表示，然后组合这些表示，通过它可以自动且准确地学习特征[23]。 2006年引入了Greedy Layer-Wise培训，利用无监督学习程序对深度神经网络体系结构进行预训练，彻底改变了深度学习技术[19]，[24]。通过Greedy LayerWise预训练，接着是基于反向传播算法的整个深层架构的微调，深度学习在语音识别等许多复杂应用中取得了创纪录的成果[25]等等。将深度学习应用于语音识别的一个很好的例子是Apple的智能助手叫做“Siri”[26]。在传统上由人类主导的其他领域，研究人员已经探索了深度学习的应用并取得了令人鼓舞的成果，例如谷歌的AlphaGo在非常复杂的棋盘游戏中[18]。从文献中可以明显看出，深度学习技术已成为通常需要大量计算的应用中的最新技术。一方面，深度学习应用仅限于图像/字符/模式识别和自然语言处理领域[11]。另一方面，尚未成功尝试对网络流量控制系统的深度学习，其仍继续经历不断增长的计算负担。这是因为连接到互联网的设备数量越来越多，全球网络流量在最近几十年中爆炸式增长[9]。因此，在设计路由策略以满足严格和不断变化的网络要求时，网络运营商需要考虑更多参数和更复杂的规则。根据[16]，深度学习具有很好的潜力，可以应用于网络流量控制系统，通过考虑各种要求来估计最佳路径。此外，由于将深度学习应用于路由仍然是一个非常新的主题，因此以前的研究工作都没有尝试将深度学习整合到SDR中。另一方面，我们的动机来自于SDR与深度学习密切相关的事实，因为许多SDR使用多核平台（例如GPU）。这为在SDR中采用基于深度学习的智能路由策略铺平了道路。从这一点来看，我们尝试通过采用GPU驱动的SDR来执行深度学习技术来估计下一个节点以实现更好的路由管理，从而考虑硬件和软件两个方面。</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_05_03.png" width="80%"><ul><li>图3：考虑提出的深度学习系统的模型。</li></ul><h1 id="3-基于深度学习的路由策略设计"><a href="#3-基于深度学习的路由策略设计" class="headerlink" title="3. 基于深度学习的路由策略设计"></a>3. 基于深度学习的路由策略设计</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本节中，我们将介绍如何设计深度学习结构以在GPU加速的SDR上构建路由表。首先，我们提出深度学习结构的输入和输出的详细表征，然后我们描述我们选择的架构，DBA。 接下来，讨论所提出的路由表构造方法如何在GPU加速的SDR上工作。</p><h2 id="3-1-输入和输出设计"><a href="#3-1-输入和输出设计" class="headerlink" title="3.1 输入和输出设计"></a>3.1 输入和输出设计</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们考虑的核心网络系统模型在图2中描绘，其包括多个有线骨干路由器。值得注意的是，也可以考虑无线骨干网络。在所考虑的网络中，假设边缘路由器连接到不同类型的网络，例如蜂窝网络，WMN等。从后面的网络生成的数据包到达边缘路由器，并且发往其他边缘路由器以进行传送。另一方面，内部路由器只负责将数据包转发到适当的边缘路由器。传统上，每个路由器周期性地将信令分组转发到其他路由器以通知延迟值或其到其邻居的链路的一些其他度量。然后，每个路由器可以利用该信息来计算用于将数据分组发送到目的地路由器的下一个节点。这种方法在大多数情况下都能很好地工作，因为每个路由器都可以根据获得的所有网络链路的信息做出最佳决策。然而，当网络中的一些路由器由于压倒性的流量需求而拥挤时，计算下一个节点的传统方法遭受慢收敛。同时，周期性信令交换加剧了交通拥堵。此外，传统的路由方法无法处理网络环境持续变得更加复杂的场景，这需要网络运营商考虑各种不相关的参数来确定路由规则。由于深度学习方法已应用于许多复杂的活动以自动探索各种输入之间的关系，我们尝试在本节的其余部分采用深度学习进行路由。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于在每个路由器处观察到的流量模式直接指示该路由器的流量情况，因此我们采用流量模式作为深度学习模型的输入。如第1节所述，深度学习结构用于计算路由路径。因此，我们选择路由路径作为模型的输出。因此，图3（a）表明深度结构的输入为业务模式、路由路径作为输出。之后，关键的挑战是如何表征深度学习结构的输入和输出。为了表征输入，我们使用每个路由器上的流量模式即每个时间间隔内路由器的入站数据包数量，如图3（b）所示。如果我们假设计入入站数据包的时间间隔是$\Delta t$秒，那么对于每个路由器，我们可以采用最后一个$\beta \Delta t$（$\beta$为正整数）秒内每个时间间隔内的入站数据包数量作为流量模式。因此，通过假设网络由$N$个路由器组成，我们可以使用$\beta$行和$N$列的矩阵来表示网络中所有路由器的流量模式，并将矩阵中的$\beta N$元素的值输入到深度学习结构的输入层。请注意，$\beta$的值不应该太大，因为很久以前的流量模式对当前网络分析没有影响。此外，如果$\beta$的值太大，则深度学习结构具有高复杂性和低效率。在我们提出的深度学习结构中，仿真结果表明，将$\beta$的值设置为1是足够准确的。因此，深度学习结构的输入可以看作是$N$维向量，其第$i^{th}$个元素是最后$\Delta t$秒内第$i^{th}$个路由器的流量模式。接下来，我们需要设计输出层。出于路由的目的，深度学习结构需要输出路由路径。因此，输出层可以设计为提供类似于集中式路由的整个路径，或者仅提供类似于分布式路由策略的下一个节点。由于其较低的复杂性和较高的容差，后者在我们的提案中被选择。对于由$N$个路由器组成的网络，我们使用由$N$个二进制元素组成的向量来表示输出。在向量中，只有一个元素的值为1，其顺序表示下一个节点。这意味着如果$N$维向量中的第$i^{th}$个元素是1，则选择所考虑的网络中的第$i^{th}$个路由器作为下一个节点。总之，我们可以使用两个$N$维向量$x$和$y$来表示深度学习结构的输入和输出，$x$和$y$的示例如下：</p><p>$$ x = (tp_1, tp_2, …, tp_{N - 1}, tp_N), \tag{1}$$<br>$$ y = (0, 1, …, 0, 0), \tag{2} $$</p><p>其中$tp_i$表示路由器$i$的流量模式，其由上一时间间隔中的入站数据包的数量来度量。 此外，在向量$y$中，我们可以发现$y_2 = 1$，这意味着选择路由器2作为下一个节点。 由于$y$的二进制值，深度学习结构是逻辑回归模型，我们需要接下来设计。</p><h2 id="3-2-深度学习结构设计"><a href="#3-2-深度学习结构设计" class="headerlink" title="3.2 深度学习结构设计"></a>3.2 深度学习结构设计</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了设计深度学习结构，需要用于执行监督训练的标记数据（即，多组$(x, y)$）。 为了完成计算具有流量模式的下一个路由器的任务，我们选择图3（c）所示的DBA作为我们的深度学习结构，因为它在所有深度学习模型中最常见和有效[27]。 如图所示，我们假设DBA由L层，输入层，$x$，输出层，$y$和$(L - 2)$隐藏层组成。 DBA也可以看作是一堆$(L - 2)$受限玻尔兹曼机器（RBMs）和一个逻辑回归层作为顶层。 每个RBM的结构如图3（d）所示。可以看出，每个RBM由两层组成，可见层，$v$和隐藏层$h$。两层中的单元通过加权链路连接，而同一层中的单元未连接。应注意，对两层中的每个单元给予加权偏差。术语$w_{ji}$表示连接隐藏层中的单元$j$和可见层中的单元$i$的链路的重量。此外，$a_i$和$b_j$分别表示可见层中的单元$i$和隐藏层中的单元$j$的偏置。隐藏层中学习单元的激活值用作DBA中上RBM的“可见数据”。如第2.2节所述，深度学习训练过程包括两个步骤：初始化结构的Greedy Layer-Wise训练和微调结构的反向传播过程。对于DBA，初始过程是训练每个RBM，这是一个无监督的学习过程，原因是RBM是一个无向图形模型，其中可见层中的单元使用对称加权连接连接到随机隐藏单元，如图所示.3（d）[28]。在训练RBM时，将未标记的数据集给予可见层，并且重复调整权重和偏差的值，直到隐藏层可以重建可见层。因此，训练后的隐藏层可以看作是可见层的抽象特征。训练RBM是使隐藏层最小化重建错误的过程。为了对训练过程进行数学建模，我们使用如下给出的可见层的对数似然函数。然后，训练过程是更新权重和偏差的值以最大化对数似然函数的值。</p><p>$$ l(\theta, a) = \sum_{t = 1}^{m} log p(v^{(t)}) \tag{3} $$</p><p>其中$\theta$表示由隐藏层的权重和偏差的所有值组成的向量。 $\theta$可写为$\theta = (w, b)$。$w$和$b$分别表示由隐藏单元$b_j$的所有权重，$w_{ji}$和偏差组成的向量。 $a$由可见单元的偏差组成，$a_i$。 $m$表示训练数据的数量。 $v^{(t)}$是$t^{th}$训练数据，其概率为$p(v^{(t)})$。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了最大化$l(\theta, a)$，我们可以使用$l(\theta, a)$的梯度下降来调整$w$，$a$和$b$，其可以在等式4和5中描述。</p><p>$$ \theta := \theta + \eta\frac{\partial l(\theta, a)}{\partial \theta} \tag{4} $$</p><p>$$ a_i := a_i + \eta\frac{\partial l(\theta, a)}{\partial a_i} \tag{5} $$</p><p>其中$\eta$是深度学习的学习率。 这里，$\theta$表示任何$w_{ji}$和任何$b_j$。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了计算$p(v)$的值（代表任何$p(v^{(t)})$），我们需要将RBM建模为能量模型，因为RBM是对数线性马尔可夫随机场（MRF）的特定形式[29]。 能量函数$E(v, h)$和联合概率函数$p(v, h)$定义如下。</p><p>$$ E(v, h) = -\sum_{i} a_i v_i - \sum_{j} b_j h_j - \sum_{i}\sum_{j}h_j w_{ji} v_i \tag{6} $$</p><p>$$ p(v, h) = \frac{e^{-E(v, h)}}{Z} \tag{7} $$</p><p>$$ Z = \sum_{v} \sum_{h} e^{-E(v, h)} \tag{8} $$</p><p>其中$v_i$和$h_j$分别是图3（d）所示的可见层中的单元$i$和隐藏层中的单元$j$。 $Z$表示归一化常数分区函数。 此外，$p(v)$和$p(v, h)$之间的关系可以表示如下。</p><p>$$ p(v) = \sum_{h} p(v, h) \tag{9} $$</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以使用等式3到9来获得$\theta$[28]的值。然而，等式8中$\sum_{v} \sum_{h}$的计算的复杂度是$2^{n_v + n_h}$，其非常高（$n_v$和$n_h$分别表示向量$v$和$h$的维度）。另一个问题是，为了计算等式8，有必要但不可能考虑$v$和$h$的所有可能值而不是仅考虑所获得的训练数据。为了解决这些问题，Hinton等人。提出了对比分歧（CD）方法[30]。 CD的主要思想是使用吉布斯采样方法对v和h的值进行采样以逼近实际值，因为一层的条件分布概率（同时给出了另一层的值），例如$p(v | h; \theta, a)$，可以计算出来。文中省略了CD的详细程序，可以在[30]中找到。由于每个单元的值独立于同一层中的其他单元，当一个层固定时，另一层的条件分布概率可以如下计算，</p><p>$$ p(v | h; \theta, a) = \prod_i p(v_i | h; \theta, a) \tag{10} $$</p><p>$$ p(h | v; \theta, a) = \prod_j p(h_j | v; \theta, a) \tag{11} $$</p><p>其中$p(v | h; \theta, a)$和$p(h | v; \theta, a)$分别是给定h的v的条件概率和给定$v$的$h$的条件概率。$p(v_i | h; \theta, a)$是隐藏层固定时可见层中单元$i$的条件概率分布。 此外，$p(h_j | v; \theta, a)$是当可见层固定时隐藏层中单元$j$的条件概率分布。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果可见层和隐藏层中的单元的值都是二进制的，则$p(v_i = 1 | h; \theta, a)$和$p(h_j = 1 | v; \theta, a)$如下给出。</p><p>$$ p(v_i = 1 | h; \theta, a) = sigm(\sum_{j} w_{ji} h_j + a_i) \tag{12} $$</p><p>$$ p(h_j = 1 | v; \theta, a) = sigm(\sum_{i} w_{ji} v_i + b_j) \tag{13} $$</p><p>其中$sigm$表示$sigmoid$激活函数，$sigm(x) = \frac{1}{1 + e^{-x}}$。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于表示入站数据包数量的DBA输入单元的值是连续的并受许多因素的影响，我们使用高斯概率分布来模拟流量模式[31]。因此，对于我们提出的DBA中的$RBM_1$，等式6和等式12应该修改如下。</p><p>$$ E(v, h) = -\sum_{i} \frac{(v_i - a_i)^2}{2\sigma_i^2} - \sum_{j} b_j h_j - \sum_{i}\sum_{j} \frac{v_i}{\sigma_i} h_j w_{ji} \tag{14} $$</p><p>$$ p(v_i | h; \theta, a) = N(a_i + \sigma_i \sum_{j} h_j w_{ji}, \sigma_i^2) \tag{15} $$</p><p>其中$\sigma_i$是单位$v_i$的方差值。 $N(a_i + \sigma_i \sum_{j} h_j w_{ji}, \sigma_i^2)$表示具有平均值$(a_i + \sigma_i \sum_{j} h_j w_{ji})$和方差$\sigma_i$的高斯分布。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图3（b）所示，最后一个RBM, $RBM_{L - 2}$由三层DBA组成，因为DBA在我们的提案中经过了监督培训[32]。 因此，$RBM_{L - 2}$的可见层不仅包括$RBM_{L - 3}$的隐藏层，还包括DBA的输出层$y$。 它的隐藏层是DBA的顶层隐藏层。 $RBM_{L - 2}$的结构如图3（e）所示，其能量函数表示如下。 为了与其他RBM保持一致，我们使用$v$和$h$分别表示$RBM_{L - 3}$的隐藏层和顶部隐藏层。</p><p>$$ E(v, h, y) = -\sum_{i} a_i v_i - \sum_{j} b_j h_j - \sum_{k} c_k y_k \\ - \sum_{i} \sum_{j} h_j w_{ji} v_i - \sum_{j} \sum_{k} h_j w_{jk} y_k \tag{16} $$</p><p>其中$y$表示输出层中的向量。 $c_k$是单位$y_k$的偏差。 $w_{jk}$表示连接单元$h_j$和$y_k$的链路的权重。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于$v$和$y$中的单位彼此独立，因此由$v$和$y$组成的连接向量的条件分布是，</p><p>$$ p(v, y | h; \theta, a) = p(v | h; \theta, a)p(y | h; \theta, a) \\ = \prod_{i} p(v_i | h; \theta, a) \prod_{k} p(y_k | h; \theta, a) \tag{17} $$</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们使用上述方法来训练每个RBM。 在给定的训练数据中，第一RBM的可见层的值是$x$。 并且在训练每个RBM之后，其隐藏层的学习激活值被用作DBA中下一个RBM的“数据”。 在这里，我们可以发现，我们通过训练RBM一次训练DBA的一个隐藏层。 以这种方式，DBA被初始化并且$\theta$的值几乎是最佳的。 然后利用反向传播的方法来微调DBA。 我们监督训练的目的是最小化DBA的输出（由$h_\theta(x)$表示）与标记的输出$y$之间的差异。 我们使用交叉熵成本函数来测量它们在公式18 [28]中给出的差异。</p><p>$$ C(\theta) = -\frac{1}{m} \sum_{t = 1}^{m} (y^{(t)} log(h_\theta(x^{(t)})) \\ + (1 - y^{(t)}) log(1 - h_\theta(x^{(t)}))) \\ + \frac{\lambda}{2} \sum_{l = 2}^{L} \sum_{j = 1}^{n_l} \sum_{i = 1}^{n_{l - 1}} (w_{ji}^{(l)})^2 \tag{18} $$</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_04.png" width="80%"> - 图4：GPU的架构以及如何在GPU加速的SDR中传递数据包的步骤。<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，$(x^{(t)}, y^{(t)})$是$t^{th}$训练数据。 $h_\theta(x^{(t)})$表示当DBA的参数是$\theta$并且输入是$x^{(t)}$时DBA的输出。 在等式的右边，我们可以发现$C(\theta)$由两部分组成。 第一部分表示DBA输出与标记输出之间的差异，当$y^{(t)} = h_\theta(x^{(t)}) = 0$或1时，对于所有$t$，其值为0，否则，大于0。 part用于防止训练过程过度拟合。 为了最小化反向传播过程中$C(\theta)$的值，我们使用$C(\theta)$的梯度下降来更新$\theta$，如公式19 [33]所示。</p><p>$$ \theta := \theta - \eta_{bp}\frac{\partial C(\theta)}{\partial \theta} \tag{19} $$</p><p>其中$\eta_{bp}$是反向传播过程中的学习率。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微调算法有效地工作，因为$\theta$的值通过Greedy LayerWise训练方法得到很好的初始化，而不是随机设置。 在微调DBA之后，我们可以获得参数$\theta(w, b)$的最佳值。 $a$的值不在反向传播步骤中训练，因为它不属于最终的DBA，并且仅用于训练每个RBM。 在本节的其余部分，我们将演示如何在GPU加速的SDR中使用所提出的深度学习结构。</p><h2 id="3-3-考虑路由器架构"><a href="#3-3-考虑路由器架构" class="headerlink" title="3.3 考虑路由器架构"></a>3.3 考虑路由器架构</h2><p>在本节中，我们简要介绍了GPU体系结构以及在一般PC平台上工作的基于深度学习的路由策略的过程，可以将其视为我们考虑的SDR。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图4所示，GPU由全局存储器，L2高速缓存和若干流处理多处理器（SM）组成，每个处理器由许多流处理器（SP）组成。 由于GPU具有许多计算核心，因此在接收工作负载时会同时启动数万个线程，并且每个线程在不同的数据集上运行相同的程序。 因此，GPU计算被认为是单指令多数据（SIMD）编程模型，其非常适合于运行深度学习。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如第1部分所述，基于普通PC的GPU加速SDR的报告线速率已高达40 Gbps，在本文中，我们选择一般的基于PC的SDR来构建路由表并执行我们的深度学习基于路由算法。图4示出了分组如何通过所考虑的SDR的架构中的相关四个部分的步骤，即GPU，CPU，网络接口卡（NIC）和主存储器。为了运行基于深度学习的路由算法，每个SDR都需要在训练阶段进行初始化，在此期间，网络中的SDR不需要处理任何数据包，只需利用他们的GPU来训练他们的DBA并记录最终值。他们的DBA的参数。在训练阶段之后，网络中的所有路由器都需要将其DBA的参数值发送到所有边缘路由器。因此，每个边缘路由器都可以使用这些参数来恢复任何DBA，以便在运行阶段构建到任何目标路由器的整个路径，而内部路由器只根据路径转发数据包。如图4所示，我们根据SDR中传输数据包的顺序给出了GPU加速SDR的主要架构和标签。我们可以发现（1）进入NIC的数据包通过直接内存访问（DMA）复制到主机内存。在整个过程中，（2）CPU从主存储器复制一些数据包以填充其缓冲区。 （3）然后在CPU上运行的软件分析这些数据包并采取一些必要的过程，如错误检查，减少寿命等。此外，CPU对不同类型的分组采用不同的过程。 （4）对于数据包，CPU提取标头并将它们发送到GPU的全局存储器，而CPU将整个信令包发送到GPU的存储器。请注意，CPU需要缓冲数据包和信令包的标头，直到达到给定的大小，然后将批量的标头或数据包发送到GPU，而不是逐个发送。由于GPU可以并行处理数百个数据包，因此批处理可以提高吞吐量，而其对延迟的负面影响已被证明可以忽略不计[6]。 （5）在从CPU获得报头和数据包之后，应该注意边缘路由器和内部路由器的GPU执行不同的数据包处理。在边缘路由器的GPU上运行的软件使用信令分组携带的流量模式作为恢复的DBA的输入。然后，DBA可以输出下一个节点，边缘路由器的GPU可以利用这些节点构建数据包的整个路径，并将相应的路径附加到接收的报头。另外，GPU还需要将每个分组的下一个节点信息发送到CPU。另一方面，内部路由器的GPU不需要计算数据包的路径，只需读取数据包头中的路径并将结果发送到CPU。此外，每个GPU并行处理这些标头并在缓冲区中填充它们。然后，CPU（6）从GPU复制处理后的数据包的头部，并且（7）将包复制回主存储器。同时，（8）CPU指示NIC转发批处理的位置，之后，（9）NIC通过另一个DMA从主存储器取出数据包。此外，可以删除将数据包复制到GPU和从GPU复制数据包的过程，因为我们可以利用GPU和CPU的映射存储器，从而可以进一步减少延迟。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本节中，我们提供了我们考虑的系统模型，深度学习结构，并解释了基于GPU的SDR如何利用深度学习结构。 在下一节中，我们将介绍我们提出的基于深度学习的路由算法的步骤。</p><h1 id="4-基于建议的深度学习路由策略的程序"><a href="#4-基于建议的深度学习路由策略的程序" class="headerlink" title="4 基于建议的深度学习路由策略的程序"></a>4 基于建议的深度学习路由策略的程序</h1><p>在本节中，我们将重点介绍利用DBA计算下一个节点的过程，这些节点用于构建图2中所考虑的核心网络中的路由路径。这些过程可分为三个步骤，即初始化，训练和运行阶段。 下面提供了三个阶段的细节。</p><h2 id="4-1-初始化阶段"><a href="#4-1-初始化阶段" class="headerlink" title="4.1 初始化阶段"></a>4.1 初始化阶段</h2><p>在初始化阶段，我们需要获取数据来训练我们提出的DBA。 如第3节所述，我们采用监督学习来训练我们提出的DBA系统。 因此，初始化阶段的目标是获得由输入矢量和相应的输出矢量组成的标记数据。 如前面部分所述，输入向量应该是所考虑的核心网络中路由器的流量模式。 输出向量应指示对应于给定流量模式的下一个节点。 为了获得这种训练数据，我们可以接近许多可用的数据集源，例如应用互联网数据分析中心（CAIDA）[34]，并提取交通信息和相关的路由路径。 另一种方法是在我们考虑的网络中运行传统的路由协议，并记录每个路由器及其路由表的入站数据包的数量。</p><h2 id="4-2-训练阶段"><a href="#4-2-训练阶段" class="headerlink" title="4.2 训练阶段"></a>4.2 训练阶段</h2><p>在培训阶段，我们使用获得的数据来训练我们设计的DBA。 训练过程包括两个步骤：使用Greedy Layer-Wise训练方法初始化每个DBA，并使用反向传播方法微调参数$\theta(w, b)$。 在训练阶段之后，我们可以获得$\theta(w, b)$的值。</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_05.png" width="80%"><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如第3.1节所述，DBA的输出是表示下一个节点的向量，这意味着它需要几个DBA来构建整个路径。假设网络中只有一个路由器训练并运行所有DBA，并且像网络中的集中控制策略一样产生网络中的所有路径，则路由器的计算量将非常高。而且，这样的中央路由器需要大量的时间和资源来计算所有路径，导致延迟增加和无保证的准确性。为了减少对路由器的计算要求并提高学习准确性，我们将训练任务分成几个部分，并将它们分发到目标核心/骨干网络中的每个路由器。这意味着所考虑的网络中的每个路由器都需要训练多个DBA，每个DBA计算从其自身到目的地路由器的下一个节点。路由器需要训练的DBA数量取决于其目标路由器的数量。设$N$和$I$分别表示路由器的总数和内部路由器的数量。因此，每个内部路由器的目标节点数量是$(N - I)$，而每个边缘路由器具有$(N - I - 1)$个目标节点，因为源路由器和目标路由器不能相同。因此，每个内部路由器都需要训练$(N - I)$DBAs，而所有边缘路由器都需要训练$(N - I - 1)$DBAs。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了更清楚地描述培训阶段，我们只关注一个DBA的培训程序，这也适用于我们提案中的其他DBA。训练DBA的主要程序在算法1中给出。训练阶段的输入是训练数据$(x, y)$以及DBA，$L$和$n$的参数，以及学习速率，$\eta_{CD}$和$\eta_{bp}$。如算法1所示，训练阶段主要包括两个步骤：贪婪层智能训练循环，训练每个RBM，如步骤1至3所示，以及后面的反向传播过程，以微调链接之间的链接权重。步骤4中显示的图层。通过Greedy Layer-Wise训练，DBA初始化时$\theta (w, b)$的值几乎达到全局最优值。然后使用反向传播算法来微调整个结构以最小化成本函数的值。在成本函数不超过给定值或次数达到上限之前，调整过程不会停止。一旦反向传播结束，就记录每个DBA的$\theta (w, b)$的值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如前所述，每个边缘路由器都需要训练$(N - I - 1)$DBAs，而每个内部路由器需要训练$(N - I)$DBAs，这意味着每个边缘路由器都可以获得$(N - I - 1)$个DBAs的$\theta$ 每个内部路由器可以获得$(N - I)$DBAs的$\theta$。 然后，每个边缘路由器需要将其$(N - 1 - 1)$DBAs的$\theta$发送到其他$(N - 1 -1)$边缘路由器。 此外，每个内部路由器都需要将其$(N - I)$DBAs的$\theta$发送到所有边缘路由器。 因此，每个边缘路由器获得网络中所有路由器的所有DBAs的$\theta$，并且$\theta$的组数是$(N - 1)(N - 1)$。 让$DBA_{ij}$代表路由器$i$中的DBA作为目的路由器$j$，$\theta_{ij}$是其参数。 由于边缘路由器获得网络中所有DBA的$\theta$，因此它们可以用$\theta_{ij}$构造相应的$DBA_{ij}$。 应该注意的是，$i \neq j$。</p><ul><li>表1: $R_3$中内置的路由表</li></ul><table><thead><tr><th align="center">终点</th><th align="center">路径</th></tr></thead><tbody><tr><td align="center">$R_1$</td><td align="center">$R_3 \rightarrow R_2 \rightarrow R_1$</td></tr><tr><td align="center">$R_2$</td><td align="center">$R_3 \rightarrow R_2$</td></tr><tr><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">$R_{12}$</td><td align="center">$R_3 \rightarrow R_7 \rightarrow R_{11} \rightarrow R_{12}$</td></tr><tr><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">$R_{16}$</td><td align="center">$R_3 \rightarrow R_7 \rightarrow R_{11} \rightarrow R_{15} \rightarrow R_{16}$</td></tr></tbody></table><h2 id="4-3-运行阶段"><a href="#4-3-运行阶段" class="headerlink" title="4.3 运行阶段"></a>4.3 运行阶段</h2><p>在运行阶段，网络中的所有路由器都需要定期将其入站数据包的数量记录为流量模式，并将它们发送到边缘路由器。然后，每个边缘路由器都可以将流量模式输入到其DBA，以获得到其他边缘路由器的下一个节点。此外，由于每个边缘路由器都获得其他路由器的DBAs的参数$\theta$，因此它可以构建网络中的任何DBA并计算从任何路由器到任何目的地边缘路由器的下一个节点。因此，每个边缘路由器可以利用下一个节点信息来构建从自身到所有其他边缘路由器的整个路径。该算法在算法2中示出。这里，我们使用$N$个元素的数组$TP[N]$来保存网络中$N$个路由器的入站分组数以表示流量模式，并且$\theta[N - I][N - 1]$保存网络中所有DBAs的参数。另一个阵列$\varepsilon R[N-I]$用于保存网络中边缘路由器的序列号，因为它们不是连续的。在实际网络情况下，$\varepsilon R [N-I]$用于保存所有目标路由器的IP地址。运行算法2后，每个边缘路由器都可以获得DBA的输出，以构建到$(N - I - 1)$个边缘路由器的路径。我们可以使用矩阵$NR[N][N-I-1]$来保存这些DBA的结果，这些DBA可用于构建到所有其他边缘路由器的整个路径。表1是路由器$R_3$中内置的路由表，图2示出了构建从$R_3$到$R_{16}$的整个路径的过程的示例。</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_06.png" width="80%"><h1 id="5-复杂性分析"><a href="#5-复杂性分析" class="headerlink" title="5. 复杂性分析"></a>5. 复杂性分析</h1><p>在本节中，我们分析了在所考虑的SDR上运行所提出的基于深度学习的路由策略的算法复杂度和时间成本。 我们的分析主要集中在训练阶段和运行阶段的算法复杂度的数值分析，通过计算加法运算的次数+，减法运算-，乘法运算×，除法运算÷，平方根运算$\sqrt{}$，指数运算$e^x$和否定操作。为了清楚地表达，每种操作的时间成本由ADD，SUB，MUL，DIV，SQRT，EXP和NEG表示。 然后，我们评估并比较在GPU和CPU上运行两个阶段的时间成本。</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_07.png" width="80%"><h2 id="5-1-训练阶段的复杂性分析"><a href="#5-1-训练阶段的复杂性分析" class="headerlink" title="5.1 训练阶段的复杂性分析"></a>5.1 训练阶段的复杂性分析</h2><p>训练阶段的主要过程包括训练每个RBM并对算法1中所示的整个DBA进行微调。每个RBM的训练算法在算法3中示出，算法3是无监督的训练过程。 假设可见层和隐藏层中的单元数分别为$n_v$和$n_h$。 训练集的数量是$m$。 首先，从算法3的步骤1到步骤4，我们需要初始化$w$，$a$，$b$和$\Delta w$，$\Delta a$，$\Delta b$。 然后，我们重复利用所有训练样例来更新$\Delta w_{ji}$，$\Delta a_i$，$\Delta b_j$的值，用CD的方法调整$w$，$a$，$b$ [30]。 如步骤7至步骤19所示，CD方法主要由两个周期组成。 第一个周期是采用吉布斯采样的方法，根据步骤7到步骤14所示的条件概率分布得到$h_j$和$v_i^{\prime}$的样本值。其次，获得的样本值$v_i^{\prime}$用于更新$\Delta w_{ji}$，$\Delta a_i$，$\Delta b_j$，根据步骤15至步骤19。因此，$\Delta w_{ji}$，$\Delta a_i$，$\Delta b_j$的值可用于更新步骤21至步骤25中所示的$w_{ji}$，$a_i$，$b_j$。整个训练过程重复$r_1$次，取$r_1((3m + 1)n_v n_h + 3mn_v + (2m + 1)n_h)ADD + r_1(mn_v n_h + (m + 1)n_v + mn_h)SUB + r_1((4m + 6)n_v n_h + n_v + n_h)MUL + r_1(2n_v n_h + (m + 1)n_v + mn_h)DIV + r_1 n_v n_h(EXP + NEG + SQRT)$</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于第一RBM的可见层满足3.2节中提到的高斯分布，为了训练第一个RBM，我们需要分别计算表示标准偏差和单位i的平均值的$\sigma_i$和$(a_i + \sigma\sum_j h_j w_{ji})$。 该步骤需要$2N(m - 1)\ ADD，Nm\ SUB，Nm\ MUL，2N\ DIV和N\ SQRT$操作。 还应注意，当训练第一RBM时，应将可见层的条件概率分布修改为等式15.第一RBM与其他RBM的时间成本的差异可忽略不计。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在完成第一步的复杂性分析之后，我们转向第二步，其采用等式18中定义的成本函数的随机梯度下降来微调权重和偏差的值。算法4中显示了第二步的详细过程，主要包括四个操作：前馈传递（步骤3到步骤11），反向传播（步骤12到步骤19），更新$w，b$的值（步骤20到步骤27），并计算成本函数（步骤29至步骤43）。如从步骤3到步骤11的前馈过程所示，计算每层中每个单元的加权值$z_j^{(l)}$和激活值$u_j^{(l)}$。这里选择的激活函数是$sigmoid$函数，然后$u_j^{(l)} = 1/(1 + e^{-z_j^{(l)}})$。因此，我们可以得到最后一层的误差$\delta_i^{(L)}$，它被定义为最后一层和标记输出的激活值之间的差异，如步骤13所示。作为最后一层中的单位值是第一层中单位的值逐层传播的结果，最后一层的误差是由先前层的误差引起的。步骤15至步骤19显示如何利用第$l^{th}$层的误差$\delta_i^{(l)}$，根据两层之间的关系计算第$(l - 1)^{th}$层的误差$\delta_i^{(l - 1)}$，这是一个向后传播过程。然后，根据步骤20到27，可以采用每层的误差$\delta_i^{(l)}$来更新$w，b$的值。在获得$w，b$的更新值之后，我们可以重新计算其值。成本函数$C$，其步骤从步骤29到43显示。然后，可以确认是否应该根据$C$的值执行新的迭代。如果我们假设算法迭代$r_2$次，则总时间成本是$r_2((4m + 1)\sum_{l = 2}^L n_l n_{l - 1} - mn_1 n_2 + m(\sum_{l = 2}^L n_l + 2n_L) + 1)ADD + r_2 m(2\sum_{l = 2}^L n_l n_{l - 1} - n_1 n_2 + \sum_{l = 2}^L n_l + 4n_L)SUB + r_2((8m + 1)\sum_{l = 2}^L n_l n_{l - 1} - mn_1 n_2 + m\sum_{l = 2}^L n_l + 2mn_L + 1)MUL + r_2(2\sum_{l = 2}^L n_l + 2)DIV$</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_08.png" width="80%"><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在获得用于训练每个DBA的不同操作数的数量之后，我们理论上可以分析利用GPU（Nvidia Titan X Pascal）或价格可比较的CPU（Intel i7-6900K）来执行计算的时间成本。 GPU，Titan X，有28个SM，每个SM可以在一个时钟周期内运行128次32位浮点运算。 CPU，Intel i7-6900K，有8个内核和16个线程。我们选择的不同算术操作数的延迟分别为$ADD/SUB，MUL和DIV$操作的3个，5个和15个时钟周期[35]。由于$EXP，SQRT和NEG$操作数的数量远少于其他操作数的数量，因此忽略这些操作数EXP，SQRT和NEG的时间成本是合理的。训练样本的数量是100000$(m = 100000)$，并且$r_1$和$r_2$的值都假设为10000。然后，我们可以计算在GPU和CPU上运行的算法的时间成本值，如图5所示。可以发现基于GPU的SDR的时间成本的对数值小于2小而不是基于CPU的。这表明基于GPU的SDR用于训练所提出的深度学习架构，其性能比基于CPU的SDR快100多倍。尽管当路由器数量为1000时基于GPU的SDR的时间成本超过1000秒，但SDR的训练阶段可以离线操作以避免网络性能下降。</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_09.png" width="80%"> - 图5：所选GPU和基于CPU的SDR的培训阶段的时间成本 <img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_10.png" width="80%"> - 图6：所选GPU和基于CPU的SDR的运行阶段的时间成本<h2 id="5-2-运行阶段的复杂性分析"><a href="#5-2-运行阶段的复杂性分析" class="headerlink" title="5.2 运行阶段的复杂性分析"></a>5.2 运行阶段的复杂性分析</h2><p>在本节中，我们将分析在运行阶段提出的路由策略的时间成本。如上所述，训练阶段可以被视为SDR的初始化时段。因此，SDR主要在运行阶段工作。运行阶段的详细过程是前馈传播，可以认为与算法4中的步骤3到11相同。如前面第4.3节所述，运行阶段仅在边缘路由器中执行，并且每个边缘路由器仅构造从自身到所有其他边缘路由器的路径。因此，在运行阶段，每个边缘路由器只需要运行DBA，DBA计算其路径中存在的下一个节点。由于一条路径中路由器数量的不确定性，有必要假设一条路径中的平均节点数为A.因此，每个边缘路由器都需要运行$(N-I-1)A\ DBAs$。因此，每个边缘路由器构造其路径的时间成本是$(N - 1 - 1)A \sum_{l = 2}^L n_l(n_{l-1} + 1)ADD + (N - I - 1)A \sum_{l = 2}^L n_l n_{l - 1} MUL + (N - I - 1)A \sum_{l = 2}^L n_l(DIV + EXP + NEG)$。</p><p>然后，我们可以计算所选GPU和基于CPU的SDR上运行阶段的时间成本值，如图6所示.$A$的值设置为$0.2N$。 由于GPU的时间成本的对数值比CPU的时间成本小约2，因此使用GPU比使用基于CPU的SDR运行算法快约100倍。 我们可以发现，当路由器的数量小于400时，GPU的时间成本小于1毫秒，而CPU的时间成本大于100毫秒。 这表明所提出的基于深度学习的路由策略在GPU加速SDR中运行得非常快。</p><p>除了复杂性分析之外，在下一节中，我们还进一步提出了基于仿真的网络性能评估，该评估基于商用路由器构建的骨干网上我们提出的基于深度学习的路由技术。</p><h1 id="6-网络性能评估"><a href="#6-网络性能评估" class="headerlink" title="6. 网络性能评估"></a>6. 网络性能评估</h1><p>本节评估了我们提出的基于深度学习的路由策略在网络性能方面的有效性。为了适应我们对输入和输出的表征，使用了C ++ / WILL-API [16]，因为它提供了DBA库，这在其他模拟器中是不可用的，例如Caffe和Microsoft Cognitive Toolkit [36]。因此，我们使用C ++ / WILL-API作为仿真框架。在模拟中，所有路由器的计算都在具有六核i7 3.3 Ghz处理器和16 GB RAM的工作站上进行。由于我们考虑的网络中所有路由器的计算都外包给一台机器，因此将模拟限制在小型网络是合理的。因此，我们考虑如图2所示的中型有线骨干网络，而不是全尺寸核心网络拓扑。值得注意的是，这种模拟规模足以证明所提出的基于深度学习的路由策略优于诸如OSPF的传统路由策略。如第3.1节所述，只有边缘路由器生成数据包，这些数据包发往边缘路由器，而内部路由器只转发数据包。另一方面，所有路由器都可以生成信令包。此外，信令数据包由流量模式组成，并且发往我们提案中的边缘路由器，而所有路由器都使用OSPF信令数据包来交换OSPF协议中的路由表。数据包和信令包的大小设置为1 kb。链路容量设置为20 Gbps。在这里，我们假设每个路由器都有一个无限的缓冲区。如前所述，我们需要使用DBA的监督培训，培训数据应包括流量数据和后续节点。然而，公共网站[34]提供的最实际的流量跟踪包括混合的路由协议，这些协议很难用于监督培训。此外，由于本文的目的是评估将深度学习应用于路由的性能，因此选择现有的路由协议作为仿真的基准是合理的。由于实际交通数据来自使用混合路由协议的网络，如果我们使用数据来训练我们的深度学习架构，那么将所提出的路由策略的性能与我们考虑的基准路由协议进行比较是不公平的。因此，在我们的模拟中，我们首先运行OSPF协议，在所考虑的网络中构建路由表，并记录流量模式和相应的路径。因此，我们可以利用记录的流量模式和相应的路径来构建标记数据，以便在训练阶段训练DBA。</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_11.png" width="80%"> - 图7：不同DBA的均方误差（MSEs）。<p>在本节中，我们首先评估给定核心网络的DBA的精度，然后我们决定隐藏层的数量和每个隐藏层所需的单元数。 我们还对输入和输出的不同特征描述策略进行了比较，并证明我们的提议具有最高的精度和最低的复杂性。 然后，从三个方面将我们提出的路由策略的网络性能与OSPF的网络性能进行比较，即信令开销，网络吞吐量和每跳的平均延迟。</p><h2 id="6-1-DBA精度分析"><a href="#6-1-DBA精度分析" class="headerlink" title="6.1 DBA精度分析"></a>6.1 DBA精度分析</h2><p>由于图2所示网络中的路由器数量为16，因此对于每个DBA，输入和输出层中的单元数均为16.在我们的模拟中，训练数据的数量为100,000。 为了确定每个DBA的隐藏层数和每个隐藏层中的单元数，我们培训不同的DBA。 测量DBA的预测误差率的均方误差（MSE）在图7中给出。可以注意到，由每层中的4层和16或18个单元组成的DBA具有最小的MSE值。 考虑到隐藏层中的更多单元意味着更复杂，我们选择DBA，其中每个隐藏层具有2个隐藏层和16个单元。</p><p>为了阐明我们提出的深度学习系统模型的输入和输出，请参考表2.该表给出了具有16个路由器的网络中五个结构的错误率。第一行表示集中式路由控制。输入是16个路由器的最后时间间隔中的流量模式，而输出给出网络中任何两个边缘路由器之间的整个路径。我们可以发现输出层中的单元数超过30,000，其结构变得极其复杂，导致精度差。以下两行中显示的结构都使用一个深度学习系统来输出整个路径。它们之间的主要区别如下。第二种结构使用16×16矩阵来显示路径，矩阵中的元素具有二进制值。另一方面，第三结构输出向量，其中一些元素的值表示在路径中选择的路由器。我们可以发现第二和第三结构的错误率分别高达70％和45％。如果我们选择下一个节点作为最后两行中指示的输出，我们可以发现错误率仅为5％。这两种结构使用我们提出的输入和输出模型，第四种结构使用仅1个时间间隔的流量模式，而最终结构使用三个时间间隔的流量模式作为输入。两个结构中的输出层均由16个单元组成，并输出16维向量，其中只有一个元素的值为1表示路径中的下一个路由器。尽管这两种结构具有相同的性能，但最终结构比第四种结构复杂得多，因为输入层中的单元更多。因此，与其他策略相比，我们选择的第四种结构具有最低的错误率和最简单的结构。</p><h2 id="6-2-网络性能分析"><a href="#6-2-网络性能分析" class="headerlink" title="6.2 网络性能分析"></a>6.2 网络性能分析</h2><p>在运行阶段，我们选择OSPF作为基准方法来比较所提出的基于深度学习的路由策略。为了比较各种网络负载下的性能，我们更改数据生成速率并记录网络信令开销，吞吐量和每跳平均延迟的值。信令间隔固定为0.25秒。图8（a）和图8（b）比较了当数据生成速率从1.44Gbps变为2.208Gbps时成功传送的信令分组的数量和网络吞吐量与两种路由策略。图8（c）比较了当数据生成速率从1.5168 Gbps增加到1.5744 Gbps时两种情况下每跳平均延迟的变化。在图8（a）中，我们可以发现在我们的提议中成功传送的信令分组的数量几乎保持不变，这是正常的，因为信令间隔和模拟时间都是固定的。然而，在使用传统OSPF协议的网络中，当数据生成速率大于1.536Gbps时，成功传送的信令分组的数量逐渐减少，这可以通过业务拥塞和随后增加的一些信令分组的丢失来解释。可以注意到，传统情况下的信令分组的数量远远高于我们的提议中的数量。这是因为在我们的提议中，每个路由器只需要将信令数据包发送到边缘路由器以计算路由路径，而在OSPF中，每个路由器都需要将信令数据包泛洪到网络中的所有其他路由器。信令分组数量的差异会影响网络吞吐量和每跳的平均延迟。图8（b）表明我们提案的吞吐量随数据生成速率线性增加。但是，在使用OSPF的网络中，吞吐量在数据生成速率达到1.536 Gbps之前线性增加，之后吞吐量增长相当缓慢。在图8（c）中更清楚地示出了两种路由策略中的性能差异，其示出了随着网络开销的增加，每跳的平均延迟的变化。可以观察到，当数据生成速率低于1.5456 Gbps时，由于我们的提议中的DBA使用来自OSPF的数据进行训练，因此两种情况下每跳的平均延迟几乎相同。因此，可以得出结论，我们的DBA培训是成功的，因为它可以提供与OSPF相同的输出。但是，在数据生成速率超过1.5456 Gbps之后，OSPF中每跳的平均延迟增加，而我们的提议仍然不受影响。这可以通过交通拥堵的发生来解释，当使用OSPF的网络中的数据生成速率高于1.5456 Gbps时，导致吞吐量降低并且每跳的平均延迟增加。相反，对于所示的数据生成速率，基于深度学习的所提出的路由策略实现了低得多的信令开销并且避免了业务拥塞问题。</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_02_18_01.png" width="80%"> - 图8：在信令开销，吞吐量和每跳平均延迟方面，我们的提议和基准方法（OSPF）中不同网络负载下的网络性能比较。 <img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_02_18_02.png" width="80%"> - 图9：在信令开销，吞吐量和每跳平均延迟方面，我们的提议和基准方法（OSPF）中不同信令间隔下的网络性能比较。<p>在利用各种数据生成速率分析网络性能之后，我们使用两种不同的路由策略进一步分析和比较不同信令开销对网络性能的影响。在这里，我们将数据生成速率固定为1.536 Gbps，并将信令间隔从260 ms更改为240 ms。图图9示出了当信令间隔分别为260ms，250ms和240ms时两种情况下的信令开销，吞吐量和每跳平均延迟的结果。在图9（a）中，我们可以发现我们的提议中的信令开销远低于OSPF的情况。在图中如图9（b）和9（c）所示，我们可以清楚地看到信令开销对两种情况的性能的影响。在图9（b）中，当信令间隔不同时，我们的提议的吞吐量几乎保持不变。另一方面，当信令间隔为240ms时，OSPF的吞吐量远低于信令间隔为260ms或250ms时的吞吐量。因此，可以推断当信令间隔是240ms时，使用OSPF对网络发生业务拥塞。图9（c）中的结果进一步证明了这一点，该结果表明，当信令间隔为240ms时，OSPF的每跳平均延迟几乎是信令间隔为260ms或250ms时的两倍。此外，我们可以发现，当信令间隔为260 ms或250 ms时，OSPF的每跳平均延迟几乎与我们的提议相同。</p><p>通过比较使用OSPF的网络性能和我们提出的基于深度学习的路由策略，我们可以发现我们提出的基于深度学习的路由策略具有更低的信令开销，从而实现更好的流量控制。我们的提议中信令开销较低的原因是只有边缘路由器而不是所有路由器都需要信令数据包，因为边缘路由器可以使用训练有素的DBA来构建整个路径，而内部路由器不需要信令数据包来计算下一个节点。但是，在具有OSPF的网络中，边缘路由器不能利用所有链路的当前权值来构建实际的整个路径，因为通过OSPF计算的路径仅适用于当前网络状态。但是在数据包传输过程中，网络流量正在发生变化，然后决定的路径变得不合适。另一方面，对于基于深度学习的路由策略，如果我们利用流量模式和实际路径来训练它们，DBA可以找到当前流量模式和真实路径之间的复杂关系。因此，边缘路由器可以利用训练有素的DBA来构建仅具有当前网络信息的整个路径。</p><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本文中，我们解释了重新思考核心路由器架构和骨干网络路由策略的重要性，以满足不断变化的网络需求并应对未来几天的大量流量增长。在这种情况下，我们探索了当前的SDR架构，并设想深度学习（最近作为一种有前途的机器学习技术出现）可用于计算路由路径而不是传统的路由协议。这可以大大改善骨干网络流量控制。考虑到当前GPU加速的SDR实现了大规模并行计算，我们提出了一种监督深度学习系统来利用流量模式直接计算路径，这与传统的基于规则的路由不同。仿真结果表明，所提出的基于深度学习的路由策略在网络分组传输吞吐量和每跳平均延迟方面优于传统OSPF，因为我们的提议具有低得多的信令开销。这表明路由计算从传统的基于规则的策略向深度学习的转变可以大大改善骨干网络控制。此外，我们分析了我们提出的路由策略的复杂性，以评估GPU加速的SDR比基于CPU的SDR更有效地运行所提出的算法。由于各种终端接入网络以获得不同类型的服务，我们未来的研究将尝试应用深度学习技术来建模多个网络指标之间的复杂关系，以便更好地进行路由路径管理。</p></div><div class="reward-container"><div></div><button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="王钰博 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="王钰博 支付宝"><p>支付宝</p></div></div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2018/12/21/2018-12-21-machineLearningAlgorithmNotes/" rel="prev" title="机器学习中的算法笔记"><i class="fa fa-chevron-left"></i> 机器学习中的算法笔记</a></div><div class="post-nav-item"><a href="/2019/01/02/2019-01-02-glossary/" rel="next" title="名词解释">名词解释 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="comments" id="comments"></div></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#抬头"><span class="nav-number">1.</span> <span class="nav-text">抬头</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#题目"><span class="nav-number">2.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#作者"><span class="nav-number">3.</span> <span class="nav-text">作者</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#摘要"><span class="nav-number">4.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#索引术语"><span class="nav-number">5.</span> <span class="nav-text">索引术语</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-简介"><span class="nav-number">6.</span> <span class="nav-text">1. 简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-相关研究工作"><span class="nav-number">7.</span> <span class="nav-text">2. 相关研究工作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-SDR相关研究工作"><span class="nav-number">7.1.</span> <span class="nav-text">2.1 SDR相关研究工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-深度学习与机器智能路由策略的相关研究工作"><span class="nav-number">7.2.</span> <span class="nav-text">2.2 深度学习与机器智能路由策略的相关研究工作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-基于深度学习的路由策略设计"><span class="nav-number">8.</span> <span class="nav-text">3. 基于深度学习的路由策略设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-输入和输出设计"><span class="nav-number">8.1.</span> <span class="nav-text">3.1 输入和输出设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-深度学习结构设计"><span class="nav-number">8.2.</span> <span class="nav-text">3.2 深度学习结构设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-考虑路由器架构"><span class="nav-number">8.3.</span> <span class="nav-text">3.3 考虑路由器架构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-基于建议的深度学习路由策略的程序"><span class="nav-number">9.</span> <span class="nav-text">4 基于建议的深度学习路由策略的程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-初始化阶段"><span class="nav-number">9.1.</span> <span class="nav-text">4.1 初始化阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-训练阶段"><span class="nav-number">9.2.</span> <span class="nav-text">4.2 训练阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-运行阶段"><span class="nav-number">9.3.</span> <span class="nav-text">4.3 运行阶段</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-复杂性分析"><span class="nav-number">10.</span> <span class="nav-text">5. 复杂性分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-训练阶段的复杂性分析"><span class="nav-number">10.1.</span> <span class="nav-text">5.1 训练阶段的复杂性分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-运行阶段的复杂性分析"><span class="nav-number">10.2.</span> <span class="nav-text">5.2 运行阶段的复杂性分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-网络性能评估"><span class="nav-number">11.</span> <span class="nav-text">6. 网络性能评估</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-DBA精度分析"><span class="nav-number">11.1.</span> <span class="nav-text">6.1 DBA精度分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-网络性能分析"><span class="nav-number">11.2.</span> <span class="nav-text">6.2 网络性能分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-总结"><span class="nav-number">12.</span> <span class="nav-text">7. 总结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="王钰博" src="/images/12.jpg"><p class="site-author-name" itemprop="name">王钰博</p><div class="site-description" itemprop="description">个人博客</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">66</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Githubwyb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Githubwyb" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:1061322005@qq.com" title="E-Mail → mailto:1061322005@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">王钰博</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">219k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">3:19</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.6.0</div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e1986d4e4e2d132" async></script></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/jquery-3.4.1.min.js"></script><script src="/lib/fancybox/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script type="text/x-mathjax-config">MathJax.Ajax.config.path['mhchem'] = '/lib/mathjax-mhchem';

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        extensions: ['[mhchem]/mhchem.js'],
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });</script><script>NexT.utils.getScript('/lib/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);</script><script>NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'qmLbUHV1HOr841BOYkl84riu-gzGzoHsz',
    appKey: 'j4fgTcf1yHRDD5X3HUH5EH95',
    placeholder: "^_^ happy everyday!",
    avatar: 'wavatar',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":true,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"bottom":-30,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body><script type="text/javascript" src="/lib/jquery-3.4.1.min.js"></script><script type="text/javascript" src="/js/src/love.js"></script></html>